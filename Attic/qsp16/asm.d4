\ qsp16 assembler

\ Inspired mostly by Chuck Moore's 20-bit `assembler' for the x21 series

\ Assumes a 32-bit host Forth!
\ Right now everything is postfix, but this can be changed.

dForth [if]
( Metacompiler vocabs)
vocab outside  ( used outside of target definitions - the `meta' forth)
vocab assembler
vocab inside   ( used inside target definitions - the `meta' compiler)
vocab target   ( the target words)

compiler definitions
comment %%
: \f   ( compile from forth)        forth   \chain ;  %%
: \o   ( compile from outside)      outside \chain ;
: \i   ( compile from inside)        inside \chain ;
: \a   ( compile from assembler)  assembler \chain ;
: \t   ( compile from target)        target \chain ;
forth definitions

-: ."  (assembling)" ;
-: assembler -"find if  outside -"find if  target -"find  if
      ( not found)  number exit  then then  execute ;
mode assemble

outside definitions
: code   \o here  constant  assemble  does> xxx ;
[then]  \ dForth

\ target memory: 512 16-bit words
create mem   512 2* allot   \ word-addressed, stored little-endian

\ if split and join are defined and do the right thing, use them instead
: lohi>   8 lshift  xor ;
: >hilo   dup 8 rshift  swap 255 and ;

\ _@ & _! address mem by cell
: _@   2* mem +  dup c@  swap 1+ c@  lohi> ;
: _!   2* mem +  >r  >hilo  r@  c!  r> 1+ c! ;

variable _h     \ dictionary pointer, into mem, by cell
variable slot   \ 0 to 16 by 4
variable hw     \ ptr to instruction word being assembled

: >empty   16 slot ! ;    \ signify empty instruction word
: -empty?  16 slot @ xor ;   \ true if instruction word is -not- empty
: _here   _h @ ;
: org   _h !  >empty ;
: _,   _here _!  1 _h +! ;
: xor,   hw @ _@  xor  hw @ _! ;

hex
create mask   7c00 ,  3e0 ,  1f ,    \ slot masks  0, 1, 2
decimal

\ Note that `slot' is only 0 momentarily, and only inside op, .
\ Outside of op, slot is 16 if the instruction word is empty.
: op,   8 slot @ u< if ( slot 3 or empty)  0 slot !  _here hw !  0 _,  then
        slot @  mask + @ and  xor,  4 slot +! ;

hex
: op   421 * constant  does>  @ op, ;

\ data movement ops
04 op pshr   05 op popr   06 op xx_1   07 op xx_2
08 op ldr    09 op lda    0a op ldr+   0b op ldp+
0c op str    0d op sta    0e op str+   0f op sta+

\ ALU ops
10 op eqz    11 op inv    12 op shr    13 op shl
14 op nop    15 op swap'  16 op step   17 op add
18 op dup'   19 op xx_3   1a op psh0   1b op psh1
1c op xx_4   1d op drop'  1e op xor'   1f op and'
decimal

: #'   ldp+  _, ;  ( make a literal)
: >full   begin  slot @ 12 xor  while  nop  repeat ;
: >next   -empty? if  >full >empty  then ;  \ always empty when we're done
: begin'   >next  _here ;

\ `far' is a bit subtle. The only time we can put a jump in slot 1 is if
\ we're already in slot 1, and the xor of `hw' and the destination address
\ shows that all the differences are in the low 5 bits. Otherwise we assume
\ the jump will be put into slot 0 at `_here' and we check its range from
\ there to the destination, and complain if the address won't fit in 10 bits.
\ Remember that, at the time the jump is taken, that the hardware pc has the
\ value that at compile time is in _h - ie, _here.

: ?span   ( to from - to')
   over xor  1024 u< if  1023 and  exit then
   hex ." jump to " dup u. ." out of range" ;

: far
   slot @ 4 = if  _here over xor  32 u< if  31 and  exit then then
   begin' ?span ;

: jmp,   swap  far  swap @ op,  xor,  >empty ;
: _jmp   op  does>  jmp, ;
hex
: _jsr   op  does>  jmp,  8000 xor, ;
: ret   >full >empty  8000 xor, ;

\ jump and jump-to-subroutine
00 _jmp jmp    01 _jmp jmp_?   02 _jmp jmpnc   03 _jmp jmpz
00 _jsr jsr    01 _jsr jsr_?   02 _jsr jsrnc   03 _jsr jsrz
decimal

\ forward jumps, for simplicity, are forced to use slot 0
: if'   >next  0 jmpz  hw @ ;
: -if'   >next  0  jmpnc  hw @ ;
: ahead'   >next  0 jmp  hw @ ;
: then'   begin' over  ?span  over _@  xor  swap _! ;
: else'  ( considered harmful)  ahead'  swap  then' ;
: while'   if'  swap ;
: -while'   -if'  swap ;
: again'   jmp ;
: until'   jmpz ;
: -until'   jmpnc ;
: repeat'   again'  then' ;

: :'   begin'  constant  does> @  jsr ;

\ This could be automated with a smarter ;' or exit'
: ;'   ret ;
hex
: -;'   ( tail-convert)  hw @ _@  7fff and  hw @ _! ;  ( clear `jsr' bit)
decimal
   
-1 [if]
( Test code)

( mem dump)
: 5#   # # # # # ;
: '_   char _ hold ;
: .w   binary  0 <# 5# '_ 5# '_ 5# '_ # #> type ;
: .a   hex  0 <# # # # # char @ hold #> type space ;
: du   for  cr  dup .a  dup _@ .w  1+ next  hex ;
[then]

hex

0 [if]
( easy stuff first)
0 org
pshr popr ldr
lda ldr+ c0de #'
str sta str+
sta+ eqz inv
shr shl nop
swap' step add
dup' psh0 psh1
drop' xor' and'
[then]

0 [if]
0 org  \ this is a copy of cpu.mem
0022 jmp

psh0 eqz eqz ret
psh1 dup' inv
add 0006 jmpz
psh1 dup' xor'
0007 jmpz
0000 jsr
psh0 0009 jmpnc
drop' 0000 jsr
inv dup' add
inv 0008 jmpnc
dup' add drop' ret

pshr 0dead #' dup'
popr str ldr
sta lda ldr+
sta+ str+ drop' ret

psh0 eqz psh1
step step shr
shl add shr
c0de #' and' drop' ret

0020 org
0000 jmp

psh1 ret

0011 jsr
0002 jsr
000c jsrnc
0000 jmp
0ffff _,

0001 jsr
eqz 002b jsrz
psh1 0021 jsr
xor' 002c jsrz
0000 jmp

pshr 0ffc0 #' popr
psh1 step dup'
popr 002e jmpnc

drop' pshr drop'
0030 jmp
[then]   \ end of cpu.mem

-1 [if]  \ this is a copy of chip.mem
0000 org
0021 jmp
popr swap' pshr
inv psh1 add
swap' popr swap'
ldr+ sta+ popr
psh1 add pshr
0004 jmpnc
pshr drop' drop'
drop' ret

( 0009)
psh1 dup' sta
lda swap'
000a jmpz
popr psh0 lda
pshr sta drop'
psh1 lda xor'
000e jmpz
ret

( 0011)
0d0a #' swap' nop

( 0013)
dup' shr shr
shr shr shr
shr shr shr
0017 jsr

( 0017)
psh0 sta nop
psh1 0003 #' sta
lda swap'
001a jmpz
shl psh1 sta
psh1 lda xor'
001d jmpz
sta drop' ret

( 0020)
0000 jmp

( 0021)
pshr 4000 #' 8000 #'
0003 #' popr
0001 jsr

( 0027)
pshr 8000 #' 4040 #'
0003 #' popr 
0001 jsr

( 0024)
0011 jsr
0009 jsr
0017 jsr
002e jmp

[then]  \ end of chip.mem





