( qsp16 simulator)

( 2001-jan-25. daf. Created)

( Stacks are 64 entries, circular. Implemented as `full' stacks: the top of
  stack is addressed by the stack pointer.)

create RS  65 cells allot  ( first is pointer)
create OS  65 cells allot  ( ditto)

RS off  OS off  ( empty)

: wrap   63 cells and  ;
: qpush  ( n stk)
   push r@ @ ( offset)      cell+ wrap dup r@ !   pop + cell+ ( ptr) !  ;
: qpop   ( stk - n)
   push r@ @ ( offset)  dup cell- wrap     r@ !   pop + cell+ ( ptr) @  ;

: 'top  ( stk - a)  @+ +  ;

-1 [if]
: qpushes  ( n stk)  swap  1 swap for  2dup swap qpush  1+  next  2drop  ;
: qpops    ( n stk)  swap         for  dup qpop u.          next   drop  ;

1 OS qpush  2 OS qpush  3 OS qpush  4 OS qpush
1 RS qpush  2 RS qpush  3 RS qpush  4 RS qpush
[then]

( Opcode map.

== Control group ==
  op  i15  for slots 0-2
  00   0   jmp
  01   0   jmp_?   undefined conditional jump
  02   0   jmpnc   if carry clear
  03   0   jmpz    if A is zero; pop OS -> A
  00   1   jsr     jmp and push RS
  01   1   jsr_?   undefined conditional jsr; jmp and push RS
  02   1   jsrnc   if carry clear, jmp and push RS
  03   1   jsrz    if A is zero, jmp and push RS; pop OS -> A

== Move group ==
  04  pshr   push A -> OS; pop RS -> A -- backwards from Forth!
  05  popr   push A -> RS; pop OS -> A -- ditto!

  06  xx_1   undefined
  07  xx_2   undefined

== Memory group ==
  08  ldr    read data using top of RS as addr; push onto OS
  09  lda    read data using top A as addr; push onto OS
  0a  ldr+   read data using top of RS as addr; push onto OS; incr top of RS
  0b  ldp+   read data using P as addr; push onto OS; incr P
  0c  str    pop OS, write it into addr on top of RS
  0d  sta    pop OS, write it into addr in A
  0e  str+   pop OS, write it into addr on top of RS; incr top of RS
  0f  sta+   pop OS, write it into addr in A; incr A

== ALU group ==
  10  eqz    A <- ffff if it was zero, 0 otherwise.
  11  inv    A <- ~A
  12  shr    A <- { CY, A[15:1] }  shift right, shifting carry in at left
  13  shl    A <- { A[14:0], 0 }   shift left, shifting in a 0 at right
  14  nop    twiddle thumbs
  15  swap   exchange A <-> top of OS
  16  step   if A[0] = 1, { CY, A } <- A + top OS. Otherwise, do nothing.
  17  add    { CY, A } <- A + top OS.
  18  dup    push A onto OS
  19  xx_3   undef, but most of the logic is there to implement `over'
  1a  psh0   push A onto OS, set A to 0
  1b  psh1   push A onto OS, set A to 1
  1c  xx_4   undef, but most of the logic is there to implement `nip'
  1d  drop   A <- pop OS
  1e  xor    A <- A ^ top OS
  1f  and    A <- A & top OS

If there were no control group instructions in slots 0-2, we execute one of
two slot 3 opcodes, depending on i15.

   0  next   using P as addr, fetch next instruction group and execute it;
             increment P
   1  ret    using top RS as addr, fetch next instruction group and 
             execute it; P <- incremented top RS; pop RS)


: binop   OS qpop  a_reg @  ??  ;
here ]
   jmp  jmp_?  jmpnc  jmpz   pshr  popr  xx_1  xx_2  ( 00 - 07)
   ldr  lda    ldr+   ldp+   str   sta   str+  sta+  ( 08 - 0f)
   eqz  inv    shr    shl    nop   swap  step  add   ( 10 - 18)
   dup  xx_3   psh0   psh1   xx_4  drop  xor   and   ( 19 - 1f)  [

: opcode  ( i)  31 and  which