$Id$

muFORTH README

Why muforth?
^^^^^^^^^^^^

Why write another Forth when there are so many around? Because
everyone else's Forth is wrong. ;-)

First of all, muforth is most emphatically _not_ ANS-compatible. It
would be silly to write another when there are perfectly good ones
available. I wanted instead to build a Forth with specific features,
several of which are shamelessly stolen from Chuck Moore's colorforth
(http://colorforth.com).

I think I started with the question, "What would colorforth look like
without color?" and went from there. I wanted a substrate for experiments,
a good metacompiler, and something small and simple.

Why the name?
^^^^^^^^^^^^^
From startup.mu4:

  The idea is to move as much code as possible -out- of the Forth kernel.
  Hence the name: "mu" is the Greek letter often used in engineering to
  represent "micro". I had called it "nu" Forth, because it was new, but I
  like this nu Greek letter better.



Why another Forth?
^^^^^^^^^^^^^^^^^^

In other words, why not keep using dforth (an earlier Linux Forth I wrote
that I have used successfully on several projects)?

dforth had some qualities that I now construed as defects, including:

* written entirely in 386 assembler;
* trapped into Linux kernel directly, eschewing the C library;

* implemented via indirect-threaded code (ITC), an elegant technique, but I
  was interested in exporing alternatives;

* a very big kernel, with lots of task-specific code

I wanted to go the other way. In particular, I was wishing for:
My desiderata included the following:

* a kernel, written in C, that is the smallest possible kernel
  capable of compiling Forth colon definitions (ie, it is self-
  bootstrapping);

* a simple native-code compiler;
* a tail-recursive implementation;
* a new parser, tokenizer, and interpreter

* colorforth's terseness but implemented without color and without
  reinventing the OS.


Issues with C
^^^^^^^^^^^^^
* stack calling convention
* gcc won't let me keep global var in register, so sp is in memory, making
  native code clomsy and a bit inefficient.
* mixing C and Forth
* strings

When earlier implementing dforth, I initially wanted to write it in C; but
I was also committed to doing an ITC Forth, and doing that in C I found to
be very clumsy. I bit the bullet and wrote in assembler, which was quite
liberating. The only real downside was the frustration of using m4 as a
macro processor - I needed more than the C preprocessor could give me, but
I grew to _hate_ m4. I found using it to be a case of programming by
trial-and-error, rather than something on which that I could bring
knowledge and experience to bear.

This time around I was willing to give on a few things in order to be able
to write in C.

Of course, muforth is far from architecture-neutral, as it contains a
native code compiler that compiles little chunks of x86 machine code. This
would need to be changed to run on other architectures. I tried to keep it
simple, so this shouldn't be hard. A few hours' work, perhaps, once you
understand the structure of muforth.

Oddities and idiosyncrasies
^^^^^^^^^^^^^^^^^^^^^^^^^^^

muforth has several odd differences from more conventional (old-school?)
Forths. Most of these differences result from the from Forth (many stemming
from the colorforth ideas)

some of these are also qualities of colorforth; others are intentional or
the result of the implementation technique(s)

First talk about the things derived from CF:

Ideas from colorforth
^^^^^^^^^^^^^^^^^^^^^

In colorforth the color of a word specifies what the interpreter should do
with it. Red means define a new word; the token in red is the name of the
new word. Yellow means execute; green means compile. There are some other
colors as well, but for our discussion these are the most interesting.

In order to be able to calculate constants inside a colon definition, you
need only switch to yellow, do the calculation, and then switch back to
green. At the yellow-to-green transition the compiler generates a literal
with the value of the calculation done by the yellow words.

How did we use to do this? Like this:

  : blog  [ 25 80 * ] literal + ;

The word "literal" is a compiler word, which gets executed at compile time;
it compiles a literal from the value on the top of the stack - in this
case, the result of 25 80 *.

But that "literal" is ugly. In colorforth it goes away. I wanted to make it
go away in muforth as well. So what did I do? I made "]" _always_ generate
a literal. If you need to jump out of the compiler (using "["), do
something, and then jump back, you can use "-]". It doesn't create a
literal.

Our example above becomes

  : blog  [ 25 80 * ] + ;

which is much nicer. A few neat examples, from startup.mu4:

  : 0   [ dup dup xor ] ;
  : -1  [ 0 invert ] ;
  : 1   [ -1 negate ] ;


Since there isn't really any compiler "state" in colorforth - each word
tells the interpreter, by its color, how to treat it - there is no need to
bracket definitions with ":" and ";". A red word marks the start of a new
definition; nothing really marks the end. In fact, it's possible, in
colorforth, to write a word whose execution "falls thru" into the next
word. This is considered bad style by some, but assembler programmers over
the years have used it to great advantage. colorforth gives you this
option.

If we don't need to mark the start and end of a word with ":" and ";", why
is there a word called ";" in colorforth? What does it do? It exits from,
or returns from, the current word, but without it any way marking it as
"done". It is like EXIT in more traditional Forths.

I coveted these qualities for muforth, but had the constraint that my
compiler _does_ have state, and does switch back and forth between
interpreting and compiling. So I need ";" to end my words, like it always
has. Now I need two new words:

 * to exit a word "prematurely";
 * to end a word, but "fall thru" to the next word.

The first I called "^" to capture the idea of jumping up out of the word. The
second I called "-;" to indicate that it does part of the work of ";" but
not all. It stops the compiler, but doesn't compile a "return".

More concretely, these words are defined thus:

XXX: copy from interpret.c, compile.c - explain "\"


colorforth has the oddball feature that "if" leaves the top of stack
intact. This can be useful or annoying. I thought it would be interesting
to have _both_ options - destructive and non- - so I defined  "=if" and
"=while" in addition to "if" and "while". "if" and "while" consume the top
of stack; "=if" and "=while" leave it alone.

And, just as in colorforth, there is no "else"! You can always get by
without it, and often the code factoring improves. For example, you can
rewrite

  <test> if  a  else  b  then  c ;

as

  <test> if  a c ^  then  b c ;

colorforth doesn't "smudge" (hide) new definitions until they are complete
- and neither does muforth. This makes writing recursive definitions easy,
but makes redefinition harder (you have to rename the old function first).
I liked the idea of being able to write iterations as syntactically
recursive procedures, as in Lisp; however, I haven't used it much. ;-)


- [ ] -]
- ; -; ^
- =if =while (non-destructive test), but no else!
- tail-recursive looping, Lisp-style
- no smudge or similar, makes recursion easier, but redefition harder nifty

Things taken from cmFORTH (also mostly existed in dforth):
* the names "compiler" and "forth" for the two basic dictionary chains
* the word "\" to mean "compile from compiler"

Then talk about the things that I took from dforth or invented for muforth:

- parser/tokenizer (text v. string type) non-inline strings & separation of
  code & data (applies to creat/does)

- create/does> "constant" implementation
* dictionary "chains" (and why I call them that) (you "link" to them; and
  threads are execution state)
* compiler/interpreter "modes" & metacompilation - same as dforth
  difference of compile-time v run-time search-order

* number parsing code all high-level; not even constants in kernel!
* currently uses GNU make, so gmake on BSD

cmFORTH stuff: names of dict chains, &c.
compiler vs .compiler.
-find

Forgetting
^^^^^^^^^^
muforth does not define the common Forth word "forget", nor does it define
"empty", as colorforth does. In the presence of deferred words, any kind of
"forget" is error-prone. I find it better to quit and reload. This has
never bothered me, or felt limiting in any way. It certainly makes memory
allocation easier. ;-)

Tokenizing the input
^^^^^^^^^^^^^^^^^^^^
This is one of the cool innovations in muforth.

I have defined two kinds of strings: string and text. A string is what you
would expect in Forth: a pointer to the first character, and a length. A
text is something a bit odd. I'll explain.

I discovered, in writing the tokenizer for dforth, that using a string
(pointer and length) and an offset (past what we have seen already) was
clumsy and slow. This is what Forths have traditionally done. The state of
the interpreter is captured by two variables: source and >in. source is a
double variable containing a pointer to the first character, and a length -
a normal string. >in is an offset _past_ the characters that we've looked
at already, in previous calls to the tokenizer.

On every call to the tokenizer you first have to offset the pointer forward
(by >in), past the text you've seen already, and the count backwards (also
by >in), since it counts characters yet to be seen. You're always
offsetting two things. Even when consuming a single character during
scanning you have to increment the pointer, and decrement the count. Two
operations. Clumsy.

Instead, I thought, why not run everything backwards?

If a string is represented by the tuple

  (start, length)

then a text describing the same sequence of bytes in memory would be
represented by the tuple

  (end, -length), where end = address + length.

The type "text" consists of a pointer just past the _end_ of the text, and
a negative offset back from the end to the start. When we start
tokenizing a chunk of text, we set a global offset "first" to "point" to
the first character. But first is really a negative back from the end of
the text.

In this scenario, the current state of the tokenizer is also captured in
two variables: source (a _text_), and first, an offset running from -length
up to 0.

On each call to the tokenizer, first already points _past_ the the text
we've seen already, so we're ready to start looking for a new token. Now
might perhaps be a good time to mention a little secret: muforth has _two_
tokenizers. One - token - assumes that tokens are separated by whitespace,
and skips _leading_ whitespace. The other - parse - takes a delimiter
character and scans for a _trailing_ delimiter, but assumes that the new
token starts at first - it does _not_ try to skip any leading delimiters.

These two routines do not share any code, even though they are
substantially the same code. There simply isn't a good a way to tease them
apart, but they are short enough that I'm not worried about it. ;-)

Ok, back to tokenizing. Let's assume we've called token, and we're going to
skip leading whitespace. first "points" to the first character that we
haven't seen yet. So, while the character at first is whitespace and first
< 0 (not at the end), increment first. Now either we've run out of text, or
we've found a non-whitespace character. Either way, this is the first
character of our token.

We leave first pointing to it, set last = first, and then start scanning
with last, incrementing last as long as it points to a non-whitespace
character and remains < 0. When we reach the end of the token - which
happens either if we find a trailing delimiter, or if we run out of text to
scan, last is left pointing just _past_ the last character of the token. We
capture the presence or absence of the trailing delimiter in a variable
called trailing, which we set to 1 when we start to look for the end of a
token. If the input runs out before we find a delimiter we set trailing to
0.

We've now "bracketed" a token. first points to its first character; last
points just beyond its last character. (These "pointers" are actually both
negative offsets from the end of the source text.) The (start, length)
string tuple for the token is then

  (end + first, last - first)

We consume the token and trailing delimiter (if there was one) from the
input stream by setting

  first = last + trailing.

Now we're ready to look for the next token.

Of course, the astute reader will be wondering about the various boundary
cases when the text runs out. By being careful about trailing, we ensure
that first is never left > 0. At the end of parsing a token it will be <=
0. If no characters were found between first and last, which can only
happen if first = 0, possibly _after_ skipping leading whitespace (think
about it), then last - first will be 0 as well. At end of text we _always_
return the token

  (end, 0)

and the interpreter code is smart enough to recognize this zero-length token
as the end.

* differences between token and parse.

Even though muforth uses the Linux/BSD file system (and has no BLOCK words as
yet) the input words look like those on a BLOCK-based Forth. Why is this?
Source is always read from a -buffer-. The double variable `source' holds
the current address of the next character to read, and the count of
characters left to read. Interactive input is buffered line-by-line. In
this case, `source' points into this line buffer. File input is
memory-mapped. In this case, the -whole source file- is mapped as a single
buffer, and `source' points into it. So we never have to worry about words
crossing buffer boundaries. The miracles of virtual memory!

For this to work under Linux, however, we have to -map- the input
characters so that all whitespace is treated like a space (ASCII 32). The
easiest way is a 256 character lookup table, which is an identity map
except for a handful of control characters: tab, line-feed, return,
form-feed, vertical tab, and I think even backspace. These all map to ASCII
32. I may change this so that -all- control characters map to space.

See `token' for details.

Simple native code compiler
  how compile, works
  tail call conversion
  the role of last, -tail
  stack manipulation
  structure compilers, high-level and low-

Strings and texts
  the different kinds
  non-inline vs jumping over
  counted string representation
  double use of counted strings
  more details about text and scanning process

Dictionary
  structure
  find
  dictionary chains

segue into the interpreter modes, "programmatic" searching, the losingness
of only/also.





