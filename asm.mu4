( $Id$

  This file is part of muFORTH; for project details, visit

     http://nimblemachines.com/browse?show=MuForth

  Copyright 1997-2007 David Frech. All rights reserved, and all wrongs
  reversed.

  Licensed under the Apache License, Version 2.0 [the "License"];
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  or see the file LICENSE in the top directory of this distribution.

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.)

( Of course, for any "new" target - even one designed in 1976 - we need an
  assembler. This is an assembler for the 8080/8085. It includes the two -
  count 'em! - instructions, sim and rim, that Intel added when they
  developed the 8085. Revolutionary! At the same time Zilog was developing
  the Z80 and getting ready to totally blow Intel's x80 market share away.
  Hmm, then what happened to Zilog? They really fumbled the 32bit market.)

( I'm going to use the term "8080" to mean the 8080 and 8085. As mentioned,
  the only difference _to the programmer_ - the hardware is a _lot_ nicer -
  is the two new instructions. You 8080 programmers out there - both of you
  - just don't use those two insns.)

( I'm going to change some of the mnemonics. Most hardware vendors choose
  awful mnemonics. [Thankfully ARM is better than most, though their
  mnemonics do imply a source/dest ordering that doesn't work as well with
  postfix assemblers.] Atmel's AVR is a good example: a decent
  architecture, a somewhat complex insn encoding, and completely awful,
  brain-dead, and confusing mnemonics . The 8080 mnemonics are a mix.
  Some are ok, but others - mostly the "immediate with A" insns - are
  awful. So I'm going to change them. If I remember, I'll note this in the
  definition of the insn.)

( One nice thing about the insn encoding is that, when you look at it with
  your octal glasses on, you see really nice simple patterns. Most insns
  group by first and last octal digit, while the middle digit chooses the
  member of the group. Eg, 302 is the conditional jump group:

  302 jnz
  312 jz
  322 jnc
  332 jc
  342 jpo
  352 jpe
  362 jp
  372 jm)

( I'm considering putting cycle times into the insns. We'll see how that
  works.)

( Space for compiling into. 8080 only has 64k address space.)
64 Ki buffer image

: 0r0  ( reg op - op')      swap  7 and  3 <<  or ;
: b,   ( compile byte)  
: w,   ( compile word, little-endian)  b,  8 >>  b, ;

octal

( Defining words.)                                                ( op)
: op       ( op)          constant  does>  ( op)                    b, ;
: 1reg     ( op)          constant  does>  ( reg op)        0r0     b, ;
: 2reg     ( op)          constant  does>  ( src dst op)    0r0 or  b, ;

: regpair  ( opreg oppair)  10 << or constant
   does>  ( reg op)  over 200 and if ( pair)  10 >> then    0r0     b, ;

: direct   ( op)          constant  does>  ( addr op)               b, w, ;
: ?direct  ( op)          constant  does>  ( addr cond op)  0r0     b, w, ;
: immed    ( op)          constant  does>  ( addr op)               b, b, ;

: 2opreg   ( op)  200 or  constant  does>  ( src op)            or  b, ;
: 2opimm   ( op)  306 or  immed ;
: 2op      ( op)  10 << dup 2opreg 2opimm ;

( Check use of register pairs.)
: ?pair  200 u< if error" needs register pair" then ;

assembler

( Registers.)
0 constant b
1 constant c
2 constant d
3 constant e
4 constant h
5 constant l
6 constant m
7 constant a

( Register pairs have high bit set.)
200 constant bc
202 constant de
204 constant hl
206 constant sp  206 constant psw ( af?)

( Conditions, encoded in the negative, so we can use them
  with "if" and "until".)
: not  1 xor ;
0 constant 0=
2 constant u<   2 constant cs  ( carry set)
4 constant even  ( parity - why did they even bother?)
6 constant 0<

( group 000)
000 op nop
( 010)
( 020)
( 030)
040 op rim  ( 8085 only)
( 050)
060 op sim  ( 8085 only)
( 070)

( group 001 odds)
011 1reg addx  ( intel: dad; mip suggested "index") ( also 031, 051, 071)

( group 002)
( or maybe like zilog just ld & st?)
002 1reg stax ( also 022)
012 1reg ldax ( also 032)
042 direct sthl  ( intel: shld)
052 direct ldhl  ( intel: lhld)
062 direct sta
072 direct lda

( groups 003, 004, 005)
( reg regpair)
  004 003 regpair inc  ( intel: inr, inx)  ( 003 evens)
  005 013 regpair dec  ( intel: dcr, dcx)  ( 003 odds)

( groups 006, 001 evens)
( Similarly to inc/dec; this combines movi and lxi)
( reg regpair)
  006 001 regpair movi

( group 007)
( Hmm: should these be called rola, rora, rlca, rrca, daa, coma, since they
  only work on a? Here is one place where the intel mnemonics are
  COMPLETELY! retarded.)
007 op rol   ( intel: rlc! 8 bits, not thru carry)
017 op ror   ( intel: rrc! ditto)
027 op rolc  ( intel: ral! 9 bits, thru carry)
037 op rorc  ( intel: rar! ditto)
047 op daa
057 op com   ( intel: cma)
067 op setc  ( intel: stc)
077 op comc  ( intel: cmc)

( groups 100 - 107; low order digit is src register)
100 2reg mov
166 op   halt  ( intel: hlt; encoded as mov m,m)

( groups 200 - 207; low order digit is src register)
( group 306 are immediates)
( regreg adds 200; imm adds 306; op is shifted to middle digit)
0 2op add  addi  ( intel: adi)
1 2op adc  adci  ( intel: aci)
2 2op sub  subi  ( intel: sui)
3 2op sbb  sbbi  ( intel: sbi)
4 2op and  andi  ( intel: ana, ani)
5 2op xor  xori  ( intel: xra, xri)
6 2op or   ori   ( intel: ora, ori)
7 2op cmp  cmpi  ( intel: cpi)

( group 300)
( Conditional return)
300 1reg ?ret  ( cond)

( group 301)
301 1reg pop  ( also 321, 341, 361)
311 op ret
( 331)
351 op pchl  ( pc! vector go run)
371 op sphl  ( sp!)

( group 302)
( Conditional jump)
302 ?direct ?jmp  ( cond)

( group 303)
303 direct jmp
( 313)
323 immed out
333 immed in
343 op xthl
353 op xchg
363 op di
373 op ei

( group 304)
( Conditional call)
304 ?direct ?call  ( cond)

( group 305)
305 1reg push  ( also 325, 345, 365)
315 direct call
( 335)
( 355)
( 375)

( group 307)
307 1reg restart  ( intel: rst)
