( $Id$

  This file is part of muFORTH; for project details, visit

     http://nimblemachines.com/browse?show=MuForth

  Copyright 1997-2007 David Frech. All rights reserved, and all wrongs
  reversed.

  Licensed under the Apache License, Version 2.0 [the "License"];
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  or see the file LICENSE in the top directory of this distribution.

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.)

( Of course, for any "new" target - even one designed in 1976 - we need an
  assembler. This is an assembler for the 8080/8085. It includes the two -
  count 'em! - instructions, sim and rim, that Intel added when they
  developed the 8085. Revolutionary! At the same time Zilog was developing
  the Z80 and getting ready to totally blow Intel's x80 market share away.
  Hmm, then what happened to Zilog? They really fumbled the 32bit market.)

( I'm going to use the term "8080" to mean the 8080 and 8085. As mentioned,
  the only difference _to the programmer_ - the hardware is a _lot_ nicer -
  is the two new instructions. You 8080 programmers out there - both of you
  - just don't use those two insns.)

( I'm going to change some of the mnemonics. Most hardware vendors choose
  awful mnemonics. [Thankfully ARM is better than most, though their
  mnemonics do imply a source/dest ordering that doesn't work as well with
  postfix assemblers.] Atmel's AVR is a good example: a decent
  architecture, a somewhat complex insn encoding, and completely awful,
  brain-dead, and confusing mnemonics . The 8080 mnemonics are a mix.
  Some are ok, but others - mostly the "immediate with A" insns - are
  awful. So I'm going to change them. If I remember, I'll note this in the
  definition of the insn.)

( One nice thing about the insn encoding is that, when you look at it with
  your octal glasses on, you see really nice simple patterns. Most insns
  group by first and last octal digit, while the middle digit chooses the
  member of the group. Eg, 302 is the conditional jump group:

  302 jnz
  312 jz
  322 jnc
  332 jc
  342 jpo
  352 jpe
  362 jp
  372 jm)

( I'm considering putting cycle times into the insns. We'll see how that
  works.)

( Space for compiling into. 8080 only has 64k address space.)
64 Ki buffer image

: 0r0  ( reg op)      swap  7 and  3 <<  or ;
: b,   ( compile byte)  
: w,   ( compile word, little-endian)  b,  8 >>  b, ;

octal
assembler

( Registers.)
0 constant b
1 constant c
2 constant d
3 constant e
4 constant h
5 constant l
6 constant m
7 constant a

( Register pairs have high bit set.)
200 constant bc
202 constant de
204 constant hl
206 constant sp  206 constant psw ( af?)

( group 000)
000 nop
( 010)
( 020)
( 030)
040 rim
( 050)
060 sim
( 070)

( group 001)
001 0R0 lxi  ( also 021, 041, 061)
011 0R0 dad  ( also 031, 051, 071)

( group 002)
( or maybe like zilog just ld & st?)
002 0R0 stax ( only works for BC, and DE...)
012 0R0 ldax ( ditto)
( 022 encodes stax d)
( 032 encodes ldax d)
042 sthl  ( intel: shld)
052 ldhl  ( intel: lhld)
062 sta
072 lda

( group 003)
003 0R0 inx  ( also 023, 043, 063)
013 0R0 dcx  ( also 033, 053, 073)

( group 004)
004 0r0 inc  ( intel: inr)

( group 005)
005 0r0 dec  ( intel: dcr)

( Hmm. why not this:)
( reg regpair)
  004 003 xxx inc
  005 013 xxx dec

( group 006)
006 0r0 movi

( Similarly to inc/dec; this combines movi and lxi)
( reg regpair)
  006 001 xxx movi

( group 007)
( Hmm: should these be called rola, rora, rlca, rrca, daa, coma, since they
  only work on a? Here is one place where the intel mnemonics are
  COMPLETELY! retarded.)
007 rol   ( intel: rlc! 8 bits, not thru carry)
017 ror   ( intel: rrc! ditto)
027 rolc  ( intel: ral! 9 bits, thru carry)
037 rorc  ( intel: rar! ditto)
047 da    ( intel: daa)
057 com   ( intel: cma)

067 setc  ( intel: stc)
077 comc  ( intel: cmc)

( groups 100 - 107; low order digit is src register)
100 mov
166 halt  ( intel: hlt; encoded as mov m,m)

( groups 200 - 207; low order digit is src register)
                              ( group 306)
( regreg adds 200; imm adds 306)
000 dup 00r add                   addi  ( intel: adi)
010 dup 00r adc                   adci  ( intel: aci)
020 dup 00r sub                   subi  ( intel: sui)
030 dup 00r sbb                   sbbi  ( intel: sbi)
040 dup 00r and  ( intel: ana)    andi  ( intel: ani)
050 dup 00r xor  ( intel: xra)    xori  ( intel: xri)
060 dup 00r or   ( intal: ora)    ori   ( intel: ori)
070 dup 00r cmp                   cmpi  ( intel: cpi)

( group 300)
( Conditional return)
: retcc  300 or b, w, ;

( group 301)
301 0R0 pop  ( also 321, 341, 361)
311 ret
( 331)
351 pchl  ( pc! vector go run)
371 sphl  ( sp!)

( group 302)
( Conditions, encoded in the negative, so we can used them with "if" and
  "until".)
: not  1 xor ;
0 constant 0=
2 constant u<   2 constant cs  ( carry set)
4 constant even  ( parity - why did they even bother?)
6 constant 0<

( Conditional jump)
: jcc  302 or b, w, ;

( group 303)
303 jmp
( 313)
323 out
333 in
343 xthl
353 xchg
363 di
373 ei

( group 304)
( Conditional call)

( This is the only even mildly amusing thing in this file. ;-)
: callcc  304 or b, w, ;

( group 305)
305 0R0 push  ( also 325, 345, 365)
315 call
( 335)
( 355)
( 375)

( group 306)
306 addi  ( intel: adi)
316 adci  ( intel: aci)
326 subi  ( intel: sui)
336 sbbi  ( intel: sbi)
346 andi  ( intel: ani)
356 xori  ( intel: xri)
366 ori   ( intel: ori)
376 cmpi  ( intel: cpi)

( group 307)
307 0r0 restart  ( intel: rst)
