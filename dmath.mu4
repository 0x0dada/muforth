: dmax-num  (s -- largest-double-integer )       [ -1 ] [ max-num  ] ;
: dmin-num  (s -- most-negative-double-integer ) [ 0 ]  [ sign-bit ] ;
: dumax-num (s -- largest-unsigned-double )      [ -1 ] [ umax-num ] ;
: dsign-bit (s -- double-sign-bit )              [ 0 ]  [ sign-bit ] ;

: dand (s d1  d2  --  r [d1 & d2] )
	push ( -- d1-lo d1-hi d2-lo )
	rot ( -- d1-hi d2-lo d1-lo )
	and  ( -- d1-hi r-lo )
	swap pop
	and  ( -- r-lo r-hi )
;

: dor (s d1  d2  --  r [d1 | d2] )
	push ( -- d1-lo d1-hi d2-lo )
	rot ( -- d1-hi d2-lo d1-lo )
	or   ( -- d1-hi r-lo )
	swap pop
	or   ( -- r-lo r-hi )
;

: dxor (s d1  d2  --  r [d1 | d2] )
	push ( -- d1-lo d1-hi d2-lo )
	rot ( -- d1-hi d2-lo d1-lo )
	xor  ( -- d1-hi r-lo )
	swap pop
	xor  ( -- r-lo r-hi )
;

: d2* (s d1 -- d1<<1 )
	swap dup 0< if 2* swap 2* 1 or ^ then
	2* swap 2* ;

: d2/ (s d1 -- d1>>1 )
	dup 1 and if 2/ swap 2/ [ sign-bit ] or swap ^ then
	2/ swap 2/ swap ;

: d<< (s d1 n -- d1<<n )
	?for d2* next ;

: d>> (s d1 n -- d1>>n )
	?for d2/ next then ;

0 [if]
variable cr-count
: cr-init 4 cr-count ! ;
: cr-test -1 cr-count +! cr-count @ if ^ then cr cr-init ;

decimal
: test-d2* cr-init 1 s->d      64 for 2dup d. d2* cr-test next 2drop ;
: test-d2/ cr-init 0 "80000000 64 for 2dup d. d2/ cr-test next 2drop ;
: test-d<< cr-init             63 for 1 s->d r@ d<< d. cr-test next 1 s->d 0 d<< d. ;
: test-d>> cr-init             63 for 0 "80000000 r@ d>> d. cr-test next 0 "80000000 0 d>> d. ;
( The above words make interesting output, use hexadecimal output mode for best results.)
hex

[then]
