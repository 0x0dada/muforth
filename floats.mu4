: fliteral  load-fliteral push-fliteral ;
: f]   fliteral -] ;
: ;fdoes  load-fliteral     pop compile, \ ^ ;
compiler
: fdoes>  ['] ;fdoes compile, push-fliteral ;
: f"   (s - f)   char "  string,  str->f  fliteral ;
forth

: fvariable   fcell buffer ;
: fconstant   create  fliteral \ ^ ;  ( syntactic sugar for : foo  89 ; )

: f"  (s - f)  char " string,  str->f ;

: s->f  (s n - f)   s->d  d->f ;
: f->s  (s f - n)   f->d  d->s ;
: drop drop ;  ( Shouldn't this be in startup.mu4? )

( These are about the worst implementations of fdup, fover, and fwap
  I could think of.  If you can make them any worse, feel free.
  Ideally, these could implemented natively on the target machine.
  Or, in theory they could be implemented in C.  But, I'm loathe to
  put anything in C that can be done in muForth.  So there. )

fvariable fhold_a
fvariable fhold_b
: fdup  fhold_a f!  fhold_a f@  fhold_a f@ ;
: fover (s fa fb -- fa fb fa )
	fhold_b  f!  fhold_a f!  fhold_a  f@  fhold_b  f@  fhold_a  f@ ;
: fswap (s fa fb -- fb fa)
	fhold_b  f!  fhold_a f!  fhold_b  f@  fhold_a  f@ ;

: f-   fneg f+ ;
: fsq  (s  f -- f*f)
	fdup f* ;

f" 3.14159265358979323846" fconstant pi
pi f" 2.0" f/              fconstant half-pi
f" 2.71828182845904523536" fconstant e
f" 180" pi f/              fconstant radian

: deg-to-rad (s fdeg -- frad )
	pi f* f" 180" f/ ;
: rad-to-deg (s frad -- fdeg )
	f" 180" f* pi f/ ;

( Sine and Cosine using Horner's method.
  These algorithms come from Jack Crenshaw's book,
  "Math Toolkit for Real-Time Programming"

  These algorithms work in radians.

  The _ versions of these routines are internal only,
  not to be used by clients.  The exported functions
  are "sine" and "cosine".  Also included for export
  are degrees versions of those routines. )

: _sine (s f -- sine-of-f)
	fdup fsq (s -- f f*f)
	fdup  (s  f  f*f                  f*f) [ f" 1.0" f" 8.0" f" 9.0" f* f/ f] f*    f" 1.0" f-
	fover (s  f  f*f  <above expr>    f*f) [ f" 1.0" f" 6.0" f" 7.0" f* f/ f] f* f* f" 1.0" f+
	fover (s  f  f*f  <above expr's>  f*f) [ f" 1.0" f" 4.0" f" 5.0" f* f/ f] f* f* f" 1.0" f-
	fswap (s  f       <above expr's>  f*f) [ f" 1.0" f" 2.0" f" 3.0" f* f/ f] f* f* f" 1.0" f+
	f*
;

: _cosine (s f -- cosine-of-f)
	fsq   (s  f*f)
	fdup  (s  f*f                  f*f) [ f" 1.0" f" 7.0" f" 8.0" f* f/ f] f*    f" 1.0" f-
	fover (s  f*f  <above expr>    f*f) [ f" 1.0" f" 5.0" f" 6.0" f* f/ f] f* f* f" 1.0" f+
	fover (s  f*f  <above expr's>  f*f) [ f" 1.0" f" 3.0" f" 4.0" f* f/ f] f* f* f" 1.0" f-
	fswap (s       <above expr's>  f*f) [ f" 1.0" f" 1.0" f" 2.0" f* f/ f] f* f* f" 1.0" f+
;

2variable  sine-helper
: sine  (s  f -- sine-of-f)
	fdup  half-pi f/ f" 0.5" f+ f->d  (s  -- f d)
	sine-helper 2! sine-helper 2@     (s  -- f d)
	d->f half-pi f* f-                (s  -- f)
	sine-helper 2@ 4 fm/mod drop      (s  -- f n)
	dup 0 = if drop              _sine        ^ then
	dup 1 = if drop              _cosine      ^ then
	dup 2 = if drop f" 0"  fswap _sine    f-  ^ then
	    3 = if      f" 0"  fswap _cosine  f-  ^ then
	throw ;

: cosine (s f -- cosine-of-f)
	half-pi f+ sine ;

: sine-deg    deg-to-rad  sine    ;
: cosine-deg  deg-to-rad  cosine  ;
