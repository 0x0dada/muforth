( $Id$

  This file is part of muFORTH; for project details, visit

     http://nimblemachines.com/browse?show=MuForth

  Copyright 1997-2006 David Frech. All rights reserved, and all wrongs
  reversed.

  Licensed under the Apache License, Version 2.0 [the "License"];
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  or see the file LICENSE in the top directory of this distribution.

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.)

cr " ARM kernel "  file[#

( 2006-apr-01.)

( Can't stand the pain of fiddling with the assembler, so I'm going to
  launch into writing a simple kernel, of sorts.)

( Few words we need to try this out.)

-:  ."  (assembling)"  ;
-:   .assembler. find  if  execute ^  then  number ;
mode asm-loop

-:  ."  (assembling a macro)"  ;
-:   .compiler. find  if  execute ^ then
    .assembler. find  if  compile, ^  then  number literal ;
mode macro-loop

compiler
: <asm   macro-loop ;
: asm>   -] ;
forth

assembler
: '   .target. chain' execute ;
: (    \f ( ;
: ;c    \ [ ;
forth

( code & ;c should use ?csp to make sure nothing bad has happened...)
: code  target create forth  |here  pair off  asm-loop
        does> ;

assembler
( Useful macros.)
: push  ( r)  <asm  4 sp -) !  \f swap  str  asm> ;
: pop   ( r)  <asm  4 sp )+    \f swap  ldr  asm> ;

: nest    ( r)  <asm  4 rp -) !  \f swap  str  asm> ;
: unnest  ( r)  <asm  4 rp )+    \f swap  ldr  asm> ;

: ret     <asm  lr pc mov  asm> ;
: st1   <asm  0 sp +)  asm> ;
: st2   <asm  4 sp +)  asm> ;
: st3   <asm  8 sp +)  asm> ;
forth

code +     0 pop   top 0 top add   ret  ;c
code -     0 pop   top 0 top sub   ret  ;c
code and   0 pop   top 0 top and   ret  ;c
code or    0 pop   top 0 top or    ret  ;c
code xor   0 pop   top 0 top eor   ret  ;c

( By moving 1-insn words into compiler/inside and making them macros, we
  get inlining... ;-)

code negate   0 # top top rsb   ret  ;c
code invert       top top mvn   ret  ;c

code dup   top push  ret  ;c
code nip     0 pop   ret  ;c
code drop  top pop   ret  ;c
code swap  top 0 mov   st1 top ldr   st1 0 str  ret  ;c
code rot
   { 0 1 } sp ldm
   top 2 mov   0 top mov   1 0 mov   2 1 mov
   { 0 1 } sp stm  ret  ;c

code -rot
   { 0 1 } sp ldm
   top 2 mov   1 top mov   0 1 mov   2 0 mov
   { 0 1 } sp stm  ret  ;c

code <<    0 pop   0 top lsl top mov   ret  ;c
code >>    0 pop   0 top asr top mov   ret  ;c
code u>>   0 pop   0 top lsr top mov   ret  ;c

code 2/    top 1 #asr top mov  ret  ;c
code u2/   top 1 #lsr top mov  ret  ;c
code 2*    top 1 #lsl top mov  ret  ;c

code u<    0 pop   top 0 cmp   -1 # top mov u<  0 # top mov u>=  ret  ;c
code <     0 pop   top 0 cmp   -1 # top mov  <  0 # top mov  >=  ret  ;c
code 0<          top top tst   -1 # top mov 0<  0 # top mov 0>=  ret  ;c

code branch    4 lr )+ 0 ldr   0 lr pc add   ;c
code zbranch   top top tst   top pop
               4 lr )+ 0 ldr 0=   0 lr pc add 0=   4 # lr pc add   ;c

code (for)     ct nest   top ct mov   ' drop b  ;c

code (?for)    top top tst   top 0 mov   top pop
               4 lr )+ 0 ldr 0=   0 lr pc add 0=
               ct nest   0 ct mov   4 # lr pc add   ;c

code (next)    1 # ct ct sub s   ct unnest 0=   4 # lr pc add 0=
               4 lr )+ 0 ldr   0 lr pc add   ;c

code lit            top push   4 lr )+ top ldr   ret  ;c
code lit_noreturn   top push   0 lr )+ top ldr   pc unnest  ;c

code push   top nest   ' drop b  ( 1 word shorter)  ;c
code pop    top push   top unnest   ret  ;c

#]file
