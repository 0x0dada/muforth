( $Id$

  This file is part of muFORTH; for project details, visit

     http://nimblemachines.com/browse?show=MuForth

  Copyright 1997-2006 David Frech. All rights reserved, and all wrongs
  reversed.

  Licensed under the Apache License, Version 2.0 [the "License"];
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  or see the file LICENSE in the top directory of this distribution.

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.)

( Develop some simple markup for generating XML, HTML, TeX, PDF, or
  whatever we want.)

( Maybe push a stack of elements. Then we can neglect to put in all the
  closing markup, inserting it automatically when we see another opening
  tag. Is this worthwhile? Maybe only allow the same type of element to
  be opened, automatically closing the previous?)


comment Chunks
  Do the formatting via a "chunk list". The basic idea is this: as
  tokens are parsed or inserted into the output, put a (start,len)
  pair onto the end of the chunk list. (A chunk list is basically a
  line of output. If the last chunk would send the line past the right
  margin, we wrap, print the line, and make that chunk the first of
  the new line. We could even use a string of blanks for indenting and
  so on: use (start_blanks, count_of_blanks).
Chunks

128 2* buffer chunks
variable 'chunk
variable #chunk-chars

: 0chunks  chunks 'chunk !  0 #chunk-chars ! ;  0chunks
: chunk,  'chunk @ !  cell 'chunk +! ;
: chunk  ( start len)  dup #chunk-chars +!  swap chunk, chunk, ;
: .chunks  chunks  'chunk @ chunks - cell/ 2/  0chunks
    ?for  @+ @+ -rot type next  then ;

( $ isn't used for anything. use it for "lift"?)
: lift          token  chunk ;  ( no trailing space)
: lift"  char " parse  chunk ;
: (lift")  ( z")  count chunk ;
: sp  ( put spaces in, from string of 80 of them)
   z"                                                                                 " swap chunk ;

compiler
: lift   token, literal  \ (lift") ;


( Allocate chunks in memory? But then when we have compiled chunks it becomes
  hard because we're allocating them from the same space. Put the strings
  in code space? In name space? Create a string space?)

: chunk  ( start len)  swap , , ;
: $  ( lift)  token chunk ;

forth
variable #col  ( current output column)
variable #indent  ( spaces from left)
variable #spaces  ( preceding markup)

: #wrap  80 ;  ( column to wrap)

: wrap   cr  #indent @ dup spaces  #col !  0 #spaces ! ;
: +wrap  #wrap #col ! ; +wrap
: ?wrap ( len)  dup #col @ +  #wrap u< not  if wrap then  #col +! ;

( Attributes)
: .attribute  ( Svalue Sname)
   ( total chars = Sname len Svalue len + 3 + . ="foo")
   chunk  lift ="  chunk  lift "  #chunk-chars @ ?wrap  .chunks ;

( Quoting)
: quoted  2 over + ?wrap  \f char dup  emit  -rot  type  emit ;
: quoted  2 over + ?wrap  char " emit  type  char " emit ;

( Strings that begin new chunks - they reset the #col counter.)
: (w")  count dup ?wrap type ;
: (b")  +wrap  (w") ;
: (e")         (w") ;

compiler
: b"  \ z"  \ (b") ;
: e"  \ z"  \ (e") ;

forth
: start-tag   lift <  \f lift  lift > ;
: end-tag     lift <  \f lift  lift /> ;

forth
( I want block and inline elements that are defined somehow elegantly.)
\ : block-element  \ start-tag  :>> ;

( What we do when it's not markup...)
: .cdata  dup #spaces @ + ?wrap  #spaces @ spaces  type ;

chain .markup.
: markup  .markup. definitions ;

compiler
: \m  .markup. \chain ;

forth
-: ."  (markup) " ;
-: .markup. -"find if  .cdata  1 #spaces ! ^ then
                      execute  0 #spaces ! ;
mode mu

markup
: :>   2 #indent +! ;
: :<  -2 #indent +! ;
: :title  b" <html>" ;
\ : :style  token  ." <link rel="stylesheet" 
: :p  ( para)  b" <p>" ;
: ;p           e" </p>" ;
: :olist        b" <ol>"  \m :> ;
: ;olist  \m :< b" </ol>"  ;
: :li  b" <li>" ;
: ;li  e" </li>" ;
: :url  token  b" <a href="  quoted  e" >" ;
: ;url  e" </a>" ;
forth

: t  lift <  lift href= lift " lift http://freebsd.org/ lift " lift /> ;      
: x  " big deal" chunk  " another big deal" chunk  " not soo big" chunk ;

mu

:p this is a para but it is a very long line that will need to be altered by breaking it up in a few places ;p

:> :> :>

:p another long para; this one should be indented; it also  is a very long line that will need to be altered by breaking it up in a few places ;p

:url http://freebsd.org The FreeBSD Project ;url
:url images/beanie.png Cute ;url

:ol
:li An item ;li
:li Another item ;li
;ol

