( $Id$

  This file is part of muFORTH; for project details, visit

     http://nimblemachines.com/browse?show=MuForth

  Copyright 1997-2006 David Frech. All rights reserved, and all wrongs
  reversed.

  Licensed under the Apache License, Version 2.0 [the "License"];
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  or see the file LICENSE in the top directory of this distribution.

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.)

( Simple terminal and serial expect/send code.)

( 2002-mar-27. Converted to muforth.)

( Created 5-aug-1999.)

cr " Terminal "  file[#

decimal

( test)
( by setting rom-start wrong here, to "4000000, instead of
  "4000000 64 Ki +, I managed to b0rk the bootloader on one of my boards
  while testing the terminal download code. Shit!)

( Open serial device.)
: tty-target  [ z" /dev/cuad4" r/w open-file ] ;
tty-target raw  ( disallows signals)

: bps   ( fd speed)
   over ram get-termios drop  ram swap set-termios-speed
  ( fd) ram set-termios ;

: te-slow     tty-target   9600 bps  ;
: te-fast     tty-target  57600 bps  ;
: te-smokin'  tty-target 115200 bps  ;  te-smokin'

( Keymaps)
-: ( self)  emit  0 ;  256 keymap term-keys
   ( nop)       ' 0    256 keymap term-esc-keys
-: drop ( ESC)  key term-esc-keys @execute ;  #ESC term-keys !
: esc:  -:  \f char  term-esc-keys ! ;

comment %use-typing%
  256 constant #serialbuf
  #serialbuf buffer serialbuf ( serial input buffer)
%use-typing%

comment %coroutines-broken%
( 2003-mar-13. It's coroutine time!)

: coroutine  ( dstack-safety dstack-size - s0)
   cells allot ( size)  cells ( safety)  ram  swap -  constant ;

coroutine serial-s0
%coroutines-broken%

variable fdmax
: new-fd-set  ram fd!  buffer ;
new-fd-set fds

: te-select  ( fd0 .. fdn n)
   fds fd! drop  fdmax off
   for  fds over fd-set   fdmax @ max  fdmax !  next
   fdmax @ 1+  fds  0  0  0  select  drop  ;

( Serial input to screen, keyboard input to serial.)

: serial->screen
   fds tty-target fd-in-set? if
     tty-target reads  tty writes  typing type
  then ;

: keyboard->serial  ( - done?)
   fds tty fd-in-set? if
     tty reads  tty-target writes  key dup term-keys @execute ^
   then  0 ;

: te-stream
   begin  tty tty-target 2 te-select
      serial->screen  keyboard->serial  until  tty writes  ;

: <drain  begin  tty-target 1 te-select  serial->screen  until
   tty-target writes  ;

: te  ( terminal)
   radix @ push  tty raw   ['] te-stream catch
                 tty cooked  pop radix !  throw ;

( Downloading initial image to target.)

( IDEA: Use this code to stream stuff to the v25 and have it show, on the
  screen, what it's returning. Or simply to consume all the text before or
  after a cmd.)

( Expect/send.)
: ><target  tty reads  tty writes  (  tty-target reads  tty-target writes)  ;
: |cr  #CR emit  ;

: ?prompt  ( ch)  begin  key  over = until  drop  ;

variable 'boot   rom-start "435 + 'boot !  ( XXX: just for fun)
( Execute!)
: pc!  ( n)   ." pc" .w16 |cr  ." gos" |cr ;


comment %v25-specific%
( Load the chat interactive stuff here.)
ld v25/chat-host.d4		( interactive debugging)
%v25-specific%

( Special keys.)

( Echo ESC [ back to serial port, followed by the rest of the chars in the
  keyboard buffer. This makes AEB-1 autobauding - which works by sending
  `ESC [5n' - status query - and the Linux console answers with `ESC [0n' -
  terminal Ok. By echoing the ESC and [ that were eaten by our ESC-dispatch
  mechanism, we cause the AEB-1 autobaud feature to magically work.

  This only sort of "works". While the Linux console obliges - as do rxvt
  and xterm - the FreeBSD syscons driver does _not_. [I have no idea what
  the NetBSD wscons driver will do.] So rather than be at the mercy of an
  environment that we cannot control, we handle this ourselves, right
  here.)

: CSI  ( handle ESC [ )
  #ESC emit  char [ emit
  key dup char 5 = if
    key dup char n = if  ( got ESC [5n, so answer accordingly)
      nip  char 0
    then swap emit
  then emit ;

esc: [  ( vt10x)  CSI  0 ;

-: drop  #BS emit  0 ;   #DEL term-keys !  ( DEL sends BS)

esc: k  ( smoke)  te-smokin'  0  ;
esc: f  ( fast)   te-fast  0  ;
esc: s  ( slow)   te-slow  0  ;

esc: d  ( download)      ." flashload " rom-start .w16  |cr  0 ;
esc: r  ( ram download)  ." download"  |cr  0 ;

esc: u  ( uuencode)  'image #image  uu  0 ;
esc: p  ( pc)  ." pc " 'boot @ .w16 |cr  0 ;
esc: g  ( go)  ." gos" ( |cr)  0 ;

esc: q  ( quit)  -1 ;

comment %v25-specific%
-:
   tty-target reads  tty-target writes  te-slow
   |cr-chat  char * ?prompt  " l" send  z" loader" "download  " g" send
   char g ?prompt  te-fast
   ( changes target serial speed - can't await prompt)  0  ;
                                   char l  term-esc-keys !  ( loader)
-:
   tty-target reads  tty-target writes
   |cr-chat  char * ?prompt  " l" send  z" image" "download
   initial-sync  0  ;
                                   char i  term-esc-keys !  ( image)
-:
   tty-target reads  tty-target writes
   |cr-chat  char * ?prompt  |boot @ pc!  " r" send  0  ;
                                   char b  term-esc-keys !  ( boot)
-:
   tty-target reads  tty-target writes
   |cr-chat  char * ?prompt  " g" send  <LF> ?prompt
   ( target responds "g CR LF")   chat!  -1 ( quit term)  ;
                                   char g  term-esc-keys !  ( go)

( 2002-mar-30. Comments. About reading prompts and so on. Make an 8 byte
  ring buffer that you copy the target responses into. Keep looping around
  and copying until the last 5 characters match "Boot:".

  Alternatively, use human intelligence combined with "macro" keystrokes.
  Read the prompt yourself, then type "M-d"; terminal sends "download<CR>";
  target responds; type "M-u" to uuencode and send; target responds. This
  is probably easier. And once we get something into Flash that can be a
  debugging stub we won't even need to do this anymore.)

%v25-specific%

00 [if]

( Test code.)
: kb  raw  begin  key  dup <ESC> xor while  u.  repeat  cooked  ;
: wr  ( a #)  tty-target -rot write drop  ;
: kb-test
   if  tty keyboard-in 1 read   tty keyboard-in 1 write  2drop  then  ;

: kb    fds fd! drop  fds tty fd-set  raw
   begin  te-select drop  kb-test  again  [

[then]

#]file
