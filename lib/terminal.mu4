( $Id$

 This file is part of muforth.

 Copyright 1997-2002 David Frech. All rights reserved, and all wrongs
 reversed.
)

( Simple terminal and serial expect/send code.)

( 2002-mar-27. Converted to muForth.)

( Created 5-aug-1999.)

cr s" Terminal "  file[#

decimal

( Open serial device.)
z" /dev/cuaa0" r/w open-file  constant tty-target
tty-target >raw  ( disallows signals)

: bps   ( fd speed)
   over ram get-termios drop  ram swap set-speed  ( fd) ram set-termios ;

: te-slow     tty-target   9600 bps  ;
: te-fast     tty-target  57600 bps  ;
: te-smokin'  tty-target 115200 bps  ;  te-smokin'


comment use-typing
  256 constant #serialbuf
  #serialbuf buffer serialbuf ( serial input buffer)
use-typing

( 2003-mar-13. It's coroutine time!)

: coroutine  ( dstack-safety dstack-size - s0)
   cells allot ( size)  cells ( safety)  ram  swap -  constant ;

coroutine serial-s0

variable fdmax
: new-fd-set  ram fd-zero  buffer ;
new-fd-set fds

: te-select  ( fd0 .. fdn n)
   fds fd-zero drop  fdmax off
   for  fds over fd-set   fdmax @ max  fdmax !  next
   fdmax @ 1+  fds  0  0  0  select  drop  ;

( Serial input to screen, keyboard input to serial.)

comment old-serial->screen
: serial->screen  ( - done?)
   fds tty-target fd-in-set? dup if  tty-target reads  tty writes
       typing  type  then  not ;
old-serial->screen

( XXX: do we need to get the whole input at once? ie with "typing", or can
  we just read and process a "key" at a time, like in keyboard->serial?)

: process-serial  ( key -)
       dup <ESC>  = if  key dup char [ = if
   key dup char 5 = if  key dup char n = if  

: serial->screen  ( - done?)
   fds tty-target fd-in-set? if  tty-target reads  tty writes
      key process-serial 0 ^  then  -1 ;

: keyboard->serial  ( - done?)
   fds tty fd-in-set? if  tty reads  tty-target writes
      key process-key  ^  then  0  ;

: te-stream
   begin  tty tty-target 2 te-select
      serial->screen drop  keyboard->serial  until  tty writes  ;

: <drain  begin  tty-target 1 te-select  serial->screen  until
   tty-target writes  ;

: te  ( terminal)
   radix @ push
   raw ( console)  ['] te-stream catch  cooked ( console)
   pop radix !  throw ;


-: emit  0 ;  is pass
' pass <CR> ctrl-handler!
' pass <LF> ctrl-handler!

-: drop  <BS> pass ;  is del-handler  ( pass a BS to serial line)


( Downloading initial image to target.)

( IDEA: Use this code to stream stuff to the v25 and have it show, on the
  screen, what it's returning. Or simply to consume all the text before or
  after a cmd.)

( Expect/send.)
: ><target  tty reads  tty writes  (  tty-target reads  tty-target writes)  ;
: |cr  <CR> emit  ;

: ?prompt  ( ch)  begin  key  over = until  drop  ;

variable 'boot   rom-start "435 + 'boot !  ( XXX: just for fun)
( Execute!)
: pc!  ( n)   ." pc" .w16 |cr  ." gos" |cr ;


comment v25-specific
( Load the chat interactive stuff here.)
ld v25/chat-host.d4		( interactive debugging)

v25-specific

( Special keys.)

( Echo ESC [ back to serial port, followed by the rest of the chars in the
  keyboard buffer. This makes AEB-1 autobauding - which works by sending
  `ESC [5n' - status query - and the Linux console answers with `ESC [0n' -
  terminal Ok. By echoing the ESC and [ that were eaten by our ESC-dispatch
  mechanism, we cause the AEB-1 autobaud feature to magically work.

  This only sort of "works". While the Linux console obliges - as do rxvt
  and xterm - the FreeBSD syscons driver does _not_. [I have no idea what
  the NetBSD wscons driver will do.] So rather than be at the mercy of an
  environment that we cannot control, we handle this ourselves, right
  here.)

: CSI  ( handle ESC [ )  key dup char 5 = if  key dup push char n = if
  ( got ESC [5n, so answer accordingly)  drop char 0  then then  push
  swap emit emit ( echo "ESC [")  pop emit  pop emit ;

-:
   CSI  0 ;                               char [  esc-handler!  ( vt10x)

(   swap emit emit  0  ;)
-:
   2drop  te-smokin'  0  ;                char k  esc-handler!  ( smoke)
-:
   2drop  te-fast  0  ;                   char f  esc-handler!  ( fast)
-:
   2drop  te-slow  0  ;                   char s  esc-handler!  ( slow)

-:
   2drop  ." flashload " rom-start .w16  |cr  0 ;
                                          char d  esc-handler!  ( download)
-:
   2drop  ." download"  |cr  0 ;
                                          char r  esc-handler!  ( ram download)

-:
   2drop  'image #image  uu  0 ;
                                          char u  esc-handler!  ( uuencode)
-:
   2drop  ." pc " 'boot @ .w16 |cr  0 ;
                                          char p  esc-handler!  ( pc)
-:
   2drop  ." gos" ( |cr)  0 ;
                                          char g  esc-handler!  ( go)
comment v25-specific
-:
   tty-target reads  tty-target writes  te-slow
   |cr-chat  char * ?prompt  s" l" send  z" loader" "download  s" g" send
   char g ?prompt  te-fast
   ( changes target serial speed - can't await prompt)  0  ;
                                           char l  esc-handler!  ( loader)
-:
   tty-target reads  tty-target writes
   |cr-chat  char * ?prompt  s" l" send  z" image" "download
   initial-sync  0  ;
                                           char i  esc-handler!  ( image)
-:
   tty-target reads  tty-target writes
   |cr-chat  char * ?prompt  |boot @ pc!  s" r" send  0  ;
                                           char b  esc-handler!  ( boot)
-:
   tty-target reads  tty-target writes
   |cr-chat  char * ?prompt  s" g" send  <LF> ?prompt
   ( target responds "g CR LF")   chat!  -1 ( quit term)  ;
                                           char g  esc-handler!  ( go)

( 2002-mar-30. Comments. About reading prompts and so on. Make an 8 byte
  ring buffer that you copy the target responses into. Keep looping around
  and copying until the last 5 characters match "Boot:".

  Alternatively, use human intelligence combined with "macro" keystrokes.
  Read the prompt yourself, then type "M-d"; terminal sends "download<CR>";
  target responds; type "M-u" to uuencode and send; target responds. This
  is probably easier. And once we get something into Flash that can be a
  debugging stub we won't even need to do this anymore.)

v25-specific

00 [if]

( Test code.)
: kb  raw  begin  key  dup <ESC> xor while  u.  repeat  cooked  ;
: wr  ( a #)  tty-target -rot write drop  ;
: kb-test
   if  tty keyboard-in 1 read   tty keyboard-in 1 write  2drop  then  ;

: kb    fds fd-zero drop  fds tty fd-set  raw
   begin  te-select drop  kb-test  again  -;

[then]

#]file
