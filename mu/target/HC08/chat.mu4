( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( I couldn't take it any more - the 908 ROM monitor was driving me crazy.
  It's slow, and there is still an odd bug with the PC - the "image" of it on
  the stack frame - not getting properly initialised... but only when the
  target is first connected!

  I decided to try out some simple ideas. Instead of the Nibble Machines
  loader, we have this! Rather than a Bootloader, it's a Byteloader?

  This code should _just_ fit into RAM, leaving room for the data
  structures needed for the ROM flash routines. The idea basically that
  this is a simple target to write to in order to get the Flash written -
  ideally with a copy of this code to act as a bootloader!)

loading HC08 Chat (target)

hex

__meta

( The SCI code is identical between 908 and S08 except for the names - and
  offsets - of the SCI status and data regs ... so let's abstract them.)

.ifdef S08

aka SCIS1 SciStatus
aka SCID  SciData

.else   -- 908

aka SCS1 SciStatus
aka SCDR SciData

.then

label SciRx  ( returns char in A)
   begin  SciStatus 5 ( recvr full)  bset? until
   SciData ) lda  rts  ;c

label SciTx  ( transmits char in A)
   begin  SciStatus 7 ( xmit empty)  bset? until
   SciData ) sta  rts  ;c

( chat1 - original - protocol)

( Commands:
  0  Bye        - ignored by chat; force other command loops to return to chat
  1  Idle       - no-op - so we can re-sync the protocol
  2  Run        - does an RTI - pops stack frame and runs
  3  Id         - read low byte of S08 Id register SDIDL @1807
  4  SetH       - reads a byte from SCI, writes into H register
  5  SetX       - reads a byte from SCI, writes into X register
  6  GetH       - writes H register to SCI
  7  GetX       - writes X register to SCI
  8  HXtoSP     - sets SP from HX
  9  SPtoHX     - sets HX from SP
 10  ReadNext   - reads a byte from memory @ HX, writes it to SCI, inc HX
 11  WriteNext  - reads a byte from SCI, writes into memory @ HX, inc HX
)

( chat2 protocol - minor changes)

( Commands:
  0  Idle       - ignored by chat; force other command loops to return to chat;
                  can be used as an Idle
  1  Run        - does an RTI - pops stack frame and runs
  2  SetHX      - reads two bytes from SCI, writes them into H & X registers
  3  GetHX      - writes H then X register to SCI
  4  HXtoSP     - sets SP from HX -- deprecated, but I'm leaving it in
  5  SPtoHX     - sets HX from SP
  6  ReadNext   - reads a byte from memory @ HX, writes it to SCI, inc HX
  7  WriteNext  - reads a byte from SCI, writes into memory @ HX, inc HX

 ~~ The following are S08-only commands ~~

  8  ReadN      - reads a length from SCI, reads that many bytes from
                  memory, and writes them to SCI [S08 only!]
  9  FlashNext  - reads a byte from SCI, writes to flash @ HX, inc HX
                - calls a routine at @ram that host downloads to device
 10  FlashStatus - returns FSTAT
                 - need this as a way to "ping" the device for the
                 - completion of long operations, such as erase
)

label SendByte  ( send char in A)
   SciTx bsr

label Dispatch
   SciRx bsr  ( command)

   ( map 0 -> ff -- ignore)
   .a decz? if ( Run)   .h pul  rti  then

   .a decz? if ( SetHX)
   SciRx bsr  .a psh  .h pul  ( set H)
   SciRx bsr  tax ( set X)  Dispatch again  then

   .a decz? if ( GetHX)
   .h psh  .a pul  SciTx bsr  ( send H)
   txa  SendByte again  ( send X)  then

   .a decz? if ( HXtoSP)  txs  Dispatch again  then
   .a decz? if ( SPtoHX)  tsx  Dispatch again  then

   .a decz? if ( ReadNext)
   0 ,x lda  1 # aix  SendByte again  then

   .a decz? if ( WriteNext)
   SciRx bsr   0 ,x sta
label write-increment
   1 # aix

.ifdef S08

   ( end WriteNext)  Dispatch again  then

   .a decz? if ( ReadN)
   SciRx bsr  .a psh ( count)
   begin  0 ,x lda  1 # aix  SciTx bsr  0 ,s decz? until
   .a pul  Dispatch again  then

   .a decz? if ( FlashNext)
   SciRx bsr   flash-byte c ( call flash routine in RAM)
   write-increment again ( to WriteNext)  then

   .a decz? if ( FlashStatus)
   FSTAT ) lda  SendByte again

.then

   then
   ( unknown command)   Dispatch again  ;c


( If compiling into RAM and using 908 flash control block, check to make
  sure we haven't "run into" the control block, then jump forward over it
  and continue compiling there.)

.def in-ram  .def control-block  .and .if
__host
: ?fits
   control-block  'zram @  u< if
      error" Code too long - ran into Flash control block"
   then ;
?fits
__meta
09c org           -- continue compiling there
.then

label emulated-swi
   ( jsr/bsr has already pushed PC)
   .x psh  .a psh  tpa ( flags to A)  .a psh  sei
   .h psh
   Dispatch  again  ;c


( If the chat interaction changes the PC on this stack frame to point
  somewhere other than _after_ the __swi, not all is lost - since we got
  here via a _call_ from reset, we'll return to _that_ loop, and re-enter
  the SWI.

  On the other hand, if the PC remains unaltered, an RTI from the SWI's
  stack frame wil simply return here, and we'll take the "exception" again.)

label interact
   begin  emulated-swi c  again  ;c

Vreset handler
   @ram #ram + # ldhx
   txs

.ifdef S08

   -- Turn off watchdog
   -- Can't use bit ops! SOPT1 not in z-page.
   -- Clear bits 6 & 7. These have different meanings on different chips,
   -- but at least for the JS and QG clearing both bits will shut off the
   -- watchdog.
   SOPT1 ) lda  3f # and  SOPT1 ) sta

   .ifdef 24m

      .reg MCGTRM .if  ( JS/JM running 48M PLL)

   ( Set up the xtal oscillator and PLL. For USB we need a 48M clock - 24M
     bus clock. Getting there takes a few steps...)

   -- FEI ==> FBE
   -- Start xtal osc - we've got a 4M xtal on the board.
   -- Datasheet and appnotes have you set BDIV to /1 here, but since we're
   -- running off untrimmed internal osc still, that's a bad idea. We leave
   -- that until the end.
   %01_11_0110 # MCGC2 ) mov  ( keep BDIV at /2, start ext osc)
   -- wait for osc to start (OSCINIT)
   begin  MCGSC 1  bset? until
   -- switch to ext clock (FBE): CLKS=01 (ext), RDIV=001 (/2), IREFS=0
   -- NOTE: We've set RDIV for PLL (4M/2 == 2M), but we're still running
   -- the FLL, so this will temporarily run it out of spec... DS says this
   -- is ok, as long as we switch quickly!
   -- %10_111_000 # MCGC1 ) mov  -- from when I thought I needed to keep
                                 -- RDIV set for FLL
   %10_001_000 # MCGC1 ) mov

   -- Wait until we've switched clocks
   begin  MCGSC ) lda  %0001_1100 # and  ( mask IREFST and CLKST)
          %0000_1000 # cmp  0= until  ( IREFST=0, CLKST=10)

   -- FBE ==> PBE
   -- We're spinning up the PLL. We're set up to divide our 4M xtal by two
   -- (RDIV) to get 2M (PLL freq); let's multiply that by 24 (VDIV) to get
   -- 48M, which is our target clock.
   %0100_0110 # MCGC3 ) mov    -- PLLS=1, VDIV=0110 (*24)

   begin  MCGSC 5 bset?  until   -- loop until PLLST set
   begin  MCGSC 6 bset?  until   -- loop until LOCK set

   -- PBE ==> PEE
   MCGC1 7 bclr  -- set CLKS to 00 (PLL)
   begin  MCGSC 2 bset?  until
   begin  MCGSC 3 bset?  until   -- loop until CLKST=11

   -- Lastly, set BDIV to /1
   MCGC2 6 bclr

      .else  ( 24m ICS - QE32 probably)

   ( Set up the xtal oscillator and FLL for 48M clock - 24M bus clock.
     Getting there takes a few steps...)

   %01_11_0110 # ICSC2 ) mov  ( keep BDIV at /2, start ext osc)
   -- wait for osc to start (OSCINIT)
   begin  ICSSC 1  bset? until
   -- switch! making sure to change RDIV at the same time
   %00_010_000 # ICSC1 ) mov

         .ifdef bit-by-bit

   -- Wait until we've switched to EREF
   begin  ICSSC 4 bclr?  until  ( IREFST=0)

   -- Then switch multiplier to high range...
   %10_0_0_0000 # ICSSC ) mov

   -- and wait until we've switched
   begin  begin  ICSSC 7 bset?  until
                 ICSSC 6 bclr?  until  ( DRST=10)

         .else  ( all at once)

   -- Switch multiplier to high range
   %10_0_0_0000 # ICSSC ) mov

   -- Wait until we've switched clocks
   begin  ICSSC ) lda  %1101_0000 # and  ( mask DRST and IREFST)
          %1000_0000 # cmp  0= until  ( DRST=10, IREFST=0)

         .then

   -- Lastly, set BDIV to /1
   ICSC2 6 bclr

      .then  ( QE32)

   ( Both these cases run @ 24m, so set FCDIV and baud rate accordingly.)

   #24000 khz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI for 115200 bps

   SCIBDH ) clr        ( baud rate divisor, high)
   #13 # SCIBDL ) mov  ( baud rate divisor, low)
                       ( yields 115200 from 24M bus clock)
   0c # SCIC2 ) mov    ( enable rcvr, xmitter)

   .else .ifdef 4.9152m

   -- Let's try switching on the xtal osc.
   %01_11_0110 # ICSC2 ) mov  ( keep BDIV at /2, start ext osc)
   -- wait for osc to start
   begin  ICSSC 1  bset? until
   -- switch! making sure to change RDIV at the same time
   %00_111_000 # ICSC1 ) mov

   #49152 hhz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   -- At this xtal frequency we can't do better than 38400 and still get a
   -- good divisor.

   SCIBDH ) clr      ( baud rate divisor, high)
   8 # SCIBDL ) mov  ( baud rate divisor, low)
                     ( yields 38400 from 9.8304M bus clock)
   0c # SCIC2 ) mov  ( enable rcvr, xmitter)

   .else .ifdef 9.8304m

   -- Let's try switching on the xtal osc.
   %00_11_0110 # ICSC2 ) mov  ( BDIV to /1 from /2, start ext osc)
   -- wait for osc to start
   begin  ICSSC 1  bset? until
   -- switch! making sure to change RDIV at the same time
   %00_111_000 # ICSC1 ) mov

   #98304 hhz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   -- At this xtal frequency we can't do better than 38400 and still get a
   -- good divisor.

   SCIBDH ) clr       ( baud rate divisor, high)
   10 # SCIBDL ) mov  ( baud rate divisor, low)
                      ( yields 38400 from 9.8304M bus clock)
   0c # SCIC2 ) mov   ( enable rcvr, xmitter)

   .else  ( configure ICS or MCG, depending on device)

      .labels. .contains ICSTRM .if

   -- Configure ICS (internal clock source)
   -- We're staying in FEI mode, but we're going to trim the internal
   -- reference so that our bus clock is 9.216M - a nice multiplier for
   -- 115200.
   -- I've put my own trim values into the chips @ FFAD (for 9.216M).

   0ffad ) lda   ICSTRM ) sta
   -- 0ffad ) lda   0b0 ) sta  ( abstain from setting TRIM; to see QE factory)

   ICSC2 ) clr   ( switch BDIV to /1 from /2)

      .else    -- JS or JM part with MCG

   -- Adjust registers and values for the JS & JM parts, which use a different
   -- clock generator (MCG instead of ICS), and run twice as fast.

   0ffad ) lda   MCGTRM ) sta
   -- leave BDIV/2 set; MCG runs 2x as fast as QG's ICS

      .then  ( ICS vs MCG)

   #9216 khz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   SCIBDH ) clr      ( baud rate divisor, high)
   5 # SCIBDL ) mov  ( baud rate divisor, low)
                     ( yields 115200 from 9.216M bus clock)
   0c # SCIC2 ) mov  ( enable rcvr, xmitter)

   .then  .then  .then  ( xtal vs internal osc)

.ifdef so-that-worked
   -- UART test
   begin
      %1111_1111 # lda  SciTx c
      %0101_0101 # lda  SciTx c
      %0100_1001 # lda  SciTx c
      %0001_0001 # lda  SciTx c
      %0000_0001 # lda  SciTx c
   again
.then

.else  -- 908

   -- Setting COPD works, but is unnecessary in monitor mode; however,
   -- setting RSTEN causes the chip to fly away. Noise on nRST pin?
   -- Since I'm avoiding setting the Reset vector, setting these or not is
   -- irrelevant.
   -- CONFIG2 0 bset  ( set RSTEN: enable nRST pin - pin 8)

   -- I'm going to, after all, attempt to burn a chip with a programmed
   -- Reset vector. So I need this:
   CONFIG1 0 bset  ( set COPD: disable watchdog!)

   -- XXX Set up for use with on-chip crystal osc?
   -- 42 # OSC ) mov  ( set Ext Osc and ECGON)

   -- configure crystal osc
   PortA 4 bset
   DirA 4 bset  ( configure OSC2 as output, drive high several cycles)
   nsa nsa nsa
   DirA 4 bclr
   0c0 # OSC ) mov  ( set external osc going - 8-32MHz xtal)

   -- wait for startup; normally one waits 4096 target cycles; for
   -- simplicity we wait that many cycles, but based on the internal osc,
   -- which is slower (12.8M) than the crystal (18.432M).

   #16 # ldx  ( 4096 = 16 * 256; we don't bother to clr A the first time)
   begin  begin  .a decz? until  .x decz? until
   OSC 1 bset ( set ECGON - switch oscillators!)

   -- Configure SCI
   SCC1 6 ( ENSCI) bset
   %001_10000 # SCPSC ) mov  ( prescaler divisor of 2 + 16/32)
                             ( yields 115200 from 18.432M clock)
   0c # SCC2 ) mov   ( enable rcvr, xmitter)

.then

   begin  interact bsr  again  ;c
