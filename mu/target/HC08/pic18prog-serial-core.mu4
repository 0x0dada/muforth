( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading PIC18 programmer over serial (core)

__meta

hex

( Support for programming PIC18 parts over ICSP, using a serial-connected
  S08QE or QG as a programmer. I need a 3v device for this! So I can't use
  my JS16 - until I set it up with an external 3/3.3v regulator!)

.ndef S08QG  .ndef S08QE32  .and  .if
  z" This code will only run properly on an S08QG or an S08QE32 part."  abort
.then

( The style of this code was inspired by chat3.mu4. It's really just an
  experiment to see if the style that I wrote the USB chat firmware in
  works in this context too. The main difference is that the original chat
  code was a big loop, where the USB "loop" was a subroutine - which meant
  that to return the "top" from any piece of code all you do is _return_.
  And using tail calls, it's easy to code in a Forth-like style that is
  very efficient.)

hex

( Create a forward jump at the start of the flash sector.)
forward-jmp pic18-prog-loop

( Our signature.)
label id
   char P c,  char 1 c,  char 8 c,  ( PIC18 architecture)
   char p c,                        ( programming)
   char 1 c,                        ( version 1)

label recv-serial-byte  ( returns char in A)
   begin  SCIS1 5 ( recvr full)  bset? until
   SCID ) lda  rts  ;c

label send-serial-byte  ( transmits char in A)
   begin  SCIS1 7 ( xmit empty)  bset? until
   SCID ) sta  rts  ;c

( Return a signature of who we are and what we're doing.)
label signon
   .h clr  .x clr
   begin  id ,x lda  send-serial-byte c  .x inc  5 # cpx  0= until
   rts  ;c

( Port pins.)

( On QE32: PTA4 is output-only; PTA5 is input-only)

( PIC18     QG8            QE32            JS16
  ===================================================
  PGC    PTB2, pin 10   PTC5, pin 1     PTA3, pin 11
  PGD    PTB3, pin 9    PTC4, pin 2     PTA2, pin 10
  /MCLR  PTB5, pin 7    PTA4, pin 4     PTA4, pin 12
  PGM    PTB4, pin 8    PTA0, pin 26    PTA1, pin 9

  I created a couple of boards with Microchip PIC18F14K50 USB chips on
  them, and wired a six-pin header with the following pinout, from top to
  bottom:

  *  Gnd
  *  3.3v/5v
  *  PGC/D-  pin 18   NOTE: 3.3v only!
  *  PGD/D+  pin 19   NOTE: 3.3v only!
  *  /MCLR   pin 4
  *  PGM     pin 7
)

.ifdef S08QG

macro PGC        PTBD  2  ;m
macro PGD        PTBD  3  ;m
macro PGD-drive  PTBDD 3  ;m
macro MCLR       PTBD  5  ;m
macro PGM        PTBD  4  ;m

label init-pins
   .a clr  PTBD ) sta   ( set pins low)
   .a com  PTBDD ) sta  ( set them for output)
   %0011_1100 # lda  PTBDS ) sta  ( set high drive)
   rts  ;c

.else .ifdef S08QE32

macro PGC        PTCD  5  ;m
macro PGD        PTCD  4  ;m
macro PGD-drive  PTCDD 4  ;m
macro MCLR       PTAD  4  ;m
macro PGM        PTAD  0  ;m

label init-pins
   .a clr  PTAD ) sta   ( set pins low)
           PTCD ) sta
   .a com  PTADD ) sta  ( set them for output)
           PTCDD ) sta
   %0001_0001 # lda  PTADS ) sta  ( set high drive)
   %0011_0000 # lda  PTCDS ) sta
   rts  ;c

.then .then

( The building blocks.)

comment %% delay-times

  In HX is a _negated_ 16-bit delay count. We negate the count and
  count _up_ to make it easier to know when to increment the high half.
  Remember that inc and dec affect V, N, and Z, but not C.

  I _could_ put it on R stack. Delay would skip over ret address and decr
  2,s and 3,s.

  Delay time is 9n + (9n/256) + 18 ( pshes, ais, call+ret) cycles
              = 9n(1 + 1/256) + 18
              = 9n(257/256) + 18

  QE and QG parts have been trimmed to run at 9.216M so they can
  accuratedly generate 115200 bps clock.

  But one of my QE32 parts is running with a crystal at 24M.

  At 9.216M, to delay 5ms, n = (46,080 - 18) * 256 / (9*257) = 5098
  At 9.216M, to delay 1ms, n = (9216 - 18) * 256 / (9*257) = 1018
           to delay 100us, n = (922 - 18) * 256 / (9*257) = 100

  At 24M, to delay 5ms, n = (120,000 - 18) * 256 / (9*257) = 13,279
  At 24M, to delay 1ms, n = (24,000 - 18) * 256 / (9*257) = 2654
        to delay 100us, n = (2400 - 18) * 256 / (9*257) = 263.6
%%

label delay
   .h psh  .x psh
   begin  begin  1 ,s inc  ( lo)  0= until  0 ,s inc  0= until
   2 # ais  rts ;c

decimal

.ifdef 24m

label 5ms
   -13,279 # ldhx  delay j  ;c

label 1ms
   -2654 # ldhx  delay j  ;c

label 100us
   -264 # ldhx  delay j  ;c

( At 24M we need to slow down the clock pulses a bit, otherwise the PIC
  can't keep up!)

macro short  .x psh  .x pul  ;m

.else  ( 9.216M)

label 5ms
   -5098 # ldhx  delay j  ;c

label 1ms
   -1018 # ldhx  delay j  ;c

label 100us
   -100 # ldhx  delay j  ;c

macro short  ;m

.then

hex

( Now for some spiffy macros that let us define the bit send and receive
  words so that they look like timing diagrams!)

macro D/  PGD bset   ;m
macro D\  PGD bclr   ;m

macro C/  PGC bset  short  ;m
macro C\  PGC bclr  short  ;m

label drive-d  ( drive value of C onto bus)
   CS if  D/  rts  then
          D\  rts  ;c

macro D@  PGD bset? if then  ( sets C with pin value!)  ;m
macro D!  drive-d c    ;m

label send-bit    C/  D!  C\   rts  ;c
label recv-bit    C/  D@  C\   rts  ;c

( 4-bit command to send in A. Send LSB first.)
label send-icsp-cmd
   .a psh  ( byte to send)
   4 # lda  .a psh  ( bit count)
   begin  1 ,s ror  send-bit c  0 ,s decz? until
   2 # ais  rts  ;c

( Byte to send in A. Send LSB first.)
label send-icsp-byte
   .a psh  ( byte to send)
   8 # lda  .a psh  ( bit count)
   begin  1 ,s ror  send-bit c  0 ,s decz? until
   2 # ais  rts  ;c

( Read byte from chip into A.)
label recv-icsp-byte
   PGD-drive bclr  ( undrive PGD)
   .a psh  ( byte accumulator)
   8 # lda  .a psh  ( bit count)
   begin  recv-bit c  1 ,s ror  0 ,s decz? until
   1 ,s lda  2 # ais
   PGD-drive bset  ( redrive PGD)
   rts  ;c

( PGM high, delay, then /MCLR high.)
label enter-prog-mode
   PGM bset  100us c  ( only need to delay 2us)
   MCLR bset
   rts  ;c

( /MCLR low, then PGM low.)
label exit-prog-mode
   MCLR bclr   PGM bclr
   rts  ;c

.ifdef notyet

( Save these so we can repeat an SPI command without having to be driven by
  serial port traffic.)

1 zvar avr-cmd
1 zvar addr-hi
1 zvar addr-lo
1 zvar toggle
1 zvar count

( Receive avr-cmd, addr-lo, addr-hi, toggle, and count via serial)
label setup-command
   .h clr  .x clr
   begin   get-byte c  avr-cmd ,x sta  .x inc  5 # cpx  0= until  rts  ;c

label send-command
   .h clr  .x clr
   begin   avr-cmd ,x lda  SpiTx c  .x inc  3 # cpx  0= until

   ( toggle cmd byte and incr addr-lo if toggled back to 0)
   toggle ) lda  avr-cmd ) eor  avr-cmd ) sta
   toggle ) and  0= if  addr-lo ) inc  ( in zpage!)  then
   rts  ;c

label bulk-read
   setup-command c
   begin
      send-command c
      SpiTx c  ( send dummy, recv byte)  put-byte c  ( send back via serial)
   count ) decz? until  rts  ;c

label bulk-write
   setup-command c
   begin
      send-command c
      get-byte c  ( get serial byte)  SpiTx c  ( send via SPI)
   count ) decz? until  rts  ;c

.then

label simple-read
   recv-serial-byte c  send-icsp-cmd c
   .a clr  send-icsp-byte c  ( send dummy byte)
   recv-icsp-byte c    send-serial-byte j  ;c

label simple-write
   recv-serial-byte c  send-icsp-cmd c
   recv-serial-byte c  send-icsp-byte c
   recv-serial-byte c  send-icsp-byte j  ;c

( Commands:
0-1f  Bye        - exit PIC18 prog code and return to chat loop
  20  Read       - send 4-bit command, send dummy byte, read 1 byte
  21  Write      - send 4-bit command, send 2 bytes
)

label process-serial
   SCIS1 5 ( recvr full)  bclr? if  rts  then  ( nothing to do)
   SCID ) lda  ( command)

   ( NOTE: Command numbers are all given in HEX.)
   20 # sub   ( prog commands start at 20 hex; below that, we exit)
   u< if  ( 00 - 1f Bye)  2 # ais  ( skip return from process-serial)
      exit-prog-mode j  then

   ( 20)  simple-read            0!= until
   ( 21)  simple-write   .a dec  0!= until

   ( unknown command)   rts  ;c

\l pic18-prog-loop resolve>>  ( jump at start of Flash points here)
label main-loop
   init-pins c  ( set up port pins)
   enter-prog-mode c
   signon c     ( tell who we are and what we're doing)
   begin  process-serial c  again  ;c
