( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 BSL support

hex

( Spying on the protocol.)
variable spy  spy off
: send          spy @ if ." >"  dup .h8_ then  _send ;
: recv   _recv  spy @ if ." <"  dup .h8_ then ;

variable checksum
variable checkwhich
: sum  ( b)  checkwhich @  checksum +  dup c@  rot xor  swap c!
             checkwhich @  1 xor  checkwhich ! ;

: sum!  checkwhich off  checksum on ( set to ffff) ;

: >b   dup sum  send ;
: >w   >hilo  >b >b ;

: b>   recv  dup sum ;

: ?match  ( want got)  2dup = if  2drop ^  then
   ." expected "  .h8_  ." got " .h8_ ;

: >buf  ( buf u)  swap m !  ?for  m* >b  next  then ;
: buf>  ( buf u)  swap m !  ?for  b> m&  next  then ;

( For reading back memory from BSL.)
: hdr>  sum!  b> 80 ?match  b> drop  b> b> ?match ;
: chk>  recv checksum    c@  =
        recv checksum 1+ c@  = and  if ^ then
        error" bad checksum received" ;

: ?ack  recv  90 ?match ;
: sync  80 send  ?ack ;

: >length   dup >b  >b ;  ( Send length twice! Genius!)

: <bsl  ( length cmd)  sync  sum!  80 >b  >b  4 + >length ;
: bsl>  checksum    c@ send
        checksum 1+ c@ send ;

( Protocol commands. See Table 2-1, page 11, in SLAU319.

  Cmd   Command name    Direction    Password-protected?
  ===   =============   ==========   ===================
   10   RX password     host -> BSL  No
   12   RX data block   host -> BSL  Yes
   14   TX data block   BSL -> host  Yes
   16   Erase segment   n/a          Yes
   18   Mass erase      n/a          No
   1a   Load PC         n/a          Yes
)

( NOTE: Until further notice, we should not use mass-erase. As far as I
  can tell, it _will_ erase the information memory, which means we'll lose
  the factory calibration data. Perhaps try it with the parameters 04 0a5
  instead? These are the actual command bytes written to FCTL1. 02 is segment
  erase; 04 is erase all main memory; 06 is erase main+info if LOCKA 0.

  See SLAU144, Sec 7.4.1, p324.

  Since the BSL apparently _clears_ LOCKA, using 06 and doing a mass erase
  will erase the info memory.)

: unlock              20 10 <bsl  0 >w  0 >w  20 for  0ff >b  next  bsl> ?ack ;
: txbuf  ( buf a u)  dup 12 <bsl  swap >w  dup >w  >buf  bsl>  ?ack ;
: rxbuf  ( buf a u)    0 14 <bsl  swap >w  dup >w        bsl>  hdr>  buf>  chk> ;
-- : mass-erase           0 18 <bsl  0 >w  06 >b  0a5 >b    bsl>  ?ack ;
: run    ( pc)         0 1a <bsl       >w    0 >w        bsl>  ?ack ;

comment debug-commands

Both BSL and chat should define the following:

  t.chat   ( )          -- say hello
  t.read   ( buf a u)   -- read bytes from target into buf
  t.write  ( buf a u)   -- write bytes from buf into target
  t.flash  ( buf a u)   -- flash bytes from buf into target
  t.go     ( pc)        -- execute code on target

debug-commands

( Let's make sure we're not writing the flash inadvertently - until we know
  exactly what we're doing.)

: in-ram?  ( a - f)   @ram  dup #ram +  within ;
: txbuf-checked   ( buf a u)
   over in-ram? if  2dup + in-ram?  if  txbuf  ^  then  then
   cr  ." write to "  over u.  dup u.  ." blocked"  drop 2drop ;

( Do an operation in 64 byte chunks. This is compatible with the BSL
  protocol - which has a max payload of 250 bytes - and also with the
  process of writing the flash, which can be done by byte, word, or by
  64-byte block.)

variable 'doit  ( buf a u)
: chunk  ( buf a u - buf+u a+u)  push
   cr  ." chunk "  over u.  dup u.  r@ u.
   2dup r@  'doit @execute  pop dup v+ ;

: chunked  ( buf a u 'code - buf+u a+u)  'doit !
   40 u/mod  ( r q)  swap push  ?for  40 chunk  next  then
                         pop =if  ( rem) chunk  ^  then  drop ;

: t.chat  ( start things going)  #9600 bps  even-parity  unlock ;

: t.read    ( buf a u)  ['] rxbuf          chunked  2drop ;
: t.write   ( buf a u)  ['] txbuf-checked  chunked  2drop ;

: t.go      ( pc)  run ;
