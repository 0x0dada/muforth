( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 serial chat protocol - Forth-specific (host)

hex

( Taking inspiration from the wildly successful HC08 serial chat protocol.

  Responds to the following commands. NOTE: these are hex values!

00 - 1f  Idle   - these command bytes are ignored

20  GetVersion  - get the chat protocol version
21  SetAddr     - set the memory address pointer
22  GetCheck    - return accumulated checksum to host; reset it

23  ReadWord    - read a word from memory, incr pointer
24  WriteWord   - write a word to memory, incr pointer
25  FlashWord   - write a word to flash, using command byte saved on stack
                - can be used to initiate an erase, or to write a word

26  GetDepth    - get stack depth
27  Pop         - pop one word from stack
28  Push        - push one word onto stack
29  Execute     - execute top, using rest of stack as params

2a - ff  Idle   - these command bytes are ignored
)

variable checksum
: sum!  0ffff checksum ! ;
: sum  ( w)  checksum @  xor  checksum ! ;

: >b         dup sum  send ;
: b>   recv  dup sum ;

: >w                     dup sum  >hilo  send send ;
: w>   recv recv  lohi>  dup sum ;


( We need this _first_ so we can define the other words, in paranoid mode,
  to check their sums.)

: c.GetCheck    ( - w)    22 >b      w> ;

.ifdef paranoid

: ?ok
   c.GetCheck drop
   checksum @  sum!  dup 0= if  drop ^  then
   ." checksum failed: " u. ;

: ?reset
   c.GetCheck drop  sum! ;

.else

: ?ok ;
: ?reset ;

.then


: c.Idle                   0 >b         ;
: c.GetVersion  ( - n)    20 >b      w> w>  ( lo hi)  10 << +  ?ok ;
: c.SetAddr     ( a)      21 >b  >w      ?ok ;
( c.GetCheck              22)

: c.ReadWord    ( - w)    23 >b      w> ;
: c.WriteWord   ( w)      24 >b  >w     ;
: c.FlashWord   ( w - w)  25 >b  >w  w> ;

: c.GetDepth    ( - n)    26 >b      w>  ?ok ;
: c.PopWord     ( - w)    27 >b      w> ;
: c.PushWord    ( w)      28 >b  >w     ;
: c.Execute               29 >b         ; 


: resync  flush  c.Idle  c.Idle ;

: c.setup-chunk  ( buf a u - #words)
   swap c.SetAddr  swap m !  1+ 2/ ( words) ;

( Hook into interact code.)
: c.Hello
   tty-target target-raw
   #115200 bps  resync  drain
   ?reset
.ifndef ignore-version
   cr ." Chat firmware version "  c.GetVersion
   radix preserve  hex  sep preserve  -sep   u.
.then ;

: c.ReadChunk    ( buf a u)
   c.setup-chunk  ?for  c.ReadWord  >hilo  m& m&  next  then
   ?ok ;

: c.WriteChunk   ( buf a u)
   c.setup-chunk  ?for  m* m* lohi>  c.WriteWord  next  then
   ?ok ;

: c.ErasePage ( a fcmd - status)
   c.PushWord  c.SetAddr  0 c.FlashWord  c.PopWord drop ( fcmd)  ?ok ;

( Or together the statuses from each FlashWord command and return it.)
: c.FlashChunk   ( buf a u fcmd - status)
   c.PushWord
   c.setup-chunk  0 swap  ?for  m* m* lohi>  c.FlashWord  or  next  then
   c.PopWord drop ( fcmd)
   ?ok ;

: c.GetRegs  ( buf - sp)  drop  c.GetDepth ;


( The interact interfaces for ReadWord and WriteWord take an address. Let's
  make that work, but also streamline the conversation with the target to
  only set the address if necessary.)

variable chat-addr  chat-addr on
: ?set-addr  ( a)
   chat-addr @ over xor if  dup c.SetAddr  then  \m cell+  chat-addr ! ;

: c.ReadWordAddr   ( a - w)  ?set-addr  c.ReadWord   ?ok ;
: c.WriteWordAddr  ( w a)    ?set-addr  c.WriteWord  ?ok ;


( NOTE: We don't define RunWait separately. Since we will always be reading
  the registers back after Run, that first command - the GetSP in GetRegs -
  will block until the target is ready.)

: chat
   chat-via  c.Hello  c.GetRegs  chat-fail  c.ReadWordAddr  c.WriteWordAddr
             c.ReadChunk  c.WriteChunk  c.ErasePage  c.FlashChunk
             c.Execute  c.Execute ;
