( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 serial chat protocol - Forth-specific (core)

hex

( Taking inspiration from the wildly successful HC08 serial chat protocol.

  Responds to the following commands. NOTE: these are hex values!

00 - 1f  Idle   - these command bytes are ignored

20  GetVersion  - get the chat protocol version
21  SetAddr     - set the memory address pointer
22  GetCheck    - return accumulated checksum to host; reset it

23  ReadWord    - read a word from memory, incr pointer
24  WriteWord   - write a word to memory, incr pointer
25  FlashWord   - write a word to flash, using command byte saved on stack
                - can be used to initiate an erase, or to write a word
26  Run         - run non-forth code; pop IP, RP, Top, and do return

27  GetDepth    - get stack depth
28  Pop         - pop one word from stack
29  Push        - push one word onto stack
2a  RunForth    - pop IP, RP, and Top, and do NEXT

2b - ff  Idle   - these command bytes are ignored
)

assembler
comment %%
  NOTE: if we did  w )+ pc mov  next would take 1 cycle more, but docolon
  and friends would be shorter and simpler... %%

: next     asm{  ip )+ w mov  w ) pc mov  } ;

: rpush    ( ea)  asm{   2 # rp sub   ( ea)  rp )  mov  } ;
: rpop     ( ea)  asm{       rp )+  \f swap ( ea)  mov  } ;

: nest     asm{  ip rpush  } ;
: unnest   asm{  ip rpop   } ;
forth

__meta

( Register conventions:
  Use  ip as memory pointer
       rp as data stack pointer
      top as top of data stack, in forth code; unused elsewhere
        w as a general parameter
        x as scratch
        y as checksum)

label get-byte
   begin  01 # IFG2 & bitb  0!= until
   UCA0RXBUF & w movb  ret  ;c

label put-byte
   begin  02 # IFG2 & bitb  0!= until
   w UCA0TXBUF & movb  ret  ;c

label get-word
   get-byte c  w x mov
   get-byte c  w swpb  x w bis  w y xor  ret  ;c

label put-word
   w y xor  ( fall thru)  ;c

label put-word-unsummed
   put-byte c  w swpb  put-byte j  ;c

( Compile the first 32 bits of the current muforth Git commit.
  When asked for the version, return these two 16-bit words, in
  little-endian order.)

muforth-commit drop 8 evaluate
   dup 10 >>  swap  ( high low)

label get-version
   ( commit-lo) # w mov  put-word c
   ( commit-hi) # w mov  put-word j  ;c

label set-addr
   get-word c  w ip mov  ret  ;c

label read-word
   ip )+ w mov  put-word j  ;c

label write-word
   get-word c  w ip ) mov  2 # ip add  ret  ;c

( Write a word into flash, using the flash command stored on the stack. It
  can be used to erase or program the flash.)

label flash-word
   get-word c                    -- get value to write
   FKEY         # FCTL3 & mov    -- clear FLOCK
   rp ) FCTL1 & mov              -- write flash command - must have FKEY!
   w ip ) mov  2 # ip add        -- write word and incr pointer
.ifdef in-ram
   begin  FBUSY # FCTL3 & bit  0= until
.then
   FKEY # FCTL1 & mov            -- clear command
   FKEY FLOCK + # FCTL3 & mov    -- set FLOCK
   FCTL3 & w mov  put-word j     -- read status and return it
   ;c

label get-check
   y w mov  0ffff # y mov  put-word-unsummed j  ;c


( Forth-specific words.)

@ram #ram +  equ rp0  ( bottom of R stack!)
rp0 #48 -    equ sp0  ( bottom of D stack!)

( sp0 is d stack bottom. NOTE: using rp as _data_ stack pointer in this
  code!)

label get-depth
   sp0 # w mov  rp w sub  w asr  put-word j  ;c

label pop-word
   sp0 # rp cmp  0= if  cafe # w mov   put-word j  then
                               w rpop  put-word j  ;c

label push-word
   get-word c  w rpush  ret  ;c

code execute   top w mov  top pop  w ) pc mov  ;c
code branch    ip ) ip mov  next  ;c

label call-bug  ( point IP here!)
   ' execute ,
   0 ,  ( bug)
   ' branch ,  call-bug ,

label switch-stacks
   sp w mov  rp sp mov  w rp mov
   pc rpop  ( pop return address from R!)

label run-forth
   switch-stacks c  ip pop   rp pop   top pop   next  ;c

label run  ( non-forth code)
                    ip rpop  sp rpop  top rpop  ret  ;c

( Dispatch.)
label command-table
   get-version ,  set-addr ,  get-check ,
   read-word ,  write-word ,  flash-word ,  run ,
   get-depth ,  pop-word ,  push-word ,  run-forth ,

label process
   get-byte c  ( cmd)
   w y xor

   20 # w sub   ( 0 to 1f become large unsigned numbers)
   process command-table - 2/ # w cmp  u< if
      w w add  command-table w +) pc mov  ( jump!)
   then

   ( unknown... ignore!)
   ret  ;c

( Push registers and start conversing with host.)

here call-bug 2 + image-!  ( fix up call-bug to point to bug!)
code bug
   switch-stacks c  ( fall thru)  ;c

label start-chat
   ( pc has been pushed onto R stack already)
   top rpush  sp rpush  ip rpush  ( push TOP, RP, and IP onto D stack)
   begin  process c  again  ;c


Vreset handler
   rp0 # sp mov         ( return stack starts out empty)
   sp0 # rp mov         ( data stack starts out empty...)
   cafe # top mov       ( ...with a silly marker in top)
   call-bug # ip mov    ( start out with IP pointing to execute loop)

   -- disable watchdog timer
   WDTKEY 80 + # WDTCTL & mov

   -- Set clock to factory-calibrated 16 MHz
   -- See G2553 datasheet, p15
   TAG_DCO_30 CAL_BC1_16MHZ + & BCSCTL1 & movb
   TAG_DCO_30 CAL_DCO_16MHZ + & DCOCTL & movb
   BCSCTL2 & clrb

   -- Configure UART for 115,200 bps, 8 bits, no parity
   81 # UCA0CTL1 & bisb          -- enable SMCLK
                                 -- hold UART in reset while configuring
   UCA0CTL0 & clrb               -- reset to defaults: 8 bits, no parity, 1 stop
   UCA0BR1 & clrb                -- set baud rate divisor
   8 # UCA0BR0 & movb
   %1011_0001 # UCA0MCTL & movb  -- 16x oversample; set modulator for 115,200
   01 # UCA0CTL1 & bicb          -- bring UART out of reset

   -- Connect port pins P1.1 and P1.2 to UART
   -- SEL=1 & SEL2=1
   %0000_0110 # P1SEL & bisb
   %0000_0110 # P1SEL2 & bisb

   -- Set up flash clock; needs to be between 257 and 476 kHz (no joke)
   -- We're running at 16M, so set it to 16M/40 = 400k.
   FKEY #39 ( divisor-1) +  %0100_0000 ( MCLK)  + # FCTL2 & mov

   begin  start-chat c  again  ;c


( Set BSL flag to _not_ mass erase if wrong password entered during BSL
  "hello" sequence.)

here
Vbslkey org  0 ,
org
