( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 serial chat protocol (core)

hex

__meta

( Taking inspiration from the wildly successful HC08 serial chat protocol.

  Responds to the following commands. NOTE: these are hex values!

00 - 0f  Idle   - these command bytes are ignored

10  GetVersion  - get the chat protocol version
11  SetAddr     - set the memory address pointer
12  GetSP       - get stack pointer - points to saved regs
13  ReadWord    - read a word from memory, incr pointer
14  ReadWords   - read N words, incrementing as we go
15  WriteWord   - write a word to memory, incr pointer
16  Run         - pop the registers and saved status, and go
17  FlashWord   - write a word to flash, using command byte saved on stack
                - can be used to initiate an erase, or to write a word
18  GetCheck    - return accumulated checksum to host

19 - ff  Idle   - these command bytes are ignored
)


( Register conventions:
  Use  ip as memory pointer
    count as byte count
        w to pass a parameter around
        x as scratch
        y as checksum)

label get-byte
   begin  01 # IFG2 & bitb  0!= until
   UCA0RXBUF & w movb  ret  ;c

label put-byte
   begin  02 # IFG2 & bitb  0!= until
   w UCA0TXBUF & movb  ret  ;c

label get-word
   get-byte c  w x mov
   get-byte c  w swpb  x w bis  w y xor  ret  ;c

label put-word
   w y xor  ( fall thru)  ;c

label put-word-unsummed
   put-byte c  w swpb  put-byte j  ;c

( Compile the first 32 bits of the current muforth Git commit.
  When asked for the version, return these two 16-bit words, in
  little-endian order.)

muforth-commit drop 8 evaluate
   dup 10 >>  swap  ( high low)

label get-version
   ( commit-lo) # w mov  put-word c
   ( commit-hi) # w mov  put-word j  ;c

label set-addr
   get-word c  w ip mov  ret  ;c

label get-sp
   sp w mov  2 # w add  put-word j  ;c

label read-word
   ip )+ w mov  put-word j  ;c

label read-words
   get-byte c  w tst  0!= if
      w y xor  w count mov
      begin  read-word c  1 # count sub  0= until
   then  ret  ;c

label write-word
   get-word c  w ip ) mov  2 # ip add  ret  ;c

label run
   4 # sp add  ( skip return address from process & flash command)
   count pop  w pop  x pop  y pop  ( regs used by chat)
   ip pop  rp pop                  ( regs needed by host)
   reti  ;c

( Write a word into flash, using the flash command stored on the stack. It
  can be used to erase or program the flash.)

label flash-word
   get-word c                    -- get value to write
   FKEY         # FCTL3 & mov    -- clear FLOCK
   2 sp +) FCTL1 & mov           -- write flash command - must have FKEY!
   w ip ) mov  2 # ip add        -- write word and incr pointer
.ifdef in-ram
   begin  FBUSY # FCTL3 & bit  0= until
.then
   FKEY # FCTL1 & mov            -- clear command
   FKEY FLOCK + # FCTL3 & mov    -- set FLOCK
   FCTL3 & w mov  put-word j     -- read status and return it
   ;c

label get-check
   y w mov  0ffff # y mov  put-word-unsummed j  ;c

( Dispatch.)
label command-table
   get-version ,  set-addr ,  get-sp ,
   read-word ,  read-words ,  write-word ,
   run ,  flash-word ,  get-check ,

label process
   get-byte c  ( cmd)
   w y xor

   10 # w sub   ( 00 to 0f become large unsigned numbers)
   process command-table - 2/ # w cmp  u< if
      w w add  command-table w +) pc mov  ( jump!)
   then

   ( unknown... ignore!)
   ret  ;c


( Push registers and start conversing with host.)

( How this is done - what registers are pushed, and in what order - is an
  evolving story. It should be simple. I should probably push everything.
  But that would be slow and a waste, esp since this chat code is primarily
  designed to support the execution of _Forth_ code, not arbitrary native
  code.

  OTOH, having the chat code too wedded to assumptions about the register
  conventions of the code it supports also seems like a mistake.

  I think I've arrived, enfin, at a solution: We push registers that belong
  to either of two sets:

  * registers that are _used_ by chat itself
  * registers that are likely needed by the host in order to execute target code

  We push the chat registers first, at the top of the frame, then the
  registers wanted by the host below these. This way the host can optionally
  leave the chat-saved regs alone. Basically, it can pretend that they are
  not even there, rather than copying them back and forth.

  This leaves at least one question unanswered: Where does the status
  register get saved? Is it part of the chat-saved regs that the host doesn't
  care about? But what if we want to display it to the user? Right now it
  gets pushed at the top of the frame, just below the PC, so that we can
  execute code by doing an "reti" instruction... But this isn't strictly
  necessary.

  Also, the PC is among those registers that the host will likely want to
  read and change... But it's currently at the top of the frame.

  Solution: Put the registers for the host at the _top_ of the frame, under
  the PC and status register. Then push the chat-saved registers below these.
  The host can ignore them. It may not even _see_ them, depending on what
  value we return for GetSP. Because we're putting the flash command at the
  top of the frame, we'll be passing the address of the whole frame to the
  host; however, it only has to read and write ip and above.

  Lastly, what of "top"? It is, strictly speaking, not a normal register,
  but rather, part of the target's stack. Ideally the forth-specific
  "trampoline" code used to execute target code, and to trap back into chat,
  should be responsible for saving and restoring top.)

label chat-entry
   ( call has already pushed PC)
    sr push  sr clr  ( disable interrupts!)
    rp push  ip push                       ( needed by host)
     y push   x push  w push  count push   ( used by chat)
   0 # push  ( room for flash command)

   begin  process c  again  ;c

label interact
   begin  chat-entry c  again  ;c

Vreset handler
   -- set SP to end of RAM
   @ram #ram +  # sp mov

   -- disable watchdog timer
   WDTKEY 80 + # WDTCTL & mov

   -- Set clock to factory-calibrated 16 MHz
   -- See G2553 datasheet, p15
   TAG_DCO_30 CAL_BC1_16MHZ + & BCSCTL1 & movb
   TAG_DCO_30 CAL_DCO_16MHZ + & DCOCTL & movb
   BCSCTL2 & clrb

   -- Configure UART for 115,200 bps, 8 bits, no parity
   81 # UCA0CTL1 & bisb          -- enable SMCLK
                                 -- hold UART in reset while configuring
   UCA0CTL0 & clrb               -- reset to defaults: 8 bits, no parity, 1 stop
   UCA0BR1 & clrb                -- set baud rate divisor
   8 # UCA0BR0 & movb
   %1011_0001 # UCA0MCTL & movb  -- 16x oversample; set modulator for 115,200
   01 # UCA0CTL1 & bicb          -- bring UART out of reset

   -- Connect port pins P1.1 and P1.2 to UART
   -- SEL=1 & SEL2=1
   %0000_0110 # P1SEL & bisb
   %0000_0110 # P1SEL2 & bisb

   -- Set up flash clock; needs to be between 257 and 476 kHz (no joke)
   -- We're running at 16M, so set it to 16M/40 = 400k.
   FKEY #39 ( divisor-1) +  %0100_0000 ( MCLK)  + # FCTL2 & mov

   begin  interact c  again  ;c


( Set BSL flag to _not_ mass erase if wrong password entered during BSL
  "hello" sequence.)

here
Vbslkey org  0 ,
org
