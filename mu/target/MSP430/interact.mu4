( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 interaction

variable chatting

variable chat-vector
: chat-cmd   ( index)  cells  constant
             does> @  chat-vector @ =if  +  @execute  ^  then  2drop
                error" Not connected to a chat-capable target" ;

: chat-fail   error" Chat command not implemented" ;

 0 chat-cmd t.Hello
 1 chat-cmd t.GetRegs      ( buf - sp)
 2 chat-cmd t.SetRegs      ( buf)
 3 chat-cmd t.ReadWord     ( a - w)
 4 chat-cmd t.WriteWord    ( a w)
 5 chat-cmd t.ReadChunk    ( buf a u)  ( XXX order??)
 6 chat-cmd t.WriteChunk   ( buf a u)
 7 chat-cmd t.ErasePage    ( a cmd - status)
 8 chat-cmd t.FlashChunk   ( buf a u cmd - status)
 9 chat-cmd t.Run
10 chat-cmd t.RunWait


: >chat
   ['] t.ReadChunk  is |read    ( read from connected target)
   ['] leh@         is |cell@
                     2 |cell !  ( size of cell)
                     2 |addr !  ( size of addr) ;

: copy-chunk  ( a u)
   =if
      -- cr  ." copy-chunk "  over u. dup u.
      over image+ -rot  t.WriteChunk  ^
   then  2drop ;

variable ram-copied  ( pointer to first un-copied byte)

: copy-ram
   h preserve  ram
   ram-copied @  dup 0= if  drop  origin  then
   \m here  over -  copy-chunk
   \m here  ram-copied ! ;


( For reading and writing target cells.)
: t@  ( addr - h)  t.ReadWord ;
: t!  ( h addr)    t.WriteWord ;


.ifdef avr-bogus

: rp0  \eq SPL  t@  1+ ;             ( bottom of target's R stack)
: sp0  chat-frame @  -2 and  64 - ;  ( bottom of target's D stack;
                                       room for 32 values on R)
: sp!  ( target-sp)      .Y  t! ;
: sp@  ( - target-sp)    .Y  t@ ;
: top!  ( target-top)    .T  t! ;
: top@  ( - target-top)  .T  t@ ;

( PC on R stack is big-endian and is a cell address, not a byte address.)
: pc!  ( target-cfa)    >ra  .PC  t! ;
: pc@  ( - target-cfa)       .PC  t@  ra> ;

: depth  \m sp0 \m sp@ -  \m cell/ ;  ( depth of actual stack)
: u.  u. ;
: .  . ;
: .s  .s ;

.then


( The chat firmware has pushed an "exception frame" onto the stack.)

: reg  ( index)  \m cells  constant ;

.ifdef newregs

00 reg .FCMD      -- flash command

01 reg .COUNT
02 reg .W
03 reg .X
04 reg .Y

05 reg .IP
06 reg .RP
07 reg .SR        -- status register
08 reg .PC
09 reg .LAST

.else

00 reg .FCMD     -- flash command
01 reg .IP
02 reg .W
03 reg .RP
04 reg .COUNT
05 reg .TOP
06 reg .X
07 reg .Y
08 reg .SR       -- status register
09 reg .PC
10 reg .LAST

.then

.LAST buffer chat-frame  ( local copy of target's stack frame)
    variable chat-sp     ( current value of target's SP)

: get-regs   chat-frame t.GetRegs  chat-sp ! ;
: set-regs   chat-frame t.SetRegs ;

( These index into our local chat-frame, _not_ into target memory!)
: reg@   ( offset - reg)   chat-frame +  leh@ ;
: reg!   ( reg offset)     chat-frame +  leh! ;

: 2sp  space space ;
: .b9  binary  <#  # # # #  # # # #  #  #> type ;
: .h16    hex  <#  # # # #  #> type ;
: .r   ( offset)  reg@  .h16  2sp ;
: .sr       .SR   reg@  .b9   2sp ;

: .regs
   radix preserve

.ifdef newregs

   cr  ." V----INZC    IP     W    RP   Cnt     X     Y    SP    PC"
       (  000100011  0000  0000  0000  0000  0000  0000  0000  0000)
   cr           .sr
                   .IP .r
                          .W .r
                               .RP .r
                                  .COUNT .r
                                            .X .r
                                                  .Y .r
                                         chat-sp @ .h16 2sp  .PC .r ;
.else

   cr  ." V----INZC    IP     W    RP   Cnt   Top     X     Y    SP    PC"
       (  000100011  0000  0000  0000  0000  0000  0000  0000  0000  0000)
   cr           .sr
                   .IP .r
                          .W .r
                               .RP .r
                                  .COUNT .r
                                          .TOP .r
                                                  .X .r
                                                        .Y .r
                                               chat-sp @ .h16 2sp  .PC .r ;
.then

( Entry into chat pushes a return address that, if returned - or jumped -
  to, will get us back into chat.)

variable chat-pc

: hi  chatting on  >chat  t.Hello  ram-copied off  copy-ram
      get-regs  .PC reg@  chat-pc !  .regs ;

: chat-via   pop  chat-vector !  hi ;


( NOTE: All the following d.Foobar commands are the dummy
  _implementations_ of the chat command interface.)

.LAST buffer dummy-frame

: d.Hello  ." Connecting to dummy chat target."
   ( Init each reg in dummy-frame to its index, then set PC to RAM)
   dummy-frame m !
   0  .LAST \m cell/ for  dup >hilo m& m&  \m cell+  next  drop
   "220 .PC dummy-frame +  leh! ;

: d.ReadWord     ( a - w)
   cr  ." dummy read word "  dup u.
   image-@ ;

: d.WriteWord     ( w a)
   cr  ." dummy write word "  over u.  dup u.
   image-! ;

: d.ReadChunk    ( buf a u)
   -- cr  ." Dummy read chunk "  2 nth u.  over u.  dup u.
   push  image+  2dup xor if  swap pop cmove  ^  then
   rdrop  2drop ;

: d.WriteChunk   ( buf a u)
   -- cr  ." Dummy write chunk "  2 nth u.  over u.  dup u.
   push  image+  2dup xor if       pop cmove  ^  then
   rdrop  2drop ;

: d.ErasePage   ( a fcmd - status)
   -- cr  ." Dummy erase page "  over u.  dup u.
   2drop  "9658 ;

: d.FlashChunk   ( buf a u fcmd - status)
   drop  d.WriteChunk  "9658 ;

: d.GetRegs  ( buf - sp)
   ( copy dummy-frame to buf)
   dummy-frame swap .LAST cmove  "dead ;

: d.SetRegs  ( buf)
   ( copy buf to dummy-frame)
   dummy-frame .LAST cmove ;

: dummy
   chat-via  d.Hello  d.GetRegs  d.SetRegs  d.ReadWord  d.WriteWord
             d.ReadChunk  d.WriteChunk  d.ErasePage  d.FlashChunk
            ( Run   RunWait)
             nope    nope  ;


.ifdef avr-bogus

( The semantics of moving cells to and from the target stack are a bit
  complicated.

  When the target stack is empty, sp0 = sp, and the top register contains
  garbage.

  When the target stack isn't empty, the distance between sp0 and sp is
  2*depth, but the bottom-most cell is garbage, and top is valid.)

: stack>  ( "push" stack to target)
   depth 0= if  "cafe \m top!  \m sp0 \m sp!  ^  then
   \m top!
   depth 7 min  ( more than that would be silly)
   \m sp0 over 1+ \m cells -  dup \m sp! ( top of D stack)  swap
   ?for  tuck t!  \m cell+  next  then  ( copy each cell as a word to D stack)
   "cafe swap t! ( push bottom) ;

: stack<  ( "pop" stack from target)
   \m depth 0 max 8 min  ( more than that would be silly)  =if
      1- ( depth, excluding top)  =if
         \m sp@ over  ( n sp n)
         for  dup t@  pop 2push  \m cell+  next  ( starting with top, push to R)
         drop ( sp)
         for  2pop push  next  ( pop from R to reverse order)
         0
      then  \m top@  swap
   then  drop ;

( Get target's hardware SP - ie, forth's return stack ptr - and store into
  chat-frame.)

: get-rp   \m rp0  \m cell+ ( skip ret addr)  chat-frame ! ;

: runwait  zgo  get-rp  .regs ;

( XXX Should we try to automatically connect to target?)
: remote  ( cfa)  ( execute target forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  \m pc!  stack>  runwait  stack< ;

: rx  ( cfa)  ( execute target non-forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  \m pc!          runwait ;


( Interacting with a chatty, connected target.)

-:  ."  (interacting with target)"  ;
-:
      .meta. find  if  execute          ^  then  ( labels are in .meta.)
    .target. find  if  execute  remote  ^  then  ( execute as forth word)
   .equates. find  if  execute          ^  then
.ifdef no-number                                 complain ;
.else                                            number ;
.then
mode __target

.then  ( avr-bogus)


( Set |@ and |c@ to _some_ form of target fetch. Prefer to get bytes from
  target if we're connected. This word is useful so we can set an initial
  state for target's  du  and  dis  so that inspect won't crash when it
  runs |@ to get a default ea.)

: >target  chatting @ if  >chat ^  then  >image ;


( Define our own key bindings for memory dumping and disassembly. We'll
  default to host bindings if there isn't one in our array. This way we
  only have to define the "delta" between host and target behaviours.)

128 array msp-seekeys

( Default key action is to run host key code)
host-seekeys msp-seekeys  128 cells cmove

( Dump one line of memory from target program memory.)
: 1dump  ( a)
   hex-bytes
   >image    dup .addr  dup .hex-cells
   chatting @ if
      -valid
      >chat  dup _addr  dup .hex-cells
      -valid
   then
   drop ;

( So we can easily look at the signature embedded into the image.)
: 1dump-chars  ( a)
   hex-bytes
   >target
   dup _addr  dup .chars
   dup .addr  dup .hex-bytes
   dup _addr  dup .hex-cells
   drop ;

msp-seekeys  -1
   2dup  du-mode dumping        >target  skip+  skip-  1dump        ( a - a')
   2dup  du-mode dumping-chars  >target  skip+  skip-  1dump-chars  ( a - a')
         du-mode disasming      >target  dis+   dis-   1dis         ( a - a')

msp-seekeys 'seekeys !  ( switch over to our bindings)

key: d  ( a - a 0)   dumping        0 ;
key: C  ( a - a 0)   dumping-chars  0 ;  ( small c is "call")
key: i  ( a - a 0)   disasming      0 ;

host-seekeys 'seekeys !  ( back to host bindings)


( Interactive)

( make an alias so we can still get to it)
: _du  du ;

: du   ( a - a')   dumping     inspect ;
: dis  ( a - a')   disasming   inspect ;


: _runwait  set-regs  t.RunWait  get-regs ;
: _run      set-regs  t.Run ;  ( don't wait for target)

: runwait   _runwait  .regs ;

: 'reset   \eq Vreset image-@  .PC reg! ;
: reset    'reset  runwait ;
: go       'reset  _run ;  ( when the code you're calling doesn't speak
                             the same protocol as running code)

( Execute ram-resident code.)
( XXX for testing)

variable 'trampoline
variable 'start-forth

: trampoline!  ( cfa)
   'trampoline @  dup .IP reg!  t!  chat-pc @  'trampoline @ 4 + t!
   'start-forth @ .PC reg! ;

( Because the target "caches" the top of the stack in a register, and
  because the trampoline code loads this register before execution, and
  pushes it afterward, we can deal only with the "memory image" of the target
  stack, rather than also worrying about what to put into the "top" register.

  What's a bit mystifying is that, to achieve a target stack depth of N,
  the host has to push N+1 items. The top one goes into top; and the
  bottom-most one is the "sentinel" value, that gets loaded into top when the
  stack becomes empty.

  When pushing from the host, or when "pulling" from the target, we don't
  move more than 8 items.)

meta
: sp0   [ @ram #ram +  #48 - ] ;
: sp!   .RP reg! ;  ( the trampoline code swaps RP and SP)
: sp@   .RP reg@ ;  ( the trampoline code swaps RP and SP)
: depth   \m sp0  \m sp@ -  \m cell/  1- ;
forth

: stack>  ( "push" stack to target)
   depth 0 max 8 min
   \m sp0  over 1+  \m cells -  dup \m sp! ( top of D stack)  swap
   ?for  tuck t!  \m cell+  next  then  ( copy each cell as a word to D stack)
   "cafe swap t! ( sentinel) ;

: stack<  ( "pop" stack from target)
   \m depth 0 max 8 min  =if
      \m sp@ over  ( n sp n)
      for  dup t@  pop 2push  \m cell+  next ( starting with top, push to R)
      drop ( sp)
      for  2pop push  next  ( pop from R to reverse order)
      0
   then  drop ;

: remote  ( cfa)  ( execute target forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  trampoline!  stack>  runwait  stack< ;

: rx  ( x y pc - x' y')  ( execute target non-forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  .PC reg!  .Y reg!  .X reg!  runwait  .X reg@  .Y reg@ ;
