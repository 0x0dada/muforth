( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 interaction

variable chatting

variable chat-vector
: chat-cmd   ( index)  cells  constant
             does> @  chat-vector @ =if  +  @execute  ^  then  2drop
                error" Not connected to a chat-capable target" ;

: chat-fail   error" Chat command not implemented" ;

 0 chat-cmd t.Hello
 1 chat-cmd t.GetRegs      ( buf - sp)
 2 chat-cmd t.SetRegs      ( buf)
 3 chat-cmd t.ReadWord     ( a - w)
 4 chat-cmd t.WriteWord    ( a w)
 5 chat-cmd t.ReadChunk    ( buf a u)  ( XXX order??)
 6 chat-cmd t.WriteChunk   ( buf a u)
 7 chat-cmd t.ErasePage    ( a cmd - status)
 8 chat-cmd t.FlashChunk   ( buf a u cmd - status)
 9 chat-cmd t.Run
10 chat-cmd t.RunWait


: >chat
   ['] t.ReadChunk  is |read    ( read from connected target)
   ['] leh@         is |cell@
                     2 |cell !  ( size of cell)
                     2 |addr !  ( size of addr) ;

: copy-chunk  ( a u)
   over image+ -rot  t.WriteChunk ;

: copy-ram
   h preserve
   ram  region  ( a u)  copy-chunk ;


( For reading and writing target cells.)
: t@  ( addr - h)  t.ReadWord ;
: t!  ( h addr)    t.WriteWord ;


.ifdef avr-bogus

: rp0  \eq SPL  t@  1+ ;             ( bottom of target's R stack)
: sp0  chat-frame @  -2 and  64 - ;  ( bottom of target's D stack;
                                       room for 32 values on R)
: sp!  ( target-sp)      .Y  t! ;
: sp@  ( - target-sp)    .Y  t@ ;
: top!  ( target-top)    .T  t! ;
: top@  ( - target-top)  .T  t@ ;

( PC on R stack is big-endian and is a cell address, not a byte address.)
: pc!  ( target-cfa)    >ra  .PC  t! ;
: pc@  ( - target-cfa)       .PC  t@  ra> ;

: depth  \m sp0 \m sp@ -  \m cell/ ;  ( depth of actual stack)
: u.  u. ;
: .  . ;
: .s  .s ;

.then


( chat-entry has pushed an "exception frame" onto the stack.

  The order, low to high: flashcmd ip w rp count top x y status pc)

: reg  ( index)  \m cells  constant ;

00 reg .FCMD     -- flash command
01 reg .IP
02 reg .W
03 reg .RP
04 reg .COUNT
05 reg .TOP
06 reg .X
07 reg .Y
08 reg .SR       -- status register
09 reg .PC
10 reg .LAST

.LAST buffer chat-frame  ( local copy of target's stack frame)
    variable chat-sp     ( current value of target's SP)

: get-regs   chat-frame t.GetRegs  chat-sp ! ;
: set-regs   chat-frame t.SetRegs ;

( These index into our local chat-frame, _not_ into target memory!)
: reg@   ( offset - reg)   chat-frame +  leh@ ;
: reg!   ( reg offset)     chat-frame +  leh! ;

: 2sp  space space ;
: .b9  binary  <#  # # # #  # # # #  #  #> type  2sp ;
: .r   ( offset)  reg@  .hcell  2sp ;

: .regs
   radix preserve
   cr  ." V----INZC    IP     W    RP   Cnt   Top     X     Y    SP    PC"
       (  000100011  0000  0000  0000  0000  0000  0000  0000  0000  0000)
   cr  .SR reg@ .b9
                   .IP .r
                          .W .r
                               .RP .r
                                 .COUNT .r
                                          .TOP .r
                                                  .X .r
                                                        .Y .r
                                             chat-sp @ .hcell 2sp  .PC .r ;

: hi  chatting on  >chat  t.Hello  copy-ram  get-regs  .regs ;
: chat-via   pop  chat-vector !  hi ;


( NOTE: All the following d.Foobar commands are the dummy
  _implementations_ of the chat command interface.)

: d.Hello  ." Connecting to dummy chat target." ;

: d.ReadChunk    ( buf a u)
   cr  ." Dummy read chunk "  rot u.  swap u.  u.  cr ;

: d.WriteChunk   ( buf a u)
   cr  ." Dummy write chunk "  rot u.  swap u.  u.  cr ;

: d.ErasePage   ( a fcmd - status)
   cr  ." Dummy erase page "  swap u.  u.
   -- 2drop
   "9658 ;

: d.FlashChunk   ( buf a u fcmd - status)
   cr  ." Dummy flash chunk "  push  rot u.  swap u.  u.  pop u.
   -- 2drop 2drop
   "9658 ;

( The order, low to high: flashcmd i r t cnt x y status pc)
( GetRegs sets each register to its index in the frame.)
: d.GetRegs  ( buf - sp)
   m !  0  .LAST \m cell/ for  dup >hilo m& m&  \m cell+  next
   drop  "0dead ;

: dummy                        ( SetRegs  ReadWord  WriteWord)
   chat-via  d.Hello  d.GetRegs     drop     nope   2drop
             d.ReadChunk  d.WriteChunk  d.ErasePage  d.FlashChunk
              ( Run      RunWait)
             chat-fail  chat-fail  ;


.ifdef avr-bogus

( The semantics of moving cells to and from the target stack are a bit
  complicated.

  When the target stack is empty, sp0 = sp, and the top register contains
  garbage.

  When the target stack isn't empty, the distance between sp0 and sp is
  2*depth, but the bottom-most cell is garbage, and top is valid.)

: stack>  ( "push" stack to target)
   depth 0= if  "cafe \m top!  \m sp0 \m sp!  ^  then
   \m top!
   depth 7 min  ( more than that would be silly)
   \m sp0 over 1+ \m cells -  dup \m sp! ( top of D stack)  swap
   ?for  tuck t!  \m cell+  next  then  ( copy each cell as a word to D stack)
   "cafe swap t! ( push bottom) ;

: stack<  ( "pop" stack from target)
   \m depth 0 max 8 min  ( more than that would be silly)  =if
      1- ( depth, excluding top)  =if
         \m sp@ over  ( n sp n)
         for  dup t@  pop 2push  \m cell+  next  ( starting with top, push to R)
         drop ( sp)
         for  2pop push  next  ( pop from R to reverse order)
         0
      then  \m top@  swap
   then  drop ;

( Get target's hardware SP - ie, forth's return stack ptr - and store into
  chat-frame.)

: get-rp   \m rp0  \m cell+ ( skip ret addr)  chat-frame ! ;

: runwait  zgo  get-rp  .regs ;

( XXX Should we try to automatically connect to target?)
: remote  ( cfa)  ( execute target forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  \m pc!  stack>  runwait  stack< ;

: rx  ( cfa)  ( execute target non-forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  \m pc!          runwait ;


( Interacting with a chatty, connected target.)

-:  ."  (interacting with target)"  ;
-:
      .meta. find  if  execute          ^  then  ( labels are in .meta.)
    .target. find  if  execute  remote  ^  then  ( execute as forth word)
   .equates. find  if  execute          ^  then
.ifdef no-number                                 complain ;
.else                                            number ;
.then
mode __target

.then  ( avr-bogus)


( Set |@ and |c@ to _some_ form of target fetch. Prefer to get bytes from
  target if we're connected. This word is useful so we can set an initial
  state for target's  du  and  dis  so that inspect won't crash when it
  runs |@ to get a default ea.)

: >target  chatting @ if  >chat ^  then  >image ;


( Define our own key bindings for memory dumping and disassembly. We'll
  default to host bindings if there isn't one in our array. This way we
  only have to define the "delta" between host and target behaviours.)

128 array msp-seekeys

( Default key action is to run host key code)
host-seekeys msp-seekeys  128 cells cmove

( Dump one line of memory from target program memory.)
: 1dump  ( a)
   hex-bytes
   >image    dup .addr  dup .hex-cells
   chatting @ if
      -valid
      >chat  dup _addr  dup .hex-cells
      -valid
   then
   drop ;

( So we can easily look at the signature embedded into the image.)
: 1dump-chars  ( a)
   hex-bytes
   >target
   dup _addr  dup .chars
   dup .addr  dup .hex-bytes
   dup _addr  dup .hex-cells
   drop ;

msp-seekeys  -1
   2dup  du-mode dumping        >target  skip+  skip-  1dump        ( a - a')
   2dup  du-mode dumping-chars  >target  skip+  skip-  1dump-chars  ( a - a')
         du-mode disasming      >target  dis+   dis-   1dis         ( a - a')

msp-seekeys 'seekeys !  ( switch over to our bindings)

key: d  ( a - a 0)   dumping        0 ;
key: C  ( a - a 0)   dumping-chars  0 ;  ( small c is "call")
key: i  ( a - a 0)   disasming      0 ;

host-seekeys 'seekeys !  ( back to host bindings)


( Interactive)

( make an alias so we can still get to it)
: _du  du ;

: du   ( a - a')   dumping     inspect ;
: dis  ( a - a')   disasming   inspect ;

( Execute ram-resident code.)
: reset   \eq Vreset  image-@  .PC reg!  set-regs  t.Run ;
