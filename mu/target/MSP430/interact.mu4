( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2016 David Frech. (Read the LICENSE for details.)

loading MSP430 interaction

variable chatting

variable chat-vector
: chat-cmd   ( index)  cells  constant
             does> @  chat-vector @ =if  +  @execute  ^  then  2drop
                error" Not connected to a chat-capable target" ;

: chat-fail   error" Chat command not implemented" ;

 0 chat-cmd t.Hello
 1 chat-cmd t.GetRegs      ( buf - sp)
 2 chat-cmd t.SetRegs      ( buf)
 3 chat-cmd t.ReadWord     ( a - w)
 4 chat-cmd t.WriteWord    ( a w)
 5 chat-cmd t.ReadChunk    ( buf a u)  ( XXX order??)
 6 chat-cmd t.WriteChunk   ( buf a u)
 7 chat-cmd t.ErasePage    ( a cmd - status)
 8 chat-cmd t.FlashChunk   ( buf a u cmd - status)
 9 chat-cmd t.Run


: >chat
   ['] t.ReadChunk  is |read    ( read from connected target)
   ['] leh@         is |cell@
                    16 |addr !  ( size of addr in bits)
                     2 |cell !  ( size of cell in bytes) ;

: copy-chunk  ( a u)
   =if
      -- cr  ." copy-chunk "  over u. dup u.
      over image+ -rot  t.WriteChunk  ^
   then  2drop ;

variable ram-copied  ( pointer to first un-copied byte)

: copy-ram
   h preserve  ram
   ram-copied @  dup 0= if  drop  origin  then
   \m here  over -  copy-chunk
   \m here  ram-copied ! ;


( For reading and writing target cells.)
: t@  ( addr - h)  t.ReadWord ;
: t!  ( h addr)    t.WriteWord ;


( The chat firmware has pushed an "exception frame" onto the stack.)

: reg  ( index)  \m cells  constant ;

.ifndef chat-v1

( These are passed to and from chat, via get-regs and set-regs:)
00 reg .CP     -- context pointer
01 reg .SR     -- status register
02 reg .PC
03 reg .LAST

( These are passed to and from target via D stack:)
03 reg .IP
04 reg .LOOP
05 reg .SIZE

.else  ( chat-v1)

00 reg .FCMD     -- flash command
01 reg .IP
02 reg .W
03 reg .RP
04 reg .COUNT
05 reg .TOP
06 reg .X
07 reg .Y
08 reg .SR       -- status register
09 reg .PC
10 reg .LAST
10 reg .SIZE

.then

.SIZE buffer chat-frame  ( local copy of target's stack frame)
    variable chat-sp     ( current value of target's SP)

: get-regs   chat-frame t.GetRegs  chat-sp ! ;
: set-regs   chat-frame t.SetRegs ;

( These index into our local chat-frame, _not_ into target memory!)
: reg@   ( offset - reg)   chat-frame +  leh@ ;
: reg!   ( reg offset)     chat-frame +  leh! ;

: 2sp  space space ;
: .b9  binary  <#  # # # #  # # # #  #  #> type ;
: .h16    hex  <#  # # # #  #> type ;
: .r   ( offset)  reg@  .h16  2sp ;
: .sr       .SR   reg@  .b9   2sp ;

defer .regs

.ifndef chat-v1

-: ( chat v2 version of .regs)
   radix preserve

   cr  ." V----INZC    CP    SP    PC"
       (  000100011  0000  0000  0000 )
   cr           .sr
                   .CP .r
          chat-sp @ .h16 2sp  .PC .r ;  is .regs

.else  ( chat-v1)

-: ( chat v1 version of .regs)
   radix preserve

   cr  ." V----INZC    IP     W    RP   Cnt   Top     X     Y    SP    PC"
       (  000100011  0000  0000  0000  0000  0000  0000  0000  0000  0000)
   cr           .sr
                   .IP .r
                          .W .r
                               .RP .r
                                  .COUNT .r
                                          .TOP .r
                                                  .X .r
                                                        .Y .r
                                               chat-sp @ .h16 2sp  .PC .r ;  is .regs


.then

: hi  chatting on  >chat  t.Hello  get-regs  .regs
      ram-copied off  copy-ram
      now __chatting is __meta  __meta ;

: chat-via   pop  chat-vector !  hi ;


( NOTE: All the following d.Foobar commands are the dummy _implementations_
  of the chat command interface.)

.SIZE buffer dummy-frame

: d.Hello  ." Connecting to dummy chat target."
   ( Init each reg in dummy-frame to its index, then set PC to RAM)
   dummy-frame m !
   0  .LAST \m cell/ for  dup >hilo m& m&  \m cell+  next  drop
   "220 .PC dummy-frame +  leh! ;

: d.ReadWord     ( a - w)
   cr  ." dummy read word "  dup u.
   image-@ ;

: d.WriteWord     ( w a)
   cr  ." dummy write word "  over u.  dup u.
   image-! ;

: d.ReadChunk    ( buf a u)
   -- cr  ." Dummy read chunk "  2 nth u.  over u.  dup u.
   push  image+  2dup xor if  swap pop cmove  ^  then
   rdrop  2drop ;

: d.WriteChunk   ( buf a u)
   -- cr  ." Dummy write chunk "  2 nth u.  over u.  dup u.
   push  image+  2dup xor if       pop cmove  ^  then
   rdrop  2drop ;

: d.ErasePage   ( a fcmd - status)
   -- cr  ." Dummy erase page "  over u.  dup u.
   2drop  "9658 ;

: d.FlashChunk   ( buf a u fcmd - status)
   drop  d.WriteChunk  "9658 ;

: d.GetRegs  ( buf - sp)
   ( copy dummy-frame to buf)
   dummy-frame swap .LAST cmove  "dead ;

: d.SetRegs  ( buf)
   ( copy buf to dummy-frame)
   dummy-frame .LAST cmove ;

: dummy
   chat-via  d.Hello  d.GetRegs  d.SetRegs  d.ReadWord  d.WriteWord
             d.ReadChunk  d.WriteChunk  d.ErasePage  d.FlashChunk
             ( Run) nope ;

: _run      set-regs  t.Run ;  ( don't wait for target)
: _runwait  _run  get-regs ;   ( wait for target)

: runwait   _runwait  .regs ;

: 'reset   \eq Vreset image-@  .PC reg! ;
: go       'reset  _run ;  ( when the code you're calling doesn't speak
                             the same protocol as running code)
: reset    go  0 #100,000,000 nanosleep ( 100ms)  get-regs .regs ;

( For running random bits of code.)
: call  ( pc)  .PC reg!  runwait ;


.ifndef chat-v1

( Because the target "caches" the top of the stack in a register, and
  because the trampoline code loads this register before execution, and
  pushes it afterward, we can deal only with the "memory image" of the target
  stack, rather than also worrying about what to put into the "top" register.

  What's a bit mystifying is that, to achieve a target stack depth of N,
  the host has to push N+1 items. The top one goes into top; and the
  bottom-most one is the "sentinel" value that gets loaded into top when the
  stack becomes empty.

  When pushing from the host, or when "pulling" from the target, we don't
  move more than 8 items.)

meta
: sp0   [ @ram #ram +  #48 - ] ;
: sp!   .CP reg! ;  ( the trampoline code loads SP from CP)
: sp@   .CP reg@ ;  ( the trampoline code stores SP into CP)
: depth   \m sp0  \m sp@ -  \m cell/  1- ;
forth

: stack>  ( "push" stack to target)
   depth 0 max 8 min
   \m sp0  over 1+  \m cells -  dup \m sp! ( top of D stack)  swap
   ?for  tuck t!  \m cell+  next  then  ( copy each cell as a word to D stack)
   "cafe swap t! ( sentinel) ;

( XXX add a way to automagically sign-extend or zero-extend values coming
  from the target stack?)

: stack<  ( "pop" stack from target)
   \m depth 0 max 8 min  =if
      \m sp@ over  ( n sp n)
      for  dup t@  pop 2push  \m cell+  next ( starting with top, push to R)
      drop ( sp)
      for  2pop push  next  ( pop from R to reverse order)
      0
   then  drop ;

( Host should set PC -> continue-forth
                  SP -> top of R stack
                  CP -> top of D stack)

: ?chat
   chatting @ 0= if  error" not connected to target"  then ;

( NOTE: For initial execution of a Forth word, xn is cfa!)
: continue  ( x0 .. xn ip - y0 .. yn ip w count)
   ?chat
   copy-ram  stack>  _runwait  stack<
   .LOOP reg!  .IP reg!  .regs ;

( These are implement'ed by the kernel code.)
meta
variable continue-forth
variable trampoline

: cont    ( )     ( continue forth execution)
   .IP reg@  continue ;
forth

-: ( cfa)  ( execute target forth word)
   p@ continue-forth .PC reg!
   p@ trampoline  continue ;  is remote


.then


( Set |@ and |c@ to _some_ form of target fetch. Prefer to get bytes from
  target if we're connected. This word is useful so we can set an initial
  state for target's  du  and  dis  so that inspect won't crash when it
  runs |@ to get a default ea.)

: >target  chatting @ if  >chat ^  then  >image ;


( Define our own key bindings for memory dumping and disassembly. We'll
  default to host bindings if there isn't one in our array. This way we
  only have to define the "delta" between host and target behaviours.)

128 array msp-seekeys

( Default key action is to run host key code)
host-seekeys msp-seekeys  128 cells cmove

( Dump one line of memory from target program memory.)
: 1dump  ( a)
   hex-bytes
   >image    dup .addr  dup .hex-cells
   chatting @ if
      -valid
      >chat  dup _addr  dup .hex-cells
      -valid
   then
   drop ;

( So we can easily look at the signature embedded into the image.)
: 1dump-chars  ( a)
   hex-bytes
   >target
   dup _addr  dup .chars
   dup .addr  dup .hex-bytes
   dup _addr  dup .hex-cells
   drop ;

msp-seekeys  -1
   2dup  du-mode dumping        >target  skip+  skip-  1dump        ( a - a')
   2dup  du-mode dumping-chars  >target  skip+  skip-  1dump-chars  ( a - a')
         du-mode disasming      >target  dis+   dis-   1dis         ( a - a')

msp-seekeys 'seekeys !  ( switch over to our bindings)

key: d  ( a - a 0)   dumping        0 ;
key: C  ( a - a 0)   dumping-chars  0 ;  ( small c is "call")
key: i  ( a - a 0)   disasming      0 ;

host-seekeys 'seekeys !  ( back to host bindings)


( Interactive)

( Host du available as \f du)
meta
: du   ( a - a')   dumping     inspect ;
: dis  ( a - a')   disasming   inspect ;
forth
