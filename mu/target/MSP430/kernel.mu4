( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2016 David Frech. (Read the LICENSE for details.)

loading MSP430 Forth kernel

( Yes, you guessed it: The guts of Forth for the MSP430! This chip is
  awesomely well-suited to running Forth, and in fact, it will even run an
  ITC - indirect-threaded code - Forth with almost no overhead.

  Since this is the purest and most elegant expression of Forth, it's
  pretty great that it will fit nicely onto the chip. With 16-bit addresses
  and ITC, a ton of code will fit into the MSP430G2553's 16 KiB of flash.)


-- ------------------------------------------------------------------------
-- Macros defining register conventions
-- ------------------------------------------------------------------------

( Lower registers are callee-saved. Higher registers are caller-saved - ie,
  scratch.)

assembler
( 0         pc
  1         sp
  2         sr
  3         r3 )

 4 reg cp     ( cp - context pointer, from chat's perspective)

 4 reg ip     ( ip - forth instruction pointer)
 5 reg rp     ( rp - return stack pointer)
 6 reg top    ( cached top of data stack)

.ifndef loop-on-stack
 7 reg loop   ( current for/next/do/loop index)
.then

12 reg w      ( w - "working" register: holds cfa during next; scratch)
13 reg x      ( scratch x)
14 reg y      ( scratch y)
15 reg z      ( scratch z)
forth

( Tell the disassembler about these register names.)
-: ( reg)
   2* 2*
   z" pc  sp  sr  r3  ip  rp  top loopr8  r9  r10 r11 w   x   y   z   "  +
   (  0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff)
   4 -trailing type ;  is .regname


-- ------------------------------------------------------------------------
-- Macros defining common VM operations
-- ------------------------------------------------------------------------
assembler

( NOTE: I have chosen to use auto-increment to load the code pointer into
  pc. After next, w points to the parameter field rather than the code field.

  This adds one cycle to next - 5 instead of 4 - but simplifies all the
  Forth runtimes - for create, constant, :, etc - and saves an instruction
  and a cycle in each of them. The only execution path that slows down is
  calling native - code - words. I hope it's worth it! I like the simplicity
  and elegance of doing it this way.)

: next     asm{  ip )+ w mov  w )+ pc mov  } ;

: rpush    ( ea)  asm{   2 # rp sub   ( ea)  rp )  mov  } ;
: rpop     ( ea)  asm{       rp )+  \f swap ( ea)  mov  } ;

: nest     asm{  ip rpush  } ;
: unnest   asm{  ip rpop   } ;
forth


-- ------------------------------------------------------------------------
-- The kernel begins here!
-- ------------------------------------------------------------------------
__meta
hex

implements dodoes    nest  ip pop  ( fall thru to dovar/docreate)  ;c

( Note the structural similarities!)
meta: create     name  0 ,   ;code   label wpush
                                     top push  w   top mov  next  ;c
meta: constant   create  ,   ;code   top push  w ) top mov  next  ;c
meta: :          create  ]   ;code   nest      w    ip mov  next  ;c

code*  ^                           unnest         begin     next  ;c
codes nope

( Allocate space _before_ defining the buffer, so we can define them in
  ram as well as in flash!)

meta: buffer   ( #bytes)   'ram @  swap 'ram +!  constant  ;
meta: variable    2 buffer ;

code* (lit)  ip )+ w mov  wpush jmp  ;c

code*    (branch)      ip )   ip mov  next  ;c
code*   (0branch)   top tst  top pop  ' (branch) >body 0!= until  ( fall thru)  ;c
label        skip         2 # ip add  next  ;c
code*  (?0branch)   top tst  skip 0= until  top pop  ' (branch) >body j  ;c
code*  (=0branch)   top tst  skip 0= until           ' (branch) >body j  ;c


.ifndef loop-on-stack

( Fast version, using loop register)
code* (for)   ( u)
   loop rpush  top loop mov  top pop  next  ;c

code* (next)
   1 # loop sub  ' (branch) >body 0= until  loop rpop  skip j  ;c


( Do-loop frame looks like this:

  +------------------+
  |  saved loop reg  |
  +------------------+
  |      limit       |<--- rp
  +------------------+

   Current index is in loop register; current "user-visible" index is
   calculated as index + limit.)

code* (do)   ( limit start)
   4 # rp sub  ( make room on R stack - all in one go)
     loop 2 rp +) mov  ( save loop reg on R)
   x pop  x rp  ) mov  ( save limit to R)
   x top sub  top loop mov  ( index = start - limit)
   top pop  next  ;c

( Increment index. If it overflows to zero, restore loop register, pop
  stack frame, skip backwards jump, and continue. If non-zero, simply take
  the backwards jump.)

code* (loop)
   1 # loop add  ' (branch) >body 0= until
label undo
   2 # rp add  loop rpop  skip j  ;c

( Add incr to index. If the sign of index has changed, we've crossed the
  threshold, so restore index, pop frame, and skip jump. Otherwise, take
  the backwards jump.)

code* (+loop)  ( incr)
   loop x mov  ( save index value)
   top loop add   top pop   loop x xor  undo 0>= until
   ' (branch) >body j  ;c

( Push current loop index. User-visible index = index + limit)
code i   ( - index)
  loop w mov  rp ) w add  wpush jmp  ;c

.else  ( keeping for/next and do/loop index on R stack, not in a register)

( for is just >r. next is 3 cycles slower per iteration than fast next)
code* (next)
   1 # rp ) sub  ' (branch) >body 0= until  2 # rp add  skip j  ;c

( Do-loop frame looks like this:

  +---------+
  |  limit  |
  +---------+
  |  index  |<--- rp
  +---------+

   "User-visible" index is calculated as index + limit.)

code* (do)   ( limit start)
   4 # rp sub  ( make room on R stack - all in one go)
   x pop      x 2 rp +) mov  ( save limit to R)
   x top sub  top rp  ) mov  ( index = start - limit)
   top pop  next  ;c

( Increment index. If it overflows to zero, pop stack frame, skip backwards
  jump, and continue. If non-zero, simply take the backwards jump.)

code* (loop)
   1 # rp ) add  ' (branch) >body 0= until
label undo
   4 # rp add  skip j  ;c

( Add incr to index. If the sign of index has changed, we've crossed the
  threshold, so pop stack frame, skip backwards jump, and continue.
  Otherwise, take the backwards jump.)

code* (+loop)  ( incr)
   rp ) x mov  ( save index value)
   top rp ) add   top pop   rp ) x xor  undo 0>= until
   ' (branch) >body j  ;c

( Push current loop index. User-visible index = index + limit)
code i   ( - index)
  rp ) w mov  2 rp +) w add  wpush jmp  ;c

.then


( Basic unary ops.)
code invert   top inv               next  ;c
code negate   top inv  1 # top add  next  ;c

code 2*      top top add  next  ;c
code 2/          top asr  next  ;c
code u2/   clrc  top ror  next  ;c

( Basic binary ops.)
code +     sp )+ top add  next  ;c

code and   sp )+ top and  next  ;c
code or    sp )+ top bis  next  ;c
code xor   sp )+ top xor  next  ;c

( Stack ops.)
code dup    ( t - t t)  top push  next  ;c
code drop   ( x t - x)  top pop   next  ;c
code nip    ( x t - t)  2 # sp add  next  ;c

code over  ( w t - w t w)      sp ) w mov          wpush jmp  ;c
code swap  ( w t - t w)             w pop          wpush jmp  ;c
code rot   ( w x t - x t w)  x pop  w pop  x push  wpush jmp  ;c

code tuck  (   x t - t x t)  x pop       top push  x push  next  ;c

: 2dup   over over ;
: -rot    rot  rot ;


( Return stack ops.)
.ifdef loop-on-stack  implements (for)  .then
code >r   ( w)    top rpush  top pop   next  ;c
code r>   ( - w)      w rpop  wpush jmp  ;c
code r@   ( - w)  rp ) w mov  wpush jmp  ;c

( Memory access.)
code @   ( a - w)  top ) top mov   next  ;c
code c@  ( a - b)  top ) top movb  next  ;c

code !   ( w a)    sp )+ top ) mov   top pop  next  ;c
code c!  ( b a)    sp )+ top ) movb  top pop  next  ;c

code +!  ( w a)    sp )+ top ) add   top pop  next  ;c


( These are a bit tricky, esp since borrow is ~carry. The idea is: get the
  inverse of the flag value we want into carry, then subtract top from
  itself - yielding zero - minus borrow, or -1 for true, 0 for false. It's
  efficient but non-obvious.)

code 0=                   1 # top sub  ( ~Z -> C)  ( fall thru)  ;c
label makeflag   top top subc  next  ;c

code 0<   8000 # top xor  top top add  ( ~N -> C)  makeflag j  ;c
code u<          x pop  top x cmp  ( ~uless -> C)  makeflag j  ;c

code  <          x pop  top x cmp  clrc  makeflag >= until
                                   setc  makeflag j  ;c

( Putting - here so you can see that it's more like < than +)
code -           x pop  top x sub  x top mov  next  ;c

( Another useful compare operator - equality!)
: =   xor 0= ;

code execute   ( cfa)    top   w mov  begin  top pop  w )+ pc mov  ;c
code @execute  ( 'cfa)   top ) w mov  again  ;c


( Small constants.)
-2 constant -2
-1 constant -1
 0 constant 0
 1 constant 1
 2 constant 2

( Incrementers by small constants. Shared code means they take up very
  little space!)

meta: incr   constant  ;code  w ) top add  next  ;c
 1 incr 1+
 2 incr 2+

-1 incr 1-
-2 incr 2-


ram

( For debugging and interactive execution.)
( Host should have set PC -> continue-forth
                       SP -> top of R stack
                       CP -> top of D stack)

( The host can push things onto host stack; they get copied to target
  stack, registers popped, words execute, re-push, copy back to host...
  Much easier than stuffing things into register slots on stack frame!)

( The chat firmware pushes, at the very top of RAM, the chat entry point
  address.)

code bug
   top push  ( so all of D stack is in memory)
   ip push  ( capture Forth VM context)
.ifdef loop-on-stack
   rp ) push
.else
   loop push
.then
   sp cp mov  rp sp mov  ( D stack -> CP, R stack -> SP)
   @ram #ram + \m cell- & call  ( fall thru)  ;c

implements continue-forth
   sp rp mov  cp sp mov  ( R stack -> RP, D stack -> SP)
   ip pop  ( restore Forth VM context)
   top pop  ( host pushed depth+1 data items onto D stack)
   next  ;c

implements trampoline  ( x0 .. xn cfa - y0 .. ym)
   ( make a fake colon word: no docolon, just a body)
   ]  execute  begin  bug  again  [

__host

( XXX show some indication of whether a word is still executing;
  IP != trampoline + 4)

: executing?   .IP reg@  [ \m trampoline @ 4 + ]  - ;

: .ip
   .IP reg@ .h16
   executing? if  ." * "  ^  then  ( done)  2sp ;

: .loop
   0dead  ( use 0dead unless we are executing)
   executing? if  drop  .LOOP reg@  then  .h16__ ;

-: ( forth version of .regs)
   radix preserve

   cr  ." V----INZC    IP  Loop    SP    RP    PC"
       (  000100011  0000  0000  0000  0000  0000)
   cr           .sr   .ip
                          .loop
                               .CP .r
                         chat-sp @ .h16__  .PC .r ;  is .regs

__meta

comment ~~examples~~
variable inc
: lala  do  i bug drop  inc @ +loop ;

( to demonstrate scripting target execution from the host)
meta: grog  ( start n)  0 do  \t 1+ remote  loop ;
( try: 44 10 grog)

~~examples~~

flash
