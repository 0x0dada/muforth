( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 Forth kernel

( Yes, you guessed it: The guts of Forth for the MSP430! This chip is
  awesomely well-suited to running Forth, and in fact, it will even run an
  ITC - indirect-threaded code - Forth with almost no overhead.

  Since this is the purest and most elegant expression of Forth, it's
  pretty great that it will fit nicely onto the chip. With 16-bit addresses
  and ITC, a ton of code will fit into the MSP430G2553's 16 KiB of flash.)

assembler
comment %%
  NOTE: if we did  w )+ pc mov  next would take 1 cycle more, but docolon
  and friends would be shorter and simpler... %%

: next     asm{  ip )+ w mov  w ) pc mov  } ;

: rpush    ( ea)  asm{   2 # rp sub   ( ea)  rp )  mov  } ;
: rpop     ( ea)  asm{       rp )+  \f swap ( ea)  mov  } ;

: nest     asm{  ip rpush  } ;
: unnest   asm{  ip rpop   } ;
forth

__meta
hex

( Note the structural similarities!)
label dodoes     nest                    ip pop  ( fall thru)  ;c
label dovar      top push  2 # w add  w top mov  next  ;c
label doconst    top push        2 w +) top mov  next  ;c
label docolon    nest      2 # w add   w ip mov  next  ;c

code ^   unnest  next  ;c

code (lit)  top push  ip )+ top mov  next  ;c

code    (branch)      ip )+  ip mov  next  ;c
code   (0branch)   top tst  top pop  ' (branch) >body 0!= until  ( fall thru)  ;c
label       skip         2 # ip add  next  ;c
code  (?0branch)   top tst  skip 0= until  top pop  ' (branch) >body j  ;c

( If we also wanted =0branch, it would look like this:)
-- code  (=0branch)   top tst  skip 0= until           ' (branch) >body j  ;c

( Fast version, using count register)
code (ffor)   ( u)   count rpush  top count mov  top pop  next  ;c
code (fnext)     1 # count sub  ' (branch) >body 0= until  count rpop  skip j  ;c

( Slow version, keeping count on R stack)
( for is just >r. next is 3 cycles slower per iteration then fnext)
code (next)      1 # rp ) sub  ' (branch) >body 0= until  2 # rp add  skip j  ;c


( Do-loop frame looks like this:

  +--------------------+
  |  saved count reg   |
  +--------------------+
  |       limit        |<--- rp
  +--------------------+

   Current index is in count register; current "user-visible" index is
   calculated as count + limit.)

code (do)   ( limit start)  -- implements (do)
   4 # rp sub  ( make room on R stack - all in one go)
    count 2 rp +) mov  ( save count reg on R)
   x pop  x rp  ) mov  ( save limit to R)
   x top sub  top count mov  ( count = start - limit)
   top pop  next  ;c

( Increment count. If it overflows to zero, restore count register, pop
  stack frame, skip backwards jump, and continue. If non-zero, simply take
  the backwards jump.)

code (loop)  -- implements (loop)
   1 # count add  ' (branch) >body 0= until
label undo
   2 # rp add  rp )+ count mov  skip j  ;c

( Add incr to count. If the sign of count has changed, we've crossed the
  threshold, so restore count, pop frame, and skip jump. Otherwise, take
  the backwards jump.)

code (+loop)  ( incr)   -- implements (+loop)
   count x mov  ( save count value)
   top count add   top pop   count x xor  undo 0>= until
   ' (branch) >body j  ;c

( Push current loop index. index = count + limit)
code i   ( - index)
  top push  count top mov  rp ) top add  next  ;c


( Basic unary ops.)
code invert   top inv               next  ;c
code negate   top inv  1 # top add  next  ;c

code 2*      top top add  next  ;c
code 2/          top asr  next  ;c
code u2/   clrc  top ror  next  ;c

( Basic binary ops.)
code +     x pop  x top add             next  ;c
code -     x pop  top x sub  x top mov  next  ;c

code and   x pop  x top and  next  ;c
code or    x pop  x top bis  next  ;c
code xor   x pop  x top xor  next  ;c

( Stack ops.)
code swap   ( x t - t x)   x pop  top push        x top mov  next  ;c
code nip    ( x t - t)                           2 # sp add  next  ;c
code drop   ( x t - x)                              top pop  next  ;c
code over   ( x t - x t x)        top push  2 sp +) top mov  next  ;c

code tuck  (   x t - t x t)  x pop       top push    x push             next  ;c
code rot   ( y x t - x t y)  x pop  y pop  x push  top push  y top mov  next  ;c

( Return stack ops.)
code >r   ( w)    top rpush  top pop   next  ;c
code r>   ( - w)  top push   top rpop  next  ;c
code r@   ( - w)  top push   0 rp +) top mov  next  ;c

( Memory access.)
code @   ( a - w)  top ) top mov   next  ;c
code c@  ( a - b)  top ) top movb  next  ;c

code !   ( w a)    x pop  x top ) mov   top pop  next  ;c
code c!  ( b a)    x pop  x top ) movb  top pop  next  ;c



( These are a bit tricky, esp since borrow is ~carry. The idea is: get the
  inverse of the flag value we want into carry, then subtract top from
  itself - yielding zero - minus borrow, or -1 for true, 0 for false. It's
  efficient but non-obvious.)

code 0=                   1 # top sub  ( ~Z -> C)  ( fall thru)  ;c
label makeflag   top top subc  next  ;c

code 0<   8000 # top xor  top top add  ( ~N -> C)  makeflag j  ;c
code u<          x pop  top x cmp  ( ~uless -> C)  makeflag j  ;c

code  <          x pop  top x cmp  clrc  makeflag >= until
                                   setc  makeflag j  ;c

code execute   ( cfa)    begin  top w mov  top pop  w ) pc mov  ;c
code @execute  ( 'cfa)   top ) top mov  again  ;c


{  h @  }  ram

( For debugging and interactive execution.)
( Host should have set PC -> start-forth
                       IP -> trampoline
                        W -> top of D stack
                       RP -> bottom of R stack)

label start-forth
   sp rpush  w sp mov
   top pop  ( host pushed depth+1 things on stack)
   next  ;c

( Restores SP to its state prev to forth code execution.)
code chat
   top push ( get everything onto the stack)
   sp w mov  ( save for host)
   sp rpop  ret  ;c  ( return to chat!)

label start-forth
   r15 pop ( pc to re-enter chat)  w sp mov
   top pop  ( host pushed depth+1 things on stack)
   next  ;c

( Leaves SP where Forth left it; copies into W.)
code chat
   top push ( get everything onto the stack)
   sp w mov  ( save for host)
   r15 pc mov  ;c  ( return to chat!)

label trampoline
   0 ,  ( word to execute - patched by host)
   ' chat ,  ;c

( XXX a third way is for the host to pull the return-to-chat address from
  PC - or the slot above PC, in the case of the current, doubly-nested chat
  - and paste it as an immed value that gets moved into PC at the end of the
  chat word above.

  And a fifth way, is to put a _vector_ somewhere - fe00, ffe0, ffc0 - that
  points to chat-entry. Then we can forgo all this saving and restoring of a
  valuable return address.)

( XXX Can we enter chat from any arbitrarily-nested bit of Forth code? That
  would be a great debugging aid. Just stick "bug" or "chat" in the middle
  of some code and drop into chat at that point... All the stacks are
  available for perusal, etc. How would that work?

  And if chat uses the _current_ SP - rather than a previously-saved SP -
  chat entries are _nestable_ - ie, re-entrant. Does that even make sense?)


{  h !  }
