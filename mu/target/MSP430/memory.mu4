( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2017 David Frech. (Read the LICENSE for details.)

loading MSP430 memory image

( Space for compiling into. I think MSP430s max out at 128 KiB, but for now
  let's limit ourselves to 64k address space. This is where most of the
  varieties I'm interested in max out.)

( Helpfully, all MSP430s start their RAM at the same place:)
"0200 constant @ram

( Also, AFAIK info memory always starts in the same place.) 
"1000 constant @info

( We are quickly prototyping this using a G2553 device, so default the size
  of ram, flash, and info flash accordingly:)
.ifndef #ram
  512 constant #ram
.then

.ifndef #flash
  16 Ki constant #flash
.then

.ifndef #info
   256 constant #info
.then

"1_0000 #flash - constant @flash

( Represent the entire address space. This way we don't worry about any
  translation issues - like forcing target address fc00 to refer to first
  byte of the image buffer.)

64 Ki constant #image
#image buffer 'image

: wrap   [ #image 1- ] and ;
: +a  ( a1 a2 - sum)  +  wrap ;  ( add and wrap to 16bit address)

: image+  ( target - host)  wrap  'image + ;
: image-  ( host - target)        'image -  wrap ;


( DEBUG: Define show-comma to show code as it's compiled.)
.ifdef show-comma
: .debug-comma  dup  .h8_ ;
.else
: .debug-comma ;
.then

( DEBUG: Define show-! to show writes to image.)
.ifdef show-!
: .debug-c!   cr  ( byte addr)  2dup .hcell_  .h8 ;
: .debug-w!   cr  ( word addr)  2dup .hcell_  .hcell ;
.else
: .debug-c! ;
: .debug-w! ;
.then

: image-c@             image+ c@ ;
: image-c!  .debug-c!  image+ c! ;

( MSP430s are little-endian.)
: image-@  ( a - w)             image+  leh@ ;
: image-!  ( w a)    .debug-w!  image+  leh! ;

-: ( buf a u)  swap image+ -rot  cmove ;
: >image
   [ ]       is |read    ( read from image buffer)
   ['] leh@  is |cell@
             16 |addr !  ( size of addr in bits)
              2 |cell !  ( size of cell in bytes) ;
>image

( Dictionary operators.)
variable h   ( image dictionary pointer pointer)
: image-region   create  ( origin)  dup , ,  does>  h ! ;

( h points to one of:)
@ram   image-region ram     ( image-region sets origin and ptr)
@flash image-region flash
@info  image-region info

( I'm not going to define the following word unless I have to. Elsewhere -
  in several other target compilers - I've called this word "org". But I
  never liked the name. It started life as an assembler "directive" in the
  1960s or 1970s. It wasn't clear what it meant back then, and it is no
  clearer now.)

-- : hence   ( a)  h @ ! ;    ( hence means "from here")

meta
: here  ( - a)  h @ @ ;
: allot ( n)    h @ +! ;

: c,        ( b)                 \m here image-c!  1 \m allot ;
: align,    ( b)   \m here 1 and  if  \m c,  ^  then  drop ;
: ,         ( w)    0 \m align,  \m here image-!   2 \m allot ;

2 constant cell
: cells  2* ;
: cell/  2/ ;
: cell+  \m cell + ;
: cell-  \m cell - ;

forth
( return the origin & number of bytes in current region)
: region   ( - a u)         h @  2@  ( origin ptr)  over - ;
: region!  ( origin ptr)    h @  2! ;  ( set origin and ptr)

( Initialization.)
: wipe   'image  #image  ( erase)   "ff  fill ;


( Create a notion of flash "slots" for firmware, which I tend to program in
  chunks of 512 bytes - not coincidentally the MSP430 flash segment size.

  Use this to init the flash region to this slot. Slot 0 is the bootloader
  - ie, 0fe00. Slot 1 is "200 bytes before that: 0fc00. Etc.)

: fslot  ( num)  1+  "-200 *  [ @flash #flash + ]  +  dup @flash u< if
   error" Too many slots for flash!"  then
   h preserve  flash  ( don't want to change this for our caller)
   dup region! ;


( Erase image memory and default to ram region.)
wipe  ram
