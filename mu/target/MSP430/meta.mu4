( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading MSP430 meta-compiler (main)

( The various token consumers for each mode.)

-:  ."  (assembling)"  ;
-:
    .assembler. find  if  execute  ^  then
      .equates. find  if  execute  ^  then
         .meta. find  if  execute  ^  then  ( labels are in .meta.)
        .forth. find  if  execute  ^  then  ( utility words in .forth.)
                                            number ;
mode __asm

( The meta-interpreter. We're in this mode when we're building the target
  image, and when in between [ and ] when running the target colon
  compiler.)

-:  ."  (meta)"  ;
-:
         .meta. find  if  execute  ^  then  ( labels are in .meta.)
      .equates. find  if  execute  ^  then
        .forth. find  if  execute  ^  then
                                            number ;
mode __meta


-- ------------------------------------------------------------------------
-- Macros defining register convention and stack operations
-- ------------------------------------------------------------------------

assembler
 4 constant ip     ( ip - forth instruction pointer)
 5 constant w      (  w - "working" register: holds cfa during next)
 6 constant rp     ( rp - return stack pointer)
 7 constant count  ( current for/next/do/loop count)
 8 constant top    ( cached top of data stack)
 9 constant x      ( scratch x)
10 constant y      ( scratch y)
forth

( Tell the disassembler about these register names.)
-: ( reg)
   dup #11 u< if  ( special)
      2* 2*
      z" pc  sp  sr  r3  ip  w   rp  cnt top x   y   "  +  4 -trailing type
   ^  then
   ." r"  .udec ;  is .regname

( XXX just to get the rest of this to compile)
: barf   error" Not yet implemented!!" ;
: __target-colon   barf ;
meta
: literal  barf ;
meta-compiler
: ^   barf ;
forth

: unvectored?  ( offset - f)  image-@  "0ffff = ;

meta
: handler  ( vector-offset)  \m here swap  image-!  __asm ;

( Set all unset vectors to point to this vector - usually RESET.)
: default-handler  ( start-vector default-vector)
   \m handler  ( force it, in case it's been set already)
   ( then set all unset handlers to this address)
   \eq Vreset  swap do
      i unvectored? if  i  \m handler  ( set it)  then
   \m cell +loop ;

( Create new target names. A name is a target word which is defined as a
  _constant_ equal to its code field address.)

: name    \m here  current preserve  target constant ;
: code    \m name  \m here  \m cell+  \m ,  __asm ;
: :       \m name  __target-colon ;
: label   \m here  current preserve  meta constant  __asm ;

: -]   __target-colon ;
:  ]   \m literal  \m -] ;  ( XXX smart literal from ARM meta?)

( For forward references)
( XXX copied from AVR - maybe totally bogus)
: forward    \m here  equ ;  ( precede with jmp or call)
: resolve    ( src)  \m here  \a resolve ;

( Use hook to define the hook. This creates a label and compiles a long
  jump. Then resolve using hooks, which patches the jmp to point to here.)

: hook    \m label  asm{  0 # br  }  __meta ;
: hooks   \m here  .meta. chain' execute  \m cell+  image-! ;

: '  .target. chain' execute ;  ( get target word's constant value)
: >body  \m cell+ ;

: __host   \ [ ;  ( return to host forth mode)
: {        \m __host ;  ( useful for bracketing a few  host forth words)

forth
: }    __meta ;  ( return to meta)

assembler
: ;c   __meta ;

meta-compiler
: [   __meta ;
: ;   \mc ^  \mc [ ;  ( return to meta)

compiler
: ;m   \ ^  __meta ;     ( exit macro compilation and return to meta-compiler)

forth


( Alloting RAM space to variables. This does not create true Forth
  variables with executable code!)
( XXX keep?)
meta
: var   ( bytes)
   'ram @  dup equ  +  dup 'ram ! ( allot)
   @ram #ram +  swap u<  if error" No available ram"  then ;

forth

( Make it easy to check if a device register has been defined. If device
  equates move to somewhere other than .target. update this too.)
compiler
: .reg   .target. \ .contains ;
forth
: .reg   \ .reg ;


.ifdef notyet

-- ------------------------------------------------------------------------
-- Signatures - how we built the target image 
-- ------------------------------------------------------------------------

meta
: string,  ( a u)
   \m here image+ swap  ( a image u)  dup \m allot  cmove ;

: cr,  #LF \m c, ;  ( add a newline)
: z,     0 \m c, ;  ( add a zero terminator)

: sig"   char " parse  \m string,  \m cr, ;

forth

( based-on: creates words whose bodies are lists of addresses of words,
  just like colon words.)

here -]  \m cr, ;  ( end each created word with a call to cr, )
: based-on:  create  -]
   does>  [ ] push  ( 'body)  dup push  ( ip)
   body> >name
   \m string,  "   " \m string,
   ( run the rest of the create'd word) ;

meta

( muforth version)
based-on: muforth-commit
   muforth-commit  \m string, ;

( Timestamping with creation date.)
based-on: creation-date
   clock time"  \m string, ;

( Compile the command line into the image, prefixing it with "./muforth".)
based-on: build-command
   " ./muforth " \m string,
   command-line  count  \m string, ;

( Finishing the job.)
: end-sig
   \m z, ( terminate!)
   \m here 1 and if  \m z,  then  ( align!) ;

forth

.then  ( notyet)

.ifdef later-gator

( Forward references for control structure implementation words.)
( These are pointers to target CODE words.)
meta
variable (for)
variable (?for)
variable (next)
variable (do)
variable (loop)
variable (+loop)

forth

( looks up a label or forward-reference variable, and executes it to push
  its value or address)

: lookup  ( look up next token as forward-ref variable or label)
   .meta. chain' execute ( get addr) ;

( Fetch value of variable on stack - a primitive - and compile it if
  defined, and complain if not yet defined.)

: (p,)  ( var)
   @  =if  \m compile,  ^  then  error" primitive not yet defined" ;

compiler

( p, is a helper word that makes writing compiling words easier. It is used
  to compile a target primitive into a target word. But it doesn't do all
  the work at once. p, runs at the compile time of the compiling word. In
  that phase it consumes a token from the input, assumes it is a variable
  for a forward-referenced primitive, and compiles it; then it compiles
  (p,) ( which will do the rest of the work at the -run-time- of the
  compiling word!)

: p,   .meta. \chain  compile (p,) ;  ( XXX \ \m ?)

forth


( Looking up and changing values of target words.)
meta
: '   ( - target-cfa)  .target. chain' ;
: addr   \m '  \m cell+ ;  ( find word, skip cfa, return pfa)
: value  \m addr  \m @ ;   ( find word, skip cfa, read out value)
: is  ( target-cfa)    \m addr  \m ! ;


( Compile a linked name field into the target image.)

( The distinction between last and last-code is a bit subtle. last captures
  the cfa of the last word defined, no matter what kind of word it was.
  last-code captures the cfa of code fields that have a "bl" instruction
  compiled there, and that can be possibly "repointed" by a later ;code or
  does>. Keeping them separate makes me feel better.)

forth

variable last        ( cfa of last word defined)
variable last-code   ( for ;code and does> to fix up)
2variable last-link  ( address of vocab, link to newest word)

meta

meta-compiler
: [']  \m '  \m aliteral ;
meta

.meta. chain' literal  'target-literal !  ( patch colon compiler)
            ' number   'target-number  !  ( ditto - use host's number)

: equ   current preserve  labels  constant ;

: label     \m here  \m equ ;
: code      \m name  \m assemble ;
: new       \m name  \m code, ;  ( for words with code fields)

( implements looks up a forward-reference variable and stores the address
  of the last cfa there.)

: implements  last @  \f lookup  ! ;


( Support for making new defining words.)
forth
( (patch) ( rewrites the bl instruction at cfa to call to 'code.)
: (patch)   ( 'code cfa)  tuck >branch-offset  "eb000000 or ( op)
            swap \m ! ;

: patch   last-code @  (patch) ;

( This word, which is followed inline by a target code address, patches the
  code field of the last last word compiled with a bl to the inline target
  address. It essentially "repoints" previously defined words - defined by
  create, variable, constant, etc - to point to new code. It gets
  -compiled- indirectly by both ;calls and does>.)

: (;code@)   pop @  patch ;


( <;code> is used to switch from compiling -host- code [that will later run
  on the host, and build the target word] to compiling -target- code, that
  will run when words defined by this defining word later execute. In order
  to connect the two worlds, and to be able to patch up code fields to
  point to this newly-defined behaviour, <;code> captures the target's
  "here" value. Remember, we are about to start compiling target code at
  "here".

  <;code> runs at the compile time of a defining word, but it leaves it up
  to its caller - ;calls or does> - to change the interpreter mode.)

: <;code>   compile (;code@)  \m here  , ;


compiler
-- : does>   <;code>  save-lr  \m dodoes @ \a bl  \m -] ( start meta-colon) ;
: ;code   <;code>  \m assemble ( start assembler) ;

assembler
: ;c   __meta ;


-- ------------------------------------------------------------------------
-- Control structures.
-- ------------------------------------------------------------------------

: <test>               asm{  tl th or ( test) } ;
: <zbranch>  ( - src)  asm{  0= not if } ;

meta-compiler
: =if   ( - src)  <test>          <zbranch> ;
: if    ( - src)  <test>  <drop>  <zbranch> ;
: then  ( src)          \a then ;
: else  ( src0 - src1)  \a else ;

: begin   ( - dest)  \m here ;
: =until  ( dest -)  \mc =if  \a <resolve ;
: until   ( dest -)   \mc if  \a <resolve ;
: again   ( dest -)  \a again ;
: =while  ( dest - src dest)  \mc =if  swap ;
: while   ( dest - src dest)   \mc if  swap ;
: repeat  ( src dest -)   \mc again  \mc then ;

( n for .. next         goes n times; 4 billion+ if n=0 )
( n ?for .. next then   goes n times; 0 if n=0 )

meta
: <resolve  ." unimplemented" ;
: >mark  \m <resolve ;

meta-compiler
: for     ( - dest)      p,  (for)            \mc begin ;
: ?for    ( - src dest)  p, (?for)  \m >mark  \mc begin ;
: next    ( dest -)      p, (next)  \m >mark  \m <resolve ;

( do, loop, +loop)
: do      ( - src dest)   p, (do)     \m >mark  \mc begin ;
: loop    ( src dest)     p, (loop)   \m >mark  \m <resolve  \mc then ;
: +loop   ( src dest)     p, (+loop)  \m >mark  \m <resolve  \mc then ;
forth

-- ------------------------------------------------------------------------
-- Switching interpreter modes
-- ------------------------------------------------------------------------

( Making [ and ] work, finally.)
variable saved-state      ( interpreter mode we came from)
variable which-literal    ( the kind of literal to make when ] executes)

meta

: -]   saved-state @  state ! ;  ( return to saved state)
:  ]   \m -]  which-literal @execute ;

forth

: _[   ( 'literal)
        state @  saved-state !    ( so we know how to get back)
        which-literal !           ( so ] knows how to make a literal)
        __meta ;                  ( switch to __meta, not to host forth)

( Now define the different ways of leaving a colon compiler.)

( "Fix" host forth's [ and ; so they return to __meta)
compiler
: [          ['] literal  _[ ;   ( when we return, make a host literal)
: ;    \ ^   __meta ;
: [']  \m '  literal ;

meta-compiler
: [    'target-literal @  _[ ;   ( when we return, make a target literal)
: ^    p, ^  ;   ( compile target's ^ - EXIT)
: ;    \mc ^  __meta ;

forth

.then
