( This file is part of muforth: http://muforth.nimblemachines.com/

  Copyright 2002-2017 David Frech. (Read the LICENSE for details.)

loading RISC-V RV32 disassembler (I subset)

( Compiling the instruction table.

  If a match is found, the cfa following match is executed, and then the
  word that called match is exited. This shortcuts any further tests.

  If no match was found, the following cfa is skipped, and the matching
  continues apace.)

: matched?  ( op mask match - op matched)
   push  over and  pop = ( matched) ;

( mask op and test against match)
: match   ( op mask match - op)
   matched?  pop  swap if       @execute  ^  then  cell+ push ;

( If matched, drop op2 and execute following cfa. Otherwise, skip following
  cfa and leave both op1 and op2 on the stack.)

: submatch   ( op1 op2 mask match - op1 | op1 op2)
   matched?  pop  swap if  nip @execute  ^  then  cell+ push ;

variable instr-pc  ( points to _start_ of current instruction)

( All the op printing words have the stack signature: op - op)

: -trailing  ( a u - a u')  ( strip trailing blanks)
   over + ( end)  begin  1-  dup c@ bl -  until  over -  1+ ;

( General-purpose)   comment %unused%
: sext    ( n width - n')
   1 swap <<  push  dup  r@ 2/ and if  r@ -  then  rdrop ;  %unused%

: sext12  ( n -n')   dup    "800 and if     "-1000 +  then ;
: sext20  ( n -n')   dup "8_0000 and if  "-10_0000 +  then ;

: reg>      ( bits - reg)   31 and ;
( XXX - leave out the reg> mask?)
: rd>       ( op - rd)    7 >>  reg> ;
: rs1>      ( op - rs1)  15 >>  reg> ;
: rs2>      ( op - rs2)  20 >>  reg> ;

: funct3>   ( op - f3)   12 >>    7 and ;
: funct7>   ( op - f7)   25 >> ;

( Again, three of the immediate forms are easy.)
: I-imm>    ( op - op imm)  dup 20 >>  "fff and  sext12 ;
: U-imm>    ( op - op imm)  dup 12 >>            sext20  12 << ;
: S-imm>    ( op - op imm)  dup funct7>  5 <<  over rd>  or  sext12 ;

( And two are hard.)
: SB-imm>   ( op - op imm)
   dup  31 bit@          11 <<   ( imm[12])
   over  7 bit@          10 <<   ( imm[11])  or
   over funct7>  "3f and  4 <<   ( imm[10:5])  or
   over  8 >>    "0f and         ( imm[4:1])  or  sext12  2* ;

: UJ-imm>   ( op - op imm)
   dup  31 bit@          19 <<  ( imm[20])
   over 20 bit@          10 <<  ( imm[11])  or
   over 21 >>  "3ff and         ( imm[10:1])  or
   over 12 >>   "ff and  11 <<  ( imm[19:12])  or  sext20  2* ;

( Standard ways of printing different "types".)
: .udec  radix preserve  decimal  (u.) type ;
: .hex   radix preserve  hex       (.) type ;

: 4#   # # # # ;
: .u32   radix preserve  hex  <# 4#  char _ hold  4# #> type ;

defer .reg
-:  ( reg)   ." x"  .udec ;
: raw-regs  [ ] is .reg ;

-:  ( reg)
   dup 0= if  drop  ." zero"  ^  then
   dup 16 u< if
            z"    ra sp gp tp t0 t1 t2 s0 s1 a0 a1 a2 a3 a4 a5 "
   else
      16 -  z" a6 a7 s2 s3 s4 s5 s6 s7 s8 s9 s10s11t3 t4 t5 t6 "
   then
   swap 3 * + 3 -trailing type ;

: abi-regs  [ ] is .reg ;

abi-regs

: .rd   ( op - op)  dup rd>   .reg  space ;
: .rs1  ( op - op)  dup rs1>  .reg  space ;
: .rs2  ( op - op)  dup rs2>  .reg  space ;

( Show immediates as signed hex values.)
: .imm   .hex ;

: .3reg   .rd  .rs1  .rs2 ;
: .rs1-off  ( op imm - op)   .imm  ." ("  dup rs1> .reg  ." )" ;

: .rel-dest  ( off)   instr-pc @ +  .u32 ;

: .undecoded   ." *undecoded*" ;

: .load
   dup funct3>  4 *  z" lb  lh  lw  ??? lbu lhu ??? ??? "  +
   3 -trailing type space  .rd  I-imm>  .rs1-off ;

( Two "special case" 3-regs. They have slightly odd encodings and are
  matched specially.)
: .sub   ." sub "  .3reg ;
: .sra   ." sra "  .3reg ;

: .op-reg
   dup funct3>  4 *  z" add sll slt sltuxor srl or  and "  +
   4 -trailing type space  .3reg ;

: .muldiv
   dup funct3>  6 *  z" mul   mulh  mulhsumulhu div   divu  rem   remu  "  +
   6 -trailing type space  .3reg ;

: .store
   dup funct3>  2*  z" sbshsw??"  +  2 type space  .rs2  S-imm>  .rs1-off ;

( Shift immediates are special.)
( NOTE: for the 64-bit version of these, the shift amount field is 6 bits
  wide, not 5.)

: .shift-imm   .rd  .rs1  rs2> .imm ;
: .slli   ." slli "  .shift-imm ;
: .srli   ." srli "  .shift-imm ;
: .srai   ." srai "  .shift-imm ;

: .ui   .rd  U-imm> .imm ;
: .auipc   ." auipc "  .ui ;  ( XXX show result of pc+imm?)
: .lui     ." lui "    .ui ;

: .branch
   dup funct3>  4 *  z" beq bne ??? ??? blt bge bltubgeu"  +
   4 -trailing type space  .rs1  .rs2  SB-imm>  .rel-dest ;

: .uj-dest  UJ-imm>  .rel-dest ;
: .jal   dup rd> 0= if
   ." j "         .uj-dest  ^  then
   ." jal "  .rd  .uj-dest ;

: .jr    ." jr "         I-imm> .rs1-off ;
: .jalr  ." jalr "  .rd  I-imm> .rs1-off ;

: .fence    ." fence" ;
: .fence.i  ." fence.i" ;

: .ecall   ." ecall" ;
: .ebreak  ." ebreak" ;

( XXX look these up in a dict chain?)
: .csrreg   dup 20 >>  .hex ;
: .csrop  ( op - op)   dup funct3> 3 and  2*  z" ??rwrsrc" +  2 type ;
: .csr   ." csr"  .csrop         space  .rd  .rs1       .csrreg ;
: .csri  ." csr"  .csrop  ." i"  space  .rd  rs1> .imm  .csrreg ;

binary  ( !!)

: .misc-mem
   dup funct3>
   111  000  submatch .fence
   111  001  submatch .fence.i
   drop
   .undecoded ;

( We need to look at high-order bits of OP instructions to figure out what
  they are. We do that here rather than in the main "shred32" routine.)

: .op  ( op - op)
   dup #12 >>
   1111111_00000_00000_111  0100000_00000_00000_000  submatch .sub
   1111111_00000_00000_111  0100000_00000_00000_101  submatch .sra
   1111111_00000_00000_000  0000000_00000_00000_000  submatch .op-reg
   1111111_00000_00000_000  0000001_00000_00000_000  submatch .muldiv
   drop
   .undecoded ;

( The shift-with-immediate-count instructions have a slightly unusual
  encoding. Let's match and handle those before doing the "normal"
  immediate instructions.)

: .op-imm  ( op - op)
   dup #12 >>
   1111111_00000_00000_111  0000000_00000_00000_001  submatch .slli
   1111111_00000_00000_111  0000000_00000_00000_101  submatch .srli
   1111111_00000_00000_111  0100000_00000_00000_101  submatch .srai
   #7 and  #6 *  z" addi  ????  slti  sltiu xori  ????  ori   andi  "  +
   #5 -trailing type space  .rd  .rs1  I-imm> .imm ;

: .jalr-jr
   dup #7 >>
   111_11111  000_00000  submatch .jr
   111_00000  000_00000  submatch .jalr
   drop
   .undecoded ;

: .system
   dup #7 >>
   1_00000_111_00000  0_00000_000_00000  submatch .ecall
   1_00000_111_00000  1_00000_000_00000  submatch .ebreak

     00000_100_00000    00000_000_00000  submatch .csr
     00000_100_00000    00000_100_00000  submatch .csri
   drop
   .undecoded ;

: shred16  ( op - op)
   .undecoded ;

: shred32  ( op - op)
   11_111_11  00_000_11  match .load
   11_111_11  00_011_11  match .misc-mem
   11_111_11  00_100_11  match .op-imm
   11_111_11  00_101_11  match .auipc

   11_111_11  01_000_11  match .store
   11_111_11  01_100_11  match .op
   11_111_11  01_101_11  match .lui

   11_111_11  11_000_11  match .branch
   11_111_11  11_001_11  match .jalr-jr
   11_111_11  11_011_11  match .jal
   11_111_11  11_100_11  match .system

   .undecoded ;

decimal

( Support for interactive disassembly.)
: dis+  ( a - a' 0)  drop  p @  0 advance  0 ;
: dis-  ( a - a' 0)            -4 advance  0 ;

: op16?  ( op - f)   3 and 3 u< ;
: op*    ( - op16)   c* c* lohi> ;

: .op16  radix preserve hex  <#    4# #> type space ;
: .op32  radix preserve hex  <# 4# 4# #> type space ;

( Fetch an instruction, 16 bits at a time. If low bits of first 16-bit
  "packet" are 00, 01, or 10, this is a 16-bit compressed instruction, so
  return it. Otherwise, fetch another packet and concatenate the two.

  NOTE: While there is space in the RISC-V encoding for 64-bit and 128-bit
  *encodings*, we ignore them for now, and assume that every instruction we
  will see will consist of either one or two 16-bit packets.)

( The workhorse.)
: 1dis  ( a)
   dup  ea !  ( default ea: stay put)
   dup .addr  .nesting space  dup  p !  instr-pc !
   op* ( low16)  dup op16? if
                  4 spaces  dup .op16 space  shred16  else
      op* ( hi16) 16 <<  +  dup .op32 space  shred32  then
   drop  space ;
