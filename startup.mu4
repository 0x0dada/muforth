new :  <:> -]   new <:> -]  ^ [

: definitions  current !  ^ [
: forth        .forth. definitions  ^ [
: compiler  .compiler. definitions  ^ [

: aliteral  (alit) (alit)  a,  a,  ^ [
: literal   (alit)  (lit)  a,  ,   ^ [

: ]   literal -]  ^ [

compiler
: ;   [  token ^    .forth. find huh?  aliteral  -]  a,
      [  token [ .compiler. find huh?        a,  -]  ^ [
forth

: char   token  drop  c@ ;
: (    [ char ) ]  parse  2drop ;

( Phew! now we can have comments!)

( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( This file is muforth/startup.mu4. It contains high-level Forth code
  necessary to the useful execution of Forth. This file is loaded and
  interpreted when Forth starts up.

  The idea is to move as much code as possible -out- of the Forth kernel.
  Hence the name: "mu" is the Greek letter often used in engineering to
  represent "micro".

  This file exemplifies a Forth strength - shared by Lisp and Smalltalk,
  among other interpretive/compiled languages - that I like to call
  "writing the reader"; the reader being, in this case, the Forth
  interpreter/compiler.

  As defined in the kernel, the interpreter/compiler is very simple; it
  only knows how to do the following things:

  1. create a new colon word, making a dictionary entry for it;

  2. compile a "call" to an already-defined word [Forth lingo for
     "named piece of code"], by appending its execution address to the end
     of the colon word we are compiling.

  That's it!

  In this file, in Forth, we need to extend the interpreter/compiler to do
  the following:

  1. compile control structures: if/then, for/next, begin/while/repeat;

  2. compile data structures: variables, constants, create/does words;

  3. read and write numbers - an interesting exercise since muforth starts
     life not even knowing the constants 0 or 1;

  4. read and write strings.

  Once these are complete we will have a useful Forth for doing real work.

  The order of business will sometimes seem haphazard; words can only be
  defined after the words they depend on have been defined, so we end up
  jumping around a bit in the "semantics" of the language.

  Hopefully the reader will find this an interesting exercise in
  bootstrapping, which was precisely my intention.

  So, here goes; now we start extending the language, bit by bit.)


( !! NOTE !! Do -NOT- change this part of the file without thinking VERY
  hard first. Make changes below the line marked `Add changes below this
  line', otherwise it may be difficult to diagnose problems added by new
  code.)


( Stack manipulations.)
: rot    >r swap  r> swap ;  ( a b c - b c a)  ( fig!)
: -rot   swap >r  swap r> ;  ( a b c - c a b)
: tuck   swap over ;           ( a b - b a b)

( First, we need compiler versions of ( and char. Since we no longer hide
  words as they are being defined, we need to be careful about how we do
  this. So let's define some words that are useful for searching specific
  dictionary chains and compiling words from them.)

( Roll tokenizing and searching into one.)
: token'   token  rot  find ;   ( chain - a u F | body T)

( Compiling from specific chains. Note that `\' is an elaboration of the
  basic scheme of `\chain'. These words will be handy in the assembler
  and target compiler.)

( Tick)
: chain'  token'  huh?  ;
: \chain  chain'  a,  ;

( 28-apr-2000. Do we ever -really- want to search anything other than .forth.?)
: '   .forth.  chain'  ;
( : '   current @  chain'  ;  ( XXX)

compiler
( XXX: should this and ' do the same thing?)
( : [']  .forth. chain' aliteral ;)
: [']  ' aliteral ;

( XXX: is this useful? Here? Maybe in a target compiler...)
: \f     .forth. \chain ;
: \c  .compiler. \chain ;  ( until we have \ ; we need this for "if")

( Ok, now we can define our compiler comment char, ( .)
: (    \f ( ;
forth


( Some useful tidbits.)
: -   negate + ;
: u+  ( a b c - a+c b)  rot +  swap ;  ( "under-plus")
: v+  ( x1 y1 x2 y2 - x1+x2 y1+y2)  push u+ pop + ;  ( add 2-vectors)

( We don't even have any constants yet! So we make the easiest one first...)
: 0   [ dup dup xor ] ;
: -1  [ 0 invert ] ;
: 1   [ -1 negate ] ;
: 2   [ 1 2* ] ;
: 3   [ 1 2*  1 + ] ;

: 1+   1 + ;  ( these are common)
: 1-  -1 + ;

( Cells store data values. Default is now 64 bits.)
: cells  3 << ;  ( cell is 64 bits!)
: cell/  3 >> ;  ( signed)
: cell   [ 1 cells ] ;
: cell+  [ cell ] + ;
: cell-  [ cell negate ] + ;

( Addrs store addresses. These are architecture-specific.)
: addrs  ADDR-SHIFT << ;
: addr/  ADDR-SHIFT >> ;  ( signed)
: addr   [ 1 addrs ] ;
: addr+  [ addr ] + ;
: addr-  [ addr negate ] + ;

: bl  [ 2 2* 2* 2* 2* ] ;  ( space character)

: @+  ( a - n a+)  dup @  swap cell+ ;
: !+  ( n a - a+)  tuck !  cell+ ;

: a@+  ( a - n a+)  dup a@  swap addr+ ;
: a!+  ( n a - a+)  tuck a!  addr+ ;

( Double-length words.)
: 2@  @+ @  swap ;  ( cell at lower address to TOP)
: 2!  !+ ! ;

: 2dup  over over ;
: 2swap  rot push  rot pop ;
: 2push  ( a b -> R: a b)  pop -rot  swap push push  push ;
: 2pop   ( R: a b -> a b)  pop       pop pop swap    rot push ;

: =    xor 0= ;
: not      0= ;  ( warning! this is NOT 1's complement)
: bic  invert and ;
: @execute  @ execute ;

( jump allows jumping thru a table of addresses; you are responsible for
  making sure the index is within range! It must be used at the end of a
  word. Common usage looks like this:  jump  nope  do1  do2  do3  [

  That example assumes the top of stack has a number from 0 to 3.

  Since no UNNEST needs to be compiled, use of [ rather than ; to end the
  word is common.)

: jump  ( which)  addrs pop + a@ execute ;

: ctrl   char  [ bl 2* ( 64) ]  xor ;  ( how you get ^? = 127.)
compiler
: char   \f char aliteral ;  ( aliteral is more compact)
: ctrl   \f ctrl aliteral ;
forth

( A nice way to do full-line comments with no trailing delimiter.)
: --  ctrl J parse  2drop ;  ( throw away until a newline)
compiler
: --  \f -- ;
forth

( Before I figured out the trick above, which yields the correct answer for
  ctrl ?, I defined ctrl thus:)
-- : ctrl   char  [ bl 1- ( 31) ]  and ;  ( elliptical, but it works :-)


( Mark a branch source for later fixup.)
: >mark  ( - src)  here  0 a, ;

( Resolve a forward or backward jump, from src to dest.)
( When using absolute branch addresses, this is easy: just store dest at src.)
: <resolve  ( dest src)  a! ;
: >resolve  ( src dest)  swap <resolve ;

( Going back to fig-FORTH!)
: compile   pop a@+ push  a, ;

compiler
: =if   ( - src)        compile (=0branch)  >mark ;
: if    ( - src)        compile  (0branch)  >mark ;
: then  ( src)          here >resolve ;
: else  ( src0 - src1)  compile   (branch)  >mark  swap  \c then ;

: begin   ( - dest)  here ;
: =until  ( dest -)       \c =if  <resolve ;
: until   ( dest -)        \c if  <resolve ;
: again   ( dest -)     compile   (branch)  >mark  <resolve ;
: =while  ( dest - src dest)  \c =if  swap ;
: while   ( dest - src dest)   \c if  swap ;
: repeat  ( src dest -)   \c again  \c then ;

( n for .. next         goes n times; 2^wordsize if n=0 )
( n ?for .. next then   goes n times; 0 if n=0 )

: for     ( - dest)      compile push           \c begin ;
: ?for    ( - src dest)  compile (?for)  >mark  \c begin ;
: next    ( dest -)      compile (next)  >mark  <resolve ;

( do, loop, +loop)
: do      ( - src dest)   compile (do)     >mark  \c begin ;
: loop    ( src dest -)   compile (loop)   >mark  <resolve  \c then ;
: +loop   ( src dest -)   compile (+loop)  >mark  <resolve  \c then ;

( make \ more like ANS-Forth's POSTPONE)
( Now, the confusion happens because we need to write code _in this word_
  that will compile the above code into _other_ words. How about that?)

( Read a token out of the input stream. If the token is on the compiler
  chain, postpone its execution until the word we're compiling executes. If
  the token is on the forth chain, postpone its compilation until the word
  that we're compiling executes. Got that? ;-)

: \   .compiler. token'  if a, ^ then
         .forth. find  huh?  aliteral  ['] a,  a, ;

forth


( Defining words are next. Right now we only `know' how to make `colon'
  definitions. We need some structural help first.)

( I wanted to gain a little of the clarity that Chuck Moore's colorForth
  gains by getting rid of "[ <calculate something here> ] literal". He
  replaces the whole construct with colored words that are executed or
  compiled depending on their color, but with a little added twist: when
  switching from executed to compiled words -- yellow to green --
  colorForth assumes that the yellow words calculated a literal; just
  before starting to compile the first green word after the transition,
  colorForth compiles a literal.

  Even though we don't have color in muFORTH, we can make things a bit
  cleaner by assuming -- unlike traditional Forth -- that between  [  and
  ]  we will calculate a literal.

  How does it work? Simple.  ]  _always_ compiles a literal before
  restarting the colon compiler. To restart it _without_ compiling a
  literal, use  -]  .)


( "nameless" colon words.)
: -:  here <:> -] ;

( For comparison, the regular : compiler is defined thus:
:  :   new <:> -] ; )

 
( Dictionary structure words. Remember that link fields point to the last
  cell - suffix - of a name, which precedes the link field. Roughly, a
  dictionary entry is the following cell-sized things: suffix, link, code;
  where suffix is the last 3 characters of the name, followed by its
  byte-sized length.)

: link>name    ( 'link - a u)  1- dup  c@  tuck -  swap ;
: suffix>link  ( 'suffix - 'link)  addr+ ;

( These words all assume we're calculating to or from a code field
  address.)

: >link   ( 'code - 'link)  addr- ;
: link>   ( 'link - 'code)  addr+ ;
: >name   ( 'code - a u)   >link  link>name  ;
: >ip     ( 'code - 'does-ip)  addr+ ;  ( addr containing does> ip pointer)
: ip>     ( 'does-ip - 'code)  addr- ;  ( addr containing does> ip pointer)
: >body   ( 'code - 'body)  >ip  addr+ ;
: body>   ( 'body - 'code)       addr- ip> ;


( create and does>. Everything old is new again. ;-)

( 2010-nov-30. After many iterations, I have finally arrived at fig-forth's
  implementation of create/does>.  The only difference is the names of the
  words.)

( In fig, there are xx kinds of words:
    * CODE words, whose code field points to machine code
    * COLON words, whose code field points to docolon, and whose bodies
      contain a list of execution tokens
    * CONSTANTS, whose code field points to doconst, and whose body
      contains a value
    * VARIABLES, whose code field points to dovar, and whose body contains
      a value
    * DOES words, whose code field points to dodoes, and whose body
      contains an IP pointer, followed optionally by data.

  In muforth there are only three kinds of words:
    * CODE words - primitives defined in C whose code field points to the C
      code implementation
    * COLON words, whose code field points to docolon; body contains a list
      of execution tokens
    * DOES words, whose code field points to dodoes; body starts with IP
      pointer - to parent's Forth code - followed optionally by data.

  fig and muforth share this inefficient but simple implementation. In the
  case of fig, it was because they didn't know any better. In my case, I
  knew better but in the interest of avoiding machine-code dependencies -
  the efficient way of compiling does> words essentially being a form of
  DTC [direct-threaded code] - I had no choice.

  If you want a threaded-code implementation using only pure pointers, you
  need two pointers in each "child" word defined with create/does: one to
  point to C [dodoes] and one to point to Forth [the body of the parent
  defining word].)


( last contains the address of the does ip of the last <does> word defined)
: sleazy-variable  pop ;  ( push address of following cell in caller!)
: last  sleazy-variable  [  0 ,  ( make the variable by hand!)

( does> fixes up the does ip of the last <does> word to point to the code
  after "does>" in the caller.)

: does>  pop  last @  a! ;


( The underlying engine for all "create/does>" words. It allocates no data
  space in the word. This version does not consume a token from the input
  stream, instead expecting one on the stack. This is particularly useful
  if we are meta-compiling another Forth and want to compile heads into the
  image, since we have to process the token - the name of the new word -
  twice.)

: (create)   ( a u)
   (new) <does>
   here last !  0 a, ( placeholder for does ip)
   does> ;

( Everything is defined in terms of `create'.)
: create   token (create) ;

: constant  ( con)  create , ( compile the constant)  does> @ ;

( An array with every cell set to a default value.)
: defarray   ( default cells)  create  ?for dup , next then  drop ;
: array      ( cells)  0 swap  defarray ;

( A byte array; length is rounded up to cell boundary.)
: buffer   ( bytes)  aligned  ( round up)  cell/  array ;

( A self-indexing array with every cell set to a default value.)
: defarray+  ( default cells)  defarray  does>  ( i - a)  swap cells + ;
: array+     ( cells)  0 swap  defarray+ ;

: variable    create  0 , ;
: 2variable   variable  0 , ;


( To bracket comments in a flexible way. If you've bracketed some text
  using comment, changing "comment" to "uncomment" will interpret the
  bracketed text - the delimiter becomes a noop.)

: (comment)  ( a u)
   begin  2dup token  =while  string= until  2drop ^ then
          2drop 2drop 2drop ;
: comment  token  (comment) ;
: uncomment  new <:> \ ^ ;  ( create a noop word)


( How about a really cool word that makes self-parsing comment words? In
  other words, like using "comment" - defined above - but instead of having
  to say "comment **foobar** <commented text> **foobar**", you define
  **foobar** to skip tokens until it comes to a matching **foobar**!!)

comment no-self-comments
: make-comment  create  does>  body> >name  (comment) ;

( Here is one to get you started - good for block comments. It's 75
  characters long:)

make-comment
===========================================================================
no-self-comments

( I guess we can have deferred words, even though they are, in some ways,
  inelegant. The alternative - creating a variable and a colon word that
  calls through that variable, for _every_ deferred word - is also in some
  ways inelegant - and clumsy.

  Actually, the way we define this is exactly equivalent to what we would
  have to do with variables; the difference is that instead of two named
  objects - the variable and the colon word that calls thru it - we have
  one - the deferred word - and we need an extra mechanism to get to its
  value to change it.

  The main argument _against_ deferred words is that they aren't orthogonal
  w.r.t. _user_ variables. The way we are defining them here they are
  implemented using a global, system variable. On muforth, we don't care,
  because we don't _have_ user variables; but on a properly multithreaded
  target machine things are different. There we probably wouldn't implement
  deferred words at all, using instead the "<variable> @execute" idiom; or,
  indeed, we could have all deferred use _user_ variables instead of
  globals. But that's what the fuss is.

  That and that "vectoring" them isn't strictly postfix. And it requires
  architecture-specific code!)

variable undeferred  ' nope undeferred !
: defer  create  undeferred @ ,  does> @execute ;

( Syntactic sugar - from Rod Crawford's 4ARM.)
: now   '  ;
: is    ' >body !  ;   ( as in `now host-interpret is interpret')

compiler
: now  '        aliteral ;
: is   ' >body  aliteral  \ ! ;
forth


( Trying out, after all these years, the techniques that Klaus Schleisiek
  presented in 1984 [at FORML] and that I read about in 1993.

  The basic idea is that, in addition to return address pointers [saved
  IPs], there are stack frames on the return stack. These can be for any
  purpose, but we're interested here the following: local variable storage,
  "fluid" rebinding of variables - aka dynamic scoping, and
  cleanup-on-return - eg, to close a file that we opened.)

( Here is a picture of the return stack, with high memory towards the top of
  the page, and low memory further down:

  ^   |                    |
  |   +--------------------+
  |   |  prev return addr  |
  |   +--------------------+
  |   |        ...         |   several cells could be here; depends on the
  |   +--------------------+   type of frame
  |   |        ...         |
  |   +--------------------+
  |   |   cfa of cleanup   |
  |   +--------------------+
  +---+     prev frame     |<--- fp
      +--------------------+
      |    ip of remove    |<--- rp      remove just calls unlink
      +--------------------+                                          )

variable fp    ( the "top" - most recently pushed - frame)
               ( fp points to a frame ptr, which pts to a frame ptr...)

( link creates a new frame. It fetches the cfa of the following word and
  pushes it onto the return stack. This is the cleanup routine. Then it
  links this frame into the list rooted at fp, and then returns to its
  caller, skipping the following cfa. link is called by a word that builds
  a new stack frame.)

: link     r> dup a@  >r        ( fetch following cfa & push to r)
           fp @ >r  rp@ fp !    ( link this frame to previous)
           addr+ >r             ( skip fetched cfa) ;

( unlink undoes what link did. It unlinks the frame from the list rooted at
  fp, and then runs the cleanup routine, which will do whatever is
  necessary to de-allocate the frame and undo any state changes made by the
  word that called link.)

: unlink   r>  ( save return address)
           fp @ rp!  r> fp !    ( unlink frame)
           r> execute           ( execute cleanup word)
           >r  ( restore return address) ;

( unwind is useful in the context of exceptions. It starts at fp and
  unlinks each frame in turn until fp points to a frame with a zero link.)

: unwind   r>  ( save return address)
           -- begin  fp @ @  while  unlink  repeat
           begin  fp @  while  unlink  repeat
           >r  ( restore return address) ;


create remove  -]  unlink ;   ( remove pushes IP when executed!)


( Now some interesting applications.)

-- -----------------------------------------------------------------------
-- Fluid binding (dynamically-scoped variables)
-- -----------------------------------------------------------------------
( Restore saved value of a variable.)
: restore
   r> ( ra)   r> r>  ( value addr) !   >r ( ra) ;

( Preserve the value of a variable for the duration of the execution of the
  calling word.)

: preserve  ( addr)  ( address of variable)
   r> ( ra)
   over ( addr) >r  swap @  ( value)  >r
   link restore ( push cleanup)
   remove >r    ( normal return - unlink and cleanup)
   >r ( ra) ;

( And for address-sized variables...)

( Restore saved value of a variable.)
: arestore
   r> ( ra)   r> r>  ( value addr) a!   >r ( ra) ;

( Preserve the value of a variable for the duration of the execution of the
  calling word.)

: apreserve  ( addr)  ( address of variable)
   r> ( ra)
   over ( addr) >r  swap a@  ( value)  >r
   link arestore ( push cleanup)
   remove >r    ( normal return - unlink and cleanup)
   >r ( ra) ;


-- -----------------------------------------------------------------------
-- Cleanup on return
-- -----------------------------------------------------------------------
: cleanup
   r> ( ra)   r> ( value)  r>  ( cfa) execute   >r ( ra) ;

( Push value and following cfa to R stack; on exit or unwind, execute cfa
  with value on the stack.)

: on-exit  ( value)
   r> ( ra)
   dup a@  >r      ( fetch following cfa & push to r)
   swap >r         ( push value)
   link cleanup    ( push code to undo whatever needs undoing)
   remove >r       ( normal return - unlink and cleanup)
   addr+ >r ( ra)  ( skip fetched cfa) ;


-- -----------------------------------------------------------------------
-- Local variable frames
-- -----------------------------------------------------------------------
( Deallocate local variables.)
: unroom
   r> ( ra)
   r> ( #cells)  rp+!  ( rp+! takes cell count!)
   >r ( ra) ;

( Allocate space for local variables.)
( NOTE: do -not- try to use a for loop to push cells! It doesn't work! The
  return stack is being used to store the loop index, but you're busy
  pushing stuff there! All hell breaks loose! If you absolutely want to
  zero locals as they are allocated, do a begin/until loop with the count
  on the data stack.)

: room  ( #cells)
   r> ( ra)

   ( choose one! mark, zero, allocate)
   -- swap dup  begin  "55aa55aa >r  1-  dup 0= until  drop  ( mark)
   -- swap dup  begin          0 >r  1-  dup 0= until  drop  ( zero)
   swap dup  negate rp+!  ( allocate)

   ( #cells)  >r
   link unroom
   remove >r  ( normal return - unlink and cleanup)
   >r ( ra) ;


-- -----------------------------------------------------------------------
-- End of fancy R-stack goodies, and back to pedestrian Forth.
-- -----------------------------------------------------------------------

( Number input)
variable dpl    ( location of , or . )
variable radix

: radixer  constant  does> @  radix ! ;

2 2* 2* dup 2* ( 16!)  radixer hex
dup            (  8!)  radixer octal
2 +            ( 10!)  radixer decimal
2                      radixer binary

decimal
( On and off)
: on  -1 swap !  ;
: off  0 swap !  ;

( Punctuation in numbers: sign, radix, decimal point, separators.)

( 2006-mar-26. Ok, so this *totally* sucks. The presence of these bits of
  punctuation can mask a word not being found in the dictionary. A bare /,
  for instance, with no digits to keep it company, is happily parsed as a
  number. The number? 0. Urgh.)

: punct  ( a1 u1 ch - a2 u2 matched)
   over if ( still chars to process)  swap push  over c@  xor if
   ( no match)  pop 0 ^ then
   ( match)  pop 1 -1 v+  -1 ^  then
   ( end of input)  drop 0 ;

: ?sign  ( a1 u1 - a2 u2 neg) char - punct  if  -1 ^  then  0 ;

( I wanted to add Michael Pruemm's '0' as a hex specifier, but it's not as
  simple as adding it to this list. It will match a bare 0, which won't be
  matched as a number.)

: ?radix  ( a1 u1 - a2 u2)
(   char 0 punct  if  hex ^  then )
   char " punct  if  hex ^  then
   char # punct  if  decimal ^  then
   char ' punct  if  octal ^  then
   char % punct  if  binary ^  then ;

( . resets dpl; others leave it unchanged; this means that embedding . in a
  number causes a double number to be pushed, and dpl set to the count of
  digits _after_ the _last_ . in the number.)
: ?dot  ( a1 u1 - a2 u2)
   char . punct  if  dpl off ^  then
   char , punct  if   ^  then
   char - punct  if   ^  then
   char / punct  if   ^  then
   char : punct  if   ^  then
   char _ punct  if   ^  then   drop complain ;

( This is scary.  We need a bunch of literals for `digit?'.)

: digit?    ( ch - digit T | junk F)
   char 0 -  [ 2 2* 2* 1+ ]  ( 9)   over u< if  ( !decimal)
          [ 2 2* 2* 2* 1+ ]  ( 17)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, UPPERCASE)
          [ 2 2* 2* 2* 2* ]  ( 32)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, lowercase)
      ( junk)  0 ^
   then  then  ( hex) [ 2 2* 1+ 2* ]  ( 10) +  then  ( decimal)
   dup radix @  u<  ;

: @digit?   ( a - a digit T | a junk F)   dup c@  digit?  ;

: *digit  ( u a digit - u*base+digit a)
   swap push ( a)  swap ( dig u)  radix @ * +  pop  dpl @ 0< 1+  dpl +!  ;

( 2002-mar-23. I still don't like how number parsing works. On the one
  hand, we know ahead of time exactly how many characters we have [in the
  token we are trying to convert]; on the other, the way the prefix [sign
  and radix] and embedded [. , - : /] characters work, we can't simply put
  them in a loop: there should be at most one sign and one radix at the
  beginning. Right now I have >number [which converts digits] and punct
  words _both_ checking if there are any characters left to process. This
  seems clumsy.

  And that "dpl!" in ?dot bugs me, too.)

( ANS compatible! - or at least it was when it converting with double numbers.)
: >number  ( u1 a1 c1 - u2 a2 c2)  ( a2 is first unconvertible char)
   =if  for  @digit?  while  *digit 1+ next  0 ^  then   drop  pop  then  ;

( If >number can't convert any digits, complain.)
: digits   ( u1 a1 c1 - u2 a2 c2 u3)
   dup push ( chars left)  >number  pop over - ( count of digits converted)
   0= if  drop complain  then ;

( XXX 2009-sep-01. The following doesn't make sense, and it's a lie as
  well, since 'number,' doesn't exist any more:
 
  Now some help for the colon compiler. Note that the colon compiler now
  calls `number,' to convert-and-compile and calls `number' when interpreting.
  This is so that `number,' or `number' can reset dpl when they're done. We do
  this so that constants don't screw up fixed-point arithmetic conversion.
  Without this code, if you were to use a fixed-point number, 3.1415 eg, dpl
  would be set to 4. Then `0' pushes 0 on the stack but doesn't affect dpl,
  so Forth tries to convert it, and BOOM.)

: number  ( a u - n)
   radix preserve ( always reset the radix, even in case of error)
   2push  0  2pop  ?sign push  ?radix  dpl on
   begin  digits  =while ( still chars)  ?dot  repeat
   2drop  pop  if negate then  ;


( Ok, folks, now that we have number parsing code we can redefine the
  interpreter and compiler, which up till this point have simply complained
  if they saw something not in the dictionary.)

( Let's define a word to create new modes. This is mostly useful for
  meta-compilers.)

: mode   create  ( prompt token-consumer)  a,  a,  does>  state a! ;


( To set the compiler consumer, we need a sneaky word to get the value of
  state while compiling - we use the same trick later to set the compiler
  prompt.)

compiler
: 'compiler-mode  state a@ ;
forth

( Redefine, and then set the forth "consume".)
-:   ( interpret one token)
      .forth. find  if  execute ^  then  number ;     state a@  a!

( Now set the compiler "consumer". To get access to the value of state at
  compile time, we turn on the compiler, but don't compile anything!)

-:   ( compile one token)
   .compiler. find  if  execute ^  then
      .forth. find  if  a,      ^  then  number literal ;
                                      -]  'compiler-mode [  a!


( Basic character i/o.)

variable fd-in
variable fd-out
: writes  fd-out ! ;
: reads   fd-in  ! ;
: <stdin   0 reads  ;
: >stdout  1 writes ;
: >stderr  2 writes ;  <stdin  >stderr  ( sanity)

: type   ( a u)  fd-out @  -rot  write ;

variable charbuf  ( for >emit and <key)
: >emit  ( ch fd)  swap charbuf c!  charbuf 1 write ;
: emit   ( ch)  fd-out @  >emit ;

ctrl J  constant #LF   --  10
ctrl M  constant #CR   --  13
: space      bl emit ;
: cr        #LF emit ;  ( emit newline; assumes OPOST)


: >     swap <  ;
: min   2dup >  if swap then  drop  ;
: max   2dup <  if swap then  drop  ;


( Pictured numeric output.)
: /digit   ( u - uquot umod)  radix @  u/mod swap ;

: >digit   ( n - ch)  ( convert 1 binary digit to char; hex to uppercase)
   9 over u<  7 and +  char 0 +  ;

: abs   ( n - |n|)   dup 0<  if  negate then ;

: spaces  ( n)  0 max  ?for  space  next  then  ;

( pad is where we convert numbers to ASCII. A number is 1 cell - could be
  64 bits! - and in binary would take 64 characters to represent, plus a
  character for the sign. pad returns the address of the _end_ of the
  buffer, since conversion occurs right-to-left.)

65 allot  here constant pad   ( 64 digits + sign + alignment)

variable hld
: hold   -1 hld +!  hld @ c! ;
: <#     pad hld !  ;
: #>     ( u - a #)  drop  hld @  pad over - ;
: sign   ( n -)   0< if  char - hold  then  ;

: #     ( u - u')   /digit  >digit  hold  ;
: #s    ( u - 0)  begin  #  dup 0=  until  ;

: (u.)    ( u - a #)   <# #s #> ;
: u.      ( u -)       (u.)  type  space  ;

: (.)     ( n - a #)   dup push ( sign)  abs  <# #s  pop sign  #> ;
: .       ( n -)       (.)  type  space ;

( This should truncate to field length. Actually, it shouldn't. Does it?)
: truncating-field   ( a c field - a' field)   tuck swap -  ( a field field-c)
   dup 0< if  drop ^  then  ?for  bl hold  next then  #>  ;

( Non-truncating field.)
: field   ( a c field - a c)  over - spaces  ;

:  (.r)   ( n field - a #)   push  (.)   pop  field  ;
:   .r    (.r)  type  ;

: (u.r)   ( u field - a #)   push  (u.)  pop  field  ;
:  u.r    (u.r)  type  ;

( Useful.)
: ?  @ .  ;

: bits/cell  [ cell 8 * ] ;
: rotate  ( rotates _right_; without =if/then, rotates by 0 break on x86.)
  =if  2dup u>> push  negate bits/cell +  <<  pop xor ^ then drop ;


( String primitives.)

( 2010-feb-27. In converting to a single dictionary space I was forced to
  "revert" to having strings compiled inline. Now we have to jump over
  their bodies again.

  The single string literal primitive is called (")

( It jumps over the inline, cell-count-prefixed string, and pushes the
  address of its first character and its length on the stack. Because all
  strings are compiled with zero-terminators, it is possible to pass the
  address of the first character to a C function, and it will work.

  I use z" to identify this kind of address. It suggests a zero-terminated
  string.)

( Copy string; return a counted string [addr of first character;
  prefix count cell _precedes_ first character of string].
  This does _not_ allot space in the dictionary!)

: scrabble  ( a u - z")
   here addr+ push ( z")
   dup here ! ( prefix addr-sized length)
   tuck ( u a u)  r@ swap cmove  ( copy string)
   r@ + 0 swap c! ( zero terminator)  pop ;

( all compiled strings have a zero terminator.)
: count  ( z" - a u)  dup  addr- a@ ;
: (")    ( - a u)  pop  addr+ count ( a u)  2dup + 1+ aligned push ;

: _string      ( - z")  scrabble  count addr+ 1+  allot ;
: string,   ( ch - z")  parse  _string ;
: token,       ( - z")  token  _string ;

( Compiled strings.)
compiler
:  "   ( - a c)   \ (")  char " string,  drop ;
: z"   ( - z")    \ "  \ drop ;   ( z means zero-terminated)
: ."              \ "  \ type ;
: error"         \ z"  \ abort ;  ( compile a C-style string for abort)

( Interpreted strings. Strings that return an address always get compiled!)
forth
: z"  ( - z")   char "  string, ;
:  "  ( - a c)  \f z" count  ;  ( ANS)
: ."    char " parse ( a #)  type  ;  ( not compiled)

( Words that do something with each word being defined.)
: being-defined  constant  does> @  'new-hook a! ;

( To warn of re-defining a word.)
-: ( a u)  2dup current @ find if  fd-out preserve  >stderr
     drop  2dup type ."  again.  "  ^  then  2drop ;
being-defined -redef
 -redef

( A useful list of words as they're being defined.)
-: ( a u)   cr depth . current @ ( chain) . here .  2dup type ;
being-defined -v  ( be verbose)
-- -v

( You can only do one of these at a time! Is there an easy way to hook
  the hook?)


( Now that we have strings, let's make a more useful definition of
  undeferred, so that defer'ed words that never get set to anything will
  complain when used.)

-:  error" undefined deferred word" ;  undeferred !


( !!!!-------------------- Add changes below this line -------------------!!!!)

( Undefine a word by replacing the first character of its name with a DEL.)
: undef   current a@  chain'  >name  ( a u)  drop  127 swap c! ;

( Print word name, but skip deleted words, whose names start with a blank.)

: ?deleted  ( link)
   link>name  ( a u)  over c@ 127 = if  ( deleted)  2drop ^ then
   type space space ;

( Word listing. Putting this in as soon as possible. Needs `space'.)
: words   0  current a@  ( count 'suffix)
  begin  suffix>link a@  =while  1 u+
            dup suffix>link  ?deleted  repeat
  drop  cr  ." ("  . ." words)" ;

( XXX: should be primitive?)
: fill        ( a u n)  -rot  ?for  2dup c!    1+  next  then  2drop ;
: cell-fill   ( a u n)  -rot  ?for  2dup  ! cell+  next  then  2drop ;

: erase  ( a u)   0 fill  ;   ( easy, what?)
: blank  ( a u)  bl fill  ;


( Go forth and multiply ... and divide.

  As of r438 - 2006-mar-26 - there are no double-length numbers!

  Our new primitives are:
      * : n1 n2 - n3 [single-length product]
   /mod : n1 n2 - mod quot
  u/mod : u1 u2 - umod uquot

  Any word whose name starts with 'u' is unsigned, both in its arguments
  and its results; the others are signed.

  */ and */mod no longer calculate a double-length intermediate product,
  so beware!)

:  /      ( n1 n2 - quot)    /mod  nip ;
: u/      ( u1 u2 - uquot)  u/mod  nip ;

:  mod    ( n1 n2 - mod)     /mod  drop ;
: umod    ( u1 u2 - umod)   u/mod  drop ;

: */mod   ( n1 n2 n3 - mod quot)   push  *  pop  /mod ;
: */      ( n1 n2 n3 - n1*n2/n3)   */mod  nip ;


( Within.)
: within  ( n lo hi - lo <= n < hi)  over - push  - pop u<  ;


( Character classifications - useful for ASCII dumps and keyboard input.)
: letter?         32 127 within  ;  ( excludes ctrls & DEL)
: graphic?  dup  160 256 within  if  drop -1 ^  then  letter? ;


( Useful stack dump.)
: .s  ( stack)
   depth 0<  if ^ then  ( don't print underflowed stack!!)
   depth  s0 swap  ?for  cell- dup @ .  next then  drop  ;

( Sometimes it's nicer to see _unsigned_ stack values.)
: .us  ( stack)
   depth 0<  if ^ then  ( don't print underflowed stack!!)
   depth  s0 swap  ?for  cell- dup @ u.  next then  drop  ;

( Defining new dictionary chains.)

( These used to be in an array but are now independent of each other. They
  are structures that look just like a name entry in the dictionary - a
  name-suffix followed by a link field.

  By convention, the name-suffix fully defines a name - " VH" - that's
  "space victor hotel" - that contains a space so it's hard to accidentally
  match. "VH" suggests "vocab head".

  The link field points to the name entry - suffix - of the last word
  defined on the chain.

  I think I was careful to make the following code generate a name suffix
  that is -not- endianness-dependent.)

( XXX: This needs to test whether addresses are 64 bit! In which case the
  VH should be "     VH" and be 7 chars long - see dict.c )

: chain   create  [ char ) parse  VH )  ( a u)  drop a@ ] a,
   ( now put in length)  3 here 1- c!
   ( link) a, ;  ( fake name field before link)

: sealed           0  chain ;  ( create an independent vocab chain)
: chained  current @  chain ;  ( chain to the current vocab)

( It's also possible to chain to an -arbitrary- vocab by simply doing this:
  
  .arbitrary. chain .new-is-chained-to-arbitrary. )


( Conditional compilation.)

sealed .conditional.
: conditional   .conditional. definitions ;

( eat consumes tokens until it either consumes all the input - in which
  case the while loop will exit - or an execute'd word shunt's to exit the
  containing loop. ?toss processes each token. If it exists in
  .conditional. , it executes it; otherwise, it throws it away.)

: ?toss   .conditional. find  if  execute ^  then  2drop  0 ;
: eat   0 ( nesting)  begin  token  =while  ?toss  until  drop ( nesting) ^
                                    then  2drop ( token)  drop ( nesting) ;

compiler
: .if     0= if  eat  then ;
: .else   eat ;
: .then   ;

( Consume a token, search .forth., and return only the "found or not" flag.)
: .def  .forth. token' nip  =if ^ then  nip ;

: .ifdef   \ .def      \ .if ;
: .ifndef  \ .def  0=  \ .if ;

conditional
( nesting - nesting exitflag)
: .if       1+       0 ;  ( .if nests, never exits)
: .else         dup 0= ;  ( .else doesn't nest, exits if nesting at 0)
: .then     1-  dup 0< ;  ( .then unnests, exits if nesting -was- at 0)

: .ifdef    1+       0 ;  ( these are like .if)
: .ifndef   1+       0 ;

forth
: .if     \ .if ;
: .else   \ .else ;
: .then   ;

: .def     \ .def ;
: .ifdef   \ .ifdef ;
: .ifndef  \ .ifndef ;


( Two useful sets of units; these adhere to SI and IEC guidelines. ;-)
( K is uppercased so as not to conflict with do-loop's k)
: K   1000 * ;  ( "kilo": 10^3.)
: M   K K ;     ( "mega": 10^6.)

: Ki  10 << ;   ( "Kibi", or "kilobinary": 2^10.)
: Mi  Ki Ki ;   ( "Mebi", or "megabinary": 2^20.)


.ifdef clock

( Time, timestamp.)
: "hold  ( a n)  dup negate  hld +!  hld @  swap cmove  ;
: ##     ( n)   # #  drop  ;

( Separators)
: ":   char : hold  ;
: "-   char - hold  ;
: ".   char . hold  ;
: ||   bl hold  ;  ( a space)

: month"  ( n - a n)  ( n is 0--11)
   3 *  z" janfebmaraprmayjunjulaugsepoctnovdec" +  3 ;

( clock returns a count of seconds since 1970-jan-01 00:00:00 UTC,
  the Unix "epoch".)

( leaves a 0 which is consumed by #>)
: <date>   ( year month mday yday - 0)
   drop  ## "-  month" "hold "-  #s ( year) ;

: <hh:mm:ss>  ( hms)        ## ":  ## ":  ## ;
: <hh:mm>     ( hms)  drop ( sec)  ## ":  ## ;

: (time")  ( year month mday yday hour min sec 'zone #zone - a #)
   radix preserve  decimal  <#  "hold  ( zone)  ||  <hh:mm:ss>  ||  <date>  #> ;

: (short-time")  ( year month mday yday hour min sec 'zone #zone - a #)
   radix preserve  decimal  <#  2drop ( zone)  <hh:mm>  ||  <date>  #> ; 

: (date")  ( year month mday yday hour min sec 'zone #zone - a #)
   radix preserve  decimal  <#  2drop 2drop drop  <date>  #> ;

: date    ( epoch - y m d yday)  local-time  2drop 2drop drop ;

: date"   ( epoch - a n)  local-time  (date") ;
: time"   ( epoch - a n)  local-time  (time") ;
: utc"    ( epoch - a n)         utc  (time") ;

( Better primitives? More elegant, certainly.)
: s->sm    ( s - s m)    60 u/mod ;
: s->smh   ( s - s m h)  s->sm  s->sm ;
: s->smhd  ( s - s m h d)  s->smh  24 u/mod ;
: sm->s    60 * + ;
: smh->s   sm->s  sm->s ;
: smhd->s  24 * +  smh->s ;

( If anyone had any idea how long a year really is, we could also define
  s->smhdy and smhdy->s. ;-)

: smhq->s  6 * +  smh->s ;  ( sec min hr quarter-day)
: smhdy->s  [ 365 3 * 366 + ] * ( quarter-days/yr)  push 4 * pop +  smhq->s ;

.then ( time support)


( Link to project home page.)
: info
 ." For more information about muFORTH, please visit" cr cr
   ( ### httplink ###; keep following line, blank or not!)
 ."   http://muforth.nimblemachines.com/" cr cr
 ;


( show ` Ok' then sub-prompt)
: prompt   ."  Ok"   state a@  addr+  a@ execute ;

( set prompt in compile mode)
-: ."  (compiling)"  'compiler-mode  ;  addr+ a!  ( bwa ha ha!)

( Forth re-implementation of C interpret; semantics are exactly the same!)
: interpret
   begin  token =while  consume  ?stack  repeat  2drop ;

: evaluate  ( a u)
   source preserve  ( preserve both asize vars! ) ( source addr+ apreserve  ( save input source)
   first apreserve                ( save our place in the input)
   over first a!
   over source addr+ a!  + ( end)  source a!
   ( over +  [ start end]  source 2!)
   interpret ;

variable zloading    ( C-string name of file being loaded)

( check-depth only prints anything out if depth has changed since the file
  started loading _and_ zloading is non-zero - ie, we're loading a file.)

: check-depth  ( saved-depth)
   depth swap -  2 - ( seems to always be 2!)
      =if  zloading @ =if
      ."  [ "  zcount type  ." : +depth " .  ." ]" ^  then  drop  then  drop ;

: show-depths  ( saved)   .  depth . ;

( XXX I was hoping to use on-exit to check stack depths, but I can't seem
  to get them to reconcile. More research is indicated. ;-)

: load-file  ( z")
   depth  on-exit check-depth
   -- depth  on-exit show-depths
   dup open-file-ro ( fd)  dup on-exit close-file
   zloading preserve  swap zloading !
   line apreserve  1 line a!
   radix preserve  decimal
   fd-out preserve  >stderr
   read-file ( a u)  evaluate ;

( Consumes a token - a filename - and loads it.)
: ld  token, load-file ;

( how much dictionary space was consumed?)
: show-consumed  ( here)
   radix preserve  decimal
   fd-out preserve  >stderr
   here swap - .  ." bytes ))" ;

( Print some descriptive text and the amount of dictionary space consumed
  by loading. Consumes and prints the rest of the command line.)

: loading
   cr ." (( "  #LF parse type  space
   here  on-exit show-consumed  interpret ;

( Define words for use with the conditional compilation words.  No matter
  what chain we are compiling into, define the word in .forth.)

: -d   current apreserve  forth  -1 constant ;
: -f  ( load file)  ld ;

: banner
( Print banner.)
 ." muFORTH/ITC "
 .ifdef clock
    build-time ( seconds since epoch)  time"
 .else
    build-time ( pushes a string!)
 .then  type  cr
 ." Copyright (c) 2002-2011 David Frech. All rights reserved."  cr cr
 ." muFORTH is free software; see the file COPYRIGHT for details." cr
 ." To read more about muFORTH, type "
       char " emit  ." info" char " emit ." ." cr ;

( Don't print file & lineno if interactive - ie, zloading is zero)
: .where
   zloading @  =if  zcount type  ." , line "
   @line  radix preserve decimal u.  ." : "  ^  then
   drop ;

-: ( z")
   >stderr  cr  .where  parsed type space  zcount type  cr  unwind ;   'abort a!

: quit
   begin  cr  <stdin  typing evaluate  >stderr  prompt  again  [
   ( infinite loop, until error... )

: warm
   decimal \ [
   >stderr banner
   1 line a!  ( so it's "correct" for interactive!)
   command-line count  evaluate
   begin  quit  again  [

( Identify ourselves.)
-d  muFORTH
