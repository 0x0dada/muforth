( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

ld target/common/16bit.mu4

loading ARM Thumb16 assembler

hex

: assembler ;
: 4#  # # # # ;
: __  char _ hold ;
: debug-show   dup  radix preserve  binary  <# 4# __ 4# __ 4# __ 4# #>  cr  type ;

( Quick n dirty)
#64 Ki buffer image
variable h        ( offset relative to start of image)
variable 'region  ( target address of start of image)

( Cortex-M constants - true for M0, M3, and M4?)

2000_0000 constant @ram
0080_0000 constant @flash

: image+   image + ;
: image-   image - ;

: ram    @ram   'region ! ;
: flash  @flash 'region ! ;
: org    'region @ -  image+  h ! ;
: #image  h @  image - ;
: here   #image  'region @ + ;


: c,   h @  c!  1 h +! ;
: h,   >hilo  c,  c,  ;
-- :  ,   >hilo  c,  >hilo  c,  h, ;  ( crashes!!)
: op,  debug-show  h, ;

: reg   create  ( regnum)  ,  does> @  2000_0000 ( regtype) ;
assembler
#15 reg pc
#14 reg lr
#13 reg sp
  7 reg r7
  6 reg r6
  5 reg r5
  4 reg r4
  3 reg r3
  2 reg r2
  1 reg r1
  0 reg r0

1000_0000 constant #   ( imm - imm immtype)

forth

( When all three registers are specified - Rm, Rn, and Rd, the fields are
  as follows:

  m m m | n n n | d d d
)

: ?reg  ( reg type op - op reg)
   push  2000_0000 = not if  error" expected a register"  then
   pop swap  ;

: reg?  ( type op - type op f)   over  2000_0000 = ;

( These are named to suggest where they would put the 3-bit field if the
  instruction is in octal.)
: r00  ( reg regtype op)  ?reg  07 and  6 <<  or ;
: 0r0  ( reg regtype op)  ?reg  07 and  3 <<  or ;
: 00r  ( reg regtype op)  ?reg  07 and        or ;

: ?imm  ( imm type op - op imm)
   push  # = not if  error" expected immediate value"  then
   pop swap  ;

( Immediate fields)
: i5  ( imm immtype op)  ?imm  1f and  6 <<  or ;
: i3  ( imm immtype op)  ?imm  07 and  6 <<  or ;
: i8  ( imm immtype op)  ?imm  0ff and       or ;

( For instrs with 8-bit immediates. NOTE: needs to be preceded by a _type
  test_ so the order of stack operands is correct.)
: sh8  ( op n - op')  8 <<  or ;

( From here on out, i3/5/8 and Rm/n/d mean immediate value or register with
  type on top.)

: sh-imm  #11 <<  constant  does> @  ( i5 Rm Rd op)  00r  0r0  i5  op, ;

assembler
0 sh-imm lsl
1 sh-imm lsr
2 sh-imm asr

forth

: add-3reg  #9 <<  constant  does> @  ( Rm Rn Rd op)  00r  0r0  r00  op, ;
assembler
0c add-3reg addr3
0d add-3reg subr3

forth

( 3 bit immediate)
: add-3i  #9 <<  constant  does> @  ( i3 Rn Rd op)  00r  0r0  i3  op, ;
assembler
0e add-3i addi3
0f add-3i subi3

( 8 bit immediate)
: op-i8  #11 <<  constant  does> @  ( i8 Rd op)  ?reg sh8  i8  op, ;
assembler
4 op-i8 movi8
5 op-i8 cmpi8
6 op-i8 addi8
7 op-i8 subi8

forth

( So we can try to disassemble with objdump, and send to device using
  stlink.)

( Super-simple raw binary image. No address info is saved!)
: save-image
   token, create-file ( fd)
   dup ( fd)  image  #image  write
   close-file ;

( tests)
ram
@ram org  ( RAM start)

( imm shifts)
4 # r5 r7 lsl
8 # r3 r2 lsr
#31 # r4 r0 asr

( 3 regs)
r4 r5 r6 addr3
r0 r1 r2 subr3
6 # r5 r6 addi3
7 # r1 r2 subi3

( 8-bit imm)
44 # r6 movi8
0fc # r1 cmpi8
33 # r3 addi8
23 # r7 subi8

save-image stmf0-test.img
