( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

ld target/common/16bit.mu4

loading ARM Thumb16 assembler

hex

: assembler ;
: 4#  # # # # ;
: __  char _ hold ;
: debug-show   dup  radix preserve  binary  <# 4# __ 4# __ 4# __ 4# #>  cr  type ;

( Quick n dirty)
#64 Ki buffer image
variable h        ( offset relative to start of image)
variable 'region  ( target address of start of image)

( Cortex-M constants - true for M0, M3, and M4?)

2000_0000 constant @ram
0080_0000 constant @flash

: image+   image + ;
: image-   image - ;

: ram    @ram   'region ! ;
: flash  @flash 'region ! ;
: org    'region @ -  image+  h ! ;
: #image  h @  image - ;
: here   #image  'region @ + ;

( Halfword alignment)
: haligned   1+  -2 and ;
: halign     h @  haligned  h ! ;

( Word alignment)
: aligned   3 +  -4 and ;
: align     h @  aligned  h ! ;

: c,   h @  c!  1 h +! ;
: h,   >hilo  c,  c,  ;
-- :  ,   >hilo  c,  >hilo  c,  h, ;  ( crashes!!)
: op,  debug-show  h, ;

: reg   create  ( regnum)  ,  does> @  2000_0000 ( regtype) ;
assembler
#15 reg pc
#14 reg lr
#13 reg sp
#12 reg r12
#11 reg r11
#10 reg r10
  9 reg r9
  8 reg r8
  7 reg r7
  6 reg r6
  5 reg r5
  4 reg r4
  3 reg r3
  2 reg r2
  1 reg r1
  0 reg r0

1000_0000 constant #   ( imm - imm immtype)

forth

: ?reg  ( reg type op - op reg)
   push  2000_0000 = not if  error" expected a register"  then
   pop swap  ;

: reg?  ( type op - type op f)   over  2000_0000 = ;

( These are named to suggest where they would put the 3-bit field if the
  instruction is in octal.)
: r00  ( reg regtype op - op')  ?reg  07 and  6 <<  or ;
: 0r0  ( reg regtype op - op')  ?reg  07 and  3 <<  or ;
: 00r  ( reg regtype op - op')  ?reg  07 and        or ;

( For building opcodes with 4-bit register field, R.)
: 0R  ( R -> r0_000_rrr)  ( reg regtype op - op')
   ?reg  dup 8 and  4 <<  swap  07 and  or or ;

: R0  ( R -> 0r_rrr_000)  ( reg regtype op - op')
   ?reg  0f and  3 <<  or ;

: ?imm  ( imm type op - op imm)
   push  # = not if  error" expected immediate value"  then
   pop swap  ;

( Immediate fields)
: i5  ( imm immtype op)  ?imm  1f and  6 <<  or ;
: i3  ( imm immtype op)  ?imm  07 and  6 <<  or ;
: i8  ( imm immtype op)  ?imm  0ff and       or ;
: i7  ( imm immtype op)  ?imm   7f and       or ;

( For instrs with 8-bit immediates. NOTE: needs to be preceded by a _type
  test_ so the order of stack operands is correct.)
: sh8  ( op n - op')  8 <<  or ;

( From here on out, i3/5/8 and Rm/n/d mean immediate value or register with
  type on top.)

( Shift-immed register - low register only!)
: sh-imm  #11 <<  constant  does> @  ( i5 Rm Rd op)  00r  0r0  i5  op, ;
assembler
0 sh-imm lsli
1 sh-imm lsri
2 sh-imm asri
forth

( 3 register instructions - low registers only!)
: add-3reg  #9 <<  constant  does> @  ( Rm Rn Rd op)  00r  0r0  r00  op, ;
assembler
0c add-3reg addr3l
0d add-3reg subr3l
forth

( 3 bit immediate - low registers only!)
: add-3i  #9 <<  constant  does> @  ( i3 Rn Rd op)  00r  0r0  i3  op, ;
assembler
0e add-3i addi3
0f add-3i subi3
forth

( 8 bit immediate - low registers only!)
: op-i8  #11 <<  constant  does> @  ( i8 Rd op)  ?reg sh8  i8  op, ;
assembler
4 op-i8 movi8
5 op-i8 cmpi8
6 op-i8 addi8
7 op-i8 subi8
forth

( Data processing, low registers only!)
: alu0   6 <<  4000 or  constant  does> @  ( Rm Rdn op)  00r  0r0  op, ;

assembler
 0 alu0 and
 1 alu0 eor
 2 alu0 lslr
 3 alu0 lsrr
 4 alu0 asrr
 5 alu0 adc
 6 alu0 sbc
 7 alu0 ror
 8 alu0 tst
 9 alu0 rsb
0a alu0 cmpr
0b alu0 cmn
0c alu0 orr
0d alu0 mul
0e alu0 bic
0f alu0 mvnr
forth


( 4-bit register)
: reg4  8 <<  4400 or  constant  does> @  ( Rm Rdn op)  0R  R0  op, ;
assembler
0 reg4 addr2
1 reg4 cmpr2  ( NOTE: high registers _only_!)
2 reg4 movr2
forth
3 reg4 _bx
assembler
: bx   ( Rm)  r0 ( Rdn)  _bx ;
: blx  ( Rm)  r8 ( Rdn)  _bx ;
forth

( ldr pc-imm)
assembler
( XXX same code as op-i8, different base op)
( ea = align[pc+4] + [i8 << 2]
  i8 is _unsigned_ - forward offsets only!)
: ldr-pc-imm   ( offset Rt)  4800  ?reg sh8  i8  op, ;
forth

( ldr/str h/b/sb)
( XXX same code as add-3reg; different base opcode)
: ldr-str-ix   9 <<  5000 or  constant  does> @  ( Rm Rn Rt op)  00r  0r0  r00  op, ;
assembler
0 ldr-str-ix str-ix
1 ldr-str-ix strh-ix
2 ldr-str-ix strb-ix
3 ldr-str-ix ldrsb-ix
4 ldr-str-ix ldr-ix
5 ldr-str-ix ldrh-ix
6 ldr-str-ix ldrb-ix
7 ldr-str-ix ldrsh-ix

( ldr/str base+offset)
( NOTE: use + not or here!)
( Depending on size of datum, offset is _scaled_.
  byte     => *1
  halfword => *2
  word     => *4
  XXX NOTE: need words to check and calculate offsets!)

: ldr-str-imm   #11 <<  6000 +  constant  does> @  ( i5 Rn Rt op)  00r  0r0  i5  op, ;
assembler
0 ldr-str-imm str-imm
1 ldr-str-imm ldr-imm
2 ldr-str-imm strb-imm
3 ldr-str-imm ldrb-imm
4 ldr-str-imm strh-imm
5 ldr-str-imm ldrh-imm
forth

( ldr/str sp-rel)
( XXX same code as op-i8, different base op)
( As above, since we're moving a word-sized datum, i8 is scaled *4.)
: ldr-str-sp  #11 <<  6000 +  constant  does> @  ( i8 Rt op)  ?reg sh8  i8  op, ;
assembler
6 ldr-str-sp str-sp
7 ldr-str-sp ldr-sp

( add to pc/sp)
( i8 is scaled *4)
( same structure as ld/st sp offset!)
8 ldr-str-sp add-pc
9 ldr-str-sp add-sp
forth

( add/sub imm to sp)
( i8 is scaled *4)
: sp-offset  7 <<  0b000 or  constant  does> @  ( i7 op)  i7  op, ;
assembler
0 sp-offset add-to-sp
1 sp-offset sub-from-sp
forth

( 0b100 & 0b300 are cbz - not in ARMv6-M)

( Sign- and zero-extend)
( XXX same code as alu0; just different base opcode)
: sex!  6 <<  0b200 or  constant  does> @  ( Rm Rd op)  00r  0r0  op, ;
assembler
0 sex! sxth
1 sex! sxtb
2 sex! uxth
3 sex! uxtb
forth

( Push goes here. 8 bit reglist plus lr bit.)
( 0b400 + reglist + lr << 8)

( 0b900 & 0bb00 are cbnz - not in ARMv6-M)

( Byte and halfword reverses)
( XXX same code as alu0; just different base opcode)
: revs  6 <<  0ba00 or  constant  does> @  ( Rm Rd op)  00r  0r0  op, ;
assembler
0 revs rev
1 revs rev16
( 2 is ??)
3 revs revsh
-- forth

( Pop goes here. 8 bit reglist plus pc bit.)
( 0bc00 + reglist + pc << 8)

( Breakpoint)
( XXX is this a branch?)
: bkpt  ( i8)  0be00  i8  op, ;

( Hints.)
( 0bfx0 are hints; 0bfxm are IT - when m != 0. Not in ARMv6-M)
: hint  4 <<  0bf00 or  constant  does> @  op, ;
-- assembler
0 hint nop
1 hint yield
2 hint wfe
3 hint wfi
4 hint sev
forth


( ldm/stm)
( same as op-i8, different base opcode)
: ldm-stm   constant  does> @  ( reglist Rn op)  ?reg sh8  i8  op, ;
assembler
0c000 ldm-stm stm
0c800 ldm-stm ldm
forth

( Conditional branch.)
( Condition field:
  0  EQ  Z=1
  1  NE  Z=0
  2  CS  C=1   aka HS   NOTE: different from other architectures!
  3  CC  C=0   aka LO         ARM uses "natural" carry, which = ~borrow
  4  MI  N=1
  5  PL  N=0
  6  VS  V=1
  7  VC  V=0
  8  HI  C=1 and Z=0
  9  LS  C=0 or  Z=1
 10  GE  N=V
 11  LT  N!=V
 12  GT  N=V and Z=0
 13  LE  N!=V or Z=1
 14  AL  always    NOTE: always and never are NOT encoded in any ARMv6-M
 15  ??  never     instruction. Ever.

  b<cond> encoding: 0d000 + <cond> << 8 + offset
  offset is _signed_ and scaled *2
  XXX but from what PC?
)

( svc and friend(s)
( XXX are these _branches_? Like the conditional branch?)
( XXX like bkpt)
: svc-like   constant  does> @  ( i8 op)  i8  op, ;
assembler
0de00 svc-like undefined   ( branch always encoding!)
0df00 svc-like svc         ( branch never encoding!)
forth

( Long unconditional branch.)
( 0e000 + i11 offset: signed and scaled *2. But from what PC?)

( 0e800 - ffff are 32-bit encodings! See ARM/ARMv7/thumb32-asm.mu4 for
  details!)

( Save an image that we can try to disassemble with objdump, and send to
  device using stlink.)

( Super-simple raw binary image. No address info is saved!)
: save-image
   token, create-file ( fd)
   dup ( fd)  image  #image aligned  write
   close-file ;

( tests)
ram
@ram org  ( RAM start)

( imm shifts - low regs)
4 # r5 r7 lsli
8 # r3 r2 lsri
#31 # r4 r0 asri

( 3 regs - low regs)
r4 r5 r6 addr3l
r0 r1 r2 subr3l
6 # r5 r6 addi3
7 # r1 r2 subi3

( 8-bit imm - low regs)
44 # r6 movi8
0fc # r1 cmpi8
33 # r3 addi8
23 # r7 subi8

( alu low register)
r3 r5 tst
r7 r2 cmpr
r1 r4 bic

( 4-bit reg fields)
lr r8 addr2
r3 pc cmpr2
sp r5 movr2
lr bx
r9 blx

( ldr str indexd)
r0 r1 r2 str-ix
r3 r4 r5 strh-ix
r6 r7 r0 strb-ix
r1 r2 r3 ldrsb-ix
r4 r5 r6 ldr-ix
r7 r0 r1 ldrh-ix
r2 r3 r4 ldrb-ix
r5 r6 r7 ldrsh-ix

( ldr str base+offset, ie imm)
20 # r0 r1 str-imm
33 # r2 r3 ldr-imm
49 # r4 r5 strb-imm
53 # r6 r7 ldrb-imm
67 # r0 r1 strh-imm
98 # r2 r3 ldrh-imm

( ldr str rel to sp)
0ae # r0 str-sp
0dc # r1 ldr-sp

( load reg with pc or sp + offset)
0ce # r2 add-sp
0d9 # r3 add-pc

( offset the sp)
0b4 # add-to-sp
0c2 # sub-from-sp

save-image stmf0-test.img
