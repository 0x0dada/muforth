( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

.ifndef >hilo  ld target/common/endian.mu4  .then

loading CMSIS-DAP support (USB debug of Cortex-M devices)

-- Thanks are due to ARM for developing this open-source standard. The
-- specification and reference implementation (!) are at
-- https://silver.arm.com/browse/CMSISDAP. An account is necessary to
-- access this.

-- XXX Can multiple DAP commands be packed into a single USB packet (ie,
-- HID report)?

hex


comment CMSIS-DAP-commands

  I have left out a few that I don't think are that interesting - eg, those
  that concern talking to JTAG-DPs. The only interface this currently works
  with is the Freedom Board's OpenSDA CMSIS-DAP, which only supports the
  SW-DP (since the target chip, a Kinetis KL25Z, only _has_ an SW-DP).

  Numbers are in hex.

  DAP.LED
    > 01 xx yy        xx=00 for Connect, 01 for Running;
                      NOTE: only Connect implemented on Freedom board
                      yy=00 for off, 01 for on
    < 01 00

  DAP.Connect
    > 02 pp         pp=00 for default, 01 for SWD, 02 for JTAG
    < 02 pp         pp=00 failed, 01 SWD, 02 JTAG

  DAP.Disconnect
    > 03
    < 03 ss         ss=standard status: 00=ok, ff=failed

  DAP.Write_ABORT
    > 08 xx yy yy yy yy   xx=which device - ignored for SWD
                          yy=abort register word
    < 08 ss

  DAP.SWJ_Pins
    > 10 pp mm dd dd dd dd   pp=pin values to set
                             mm=mask - which pins to change
                             dd=delay in us
    Mapping for pp and mm:
       Bit 0: SWCLK/TCK
       Bit 1: SWDIO/TMS
       Bit 2: TDI
       Bit 3: TDO
       Bit 5: nTRST
       Bit 7: nRESET

    < 10 pp                  pp = pin values read from device

  DAP.SWJ_Sequence
    > 12 nn dd ..       nn = bit count 1 .. 256 (0 encodes 256)
                        dd = bit data, lsb first
    < 12 ss

  DAP.SWD_Configure
    > 13 cc     cc<1:0> = 00 1 cycle turnaround
                          01 2 cycles
                          10 3 cycles
                          11 4 cycles
                cc<2>   = DataPhase: 0 = do not generate on WAIT/FAULT
                                     1 = always generate on WAIT/FAULT
                                         for sticky overrun
    > 13 ss

  DAP.Transfer_Configure
    > 04 ii ww ww mm mm    ii = idle cycles after each transfer
                           ww = # retries after each WAIT response
                           mm = # retries for value match
    < 04 ss


  DAP.Transfer
    > 05 ii nn  rr dd dd dd dd  rr dd dd dd dd ..
                          ii = DAP index - ignored for SWD
                          nn = transfer count: 1 .. 255
                          rr = transfer request
                          dd = optional data (word)
                               transfer data or match value

    Requests have the following format:

       Bit 0: APnDP: 0 = Debug Port (DP), 1 = Access Port (AP).
       Bit 1: RnW: 0 = Write Register, 1 = Read Register.
       Bit 2: A2 Register Address bit 2.
       Bit 3: A3 Register Address bit 3.
       Bit 4: Value Match (only valid for Read Register):
              0 = Normal Read Register, 1 = Read Register with Value Match.
       Bit 5: Match Mask (only valid for Write Register):
              0 = Normal Write Register, 1 = Write Match Mask (instead of Register).

    < 05 nn rr  dd dd dd dd ..
                          nn = transfers executed: 1 .. 255
                          rr = last response from target
                          dd = data words received from target 

    Responses have the following format:

       Bit 2..0: ACK (Acknowledge): 1 = OK (OK/FAULT for JTAG), 2 = WAIT, 4 = FAULT.
       Bit 3: 1 = Protocol Error (SWD)
       Bit 4: 1 = Value Mismatch (Read Register with Value Match)

  DAP.Transfer_Block
    > 06 ii nn nn rr  dd dd dd dd .. 
                          ii = DAP index - ignored for SWD
                          nn = transfer count: 1 .. 65535
                          rr = transfer request

    Request has the following format:

       Bit 0: APnDP: 0 = DP (Debug Port), 1 = AP (Access Port)
       Bit 1: RnW: 0 = Write Register, 1 = Read Register
       Bit 2: A2 := Register Address bit 2
       Bit 3: A3 := Register Address bit 3

    < 06 nn nn rr  dd dd dd dd ..
                          nn = transfers executed: 1 .. 65535
                          rr = last response from target
                          dd = data words received from target 

    Response has the following format:

       Bit 2..0: ACK (Acknowledge): 1 = OK, OK/FAULT (JTAG), 2 = WAIT, 4 = FAULT
       Bit 3: Protocol Error (SWD)

  DAP.Transfer_Abort
    > 07
    No response, but aborted Transfer or Transfer_Block will respond with
    information about actually transferred data.

end CMSIS-DAP-commands


c251 f002 hid-find-device  .if  ( Keil CMSIS-DAP)
   constant cmsis

 -- hid-read  ( 'buffer size dev - #read)
 -- hid-write ( 'buffer size dev)

( Device found - load support)

: uread   ( buf len - #read)  cmsis  hid-read ;
: uwrite  ( buf len)          cmsis  hid-write ;

( A simple buffer for chatty communication protocols. Words for putting
  values into a buffer and taking them out again.)

variable bp  ( buf pointer)
40 buffer sendbuf
40 buffer recvbuf
: !send  sendbuf  bp !  sendbuf 40 55 fill ;
: !recv  recvbuf  bp ! ;
: #send  bp @  sendbuf - ;
: +bp    1 bp +! ;

( XXX Note: this is different from how I named these in
  target/HC08/bdm-usb-host.m4. Change those as well?)

: >b  ( byte)    bp @  c!  +bp ;
: b>  ( - byte)  bp @  c@  +bp ;

( Little-endian 16-bit values. In the ARM world these are "halfwords".)
: >h  ( hword)    >hilo  >b >b ;
: h>  ( - hword)          b> b>  lohi> ;

( Little-endian 32-bit values. In the ARM world these are "words".)
: >w  ( word)    >3210  >b >b >b >b ;
: w>  ( - word)          b> b> b> b>  0123> ;

( 16-bit halfword and 32-bit word fetch and store. Little endian.)
: h@  ( addr - h)  leh@ ;
: h!  ( h addr)    leh! ;
: w@  ( addr - w)  lew@ ;
: w!  ( w addr)    lew! ;

( Whether to spy on traffic to DAP.)
variable spy

: ?type  spy @ if  type  ^  then  2drop ;
: .send
   radix preserve  hex
   cr  sendbuf  #send for  c@+ swap u.  next  drop ;

: usend-recv  ( - r0 r1)  ( return first two bytes of response)
   spy @ if  .send  then
   sendbuf  #send uwrite
   !recv  recvbuf  #64   uread  drop  b> b> ;

: <cmd  ( cmd)  !send  >b ;
:  cmd>   ( - r1)  sendbuf c@ ( cmd)  push  usend-recv  swap pop xor if
   error" response didn't match command"  then ;

: check  ( r1)  if  error" DAP_ERROR response"  then ;

: DAP.LED  ( on/off)
   01 <cmd  00 >b  0= 1+ ( nonzero -> 0, zero -> 1)  >b  cmd> drop ;

: DAP.Connect
   02 <cmd  01 >b  cmd>  01 xor check ;

: DAP.SWD_Configure  ( config)
   13 <cmd  >b  cmd> check ;

( Send 56 1's then 8 0's.)
: DAP.Connect_Sequence
   12 <cmd  #64 >b  -1 >w  00ff_ffff >w  cmd> check ;

: DAP.Transfer_Configure
   04 <cmd  ( idle cycles) 04 >b  ( WAIT retries) 80 >h  ( match retries) 80 >h
   cmd> check ;


( Support for reading and writing basic DP and AP registers.)

( Unlike all other commands that access DP registers, DP.ABORT is
  self-contained. The other DP access words are intended for use inside of
  a "DAP.Transfer" operation - ie, bracketed by <xfer and xfer>.)

: DP.ABORT   ( abort)  08 <cmd   00 >b  >w     cmd> check ;
: -fault  -2 DP.ABORT ;  ( clear any faults)


( Whether to flash the "connect" LED for each transfer.)
variable led

variable #xfers
: <xfer
   led @ if  spy @ ( save)  spy off  -1 DAP.LED  spy !  then
   05 <cmd  00 ( DAP#) >b  00 ( count placeholder) >b  #xfers off ;

: >x  ( xfer)  ( add transfer to sequence)  >b  1 #xfers +! ;

:  xfer>
   #xfers @  sendbuf 2 + c!  cmd>
   led @ if  spy @ ( save)  spy off  0 DAP.LED  spy !  then
   #xfers @  xor if
      ." transactions not completed "  then
   b> dup 1 = if  drop  " OK "              ?type          ^  then
      dup 2 = if  drop  " WAIT "            ?type          ^  then
      dup 4 = if  drop  " FAULT "           ?type  -fault  ^  then
      dup 8 = if  drop  " Protocol error "  ?type          ^  then
         10 = if  drop  " Value mismatch "  ?type             then ;


: _DP.IDCODE            02 >x      ;
: _DP.CTRL    ( ctrl)   04 >x  >w  ;  ( NOTE: SELECT[0] must be 0)
: _DP.STAT              06 >x      ;  ( NOTE: SELECT[0] must be 0)
: _DP.SELECT  ( sel)    08 >x  >w  ;
: _DP.RESEND            0a >x      ;
: _DP.RDBUFF            0e >x      ;  ( NOTE: CMSIS firmware reads this for us!)


( Create a generic way to keep a "shadow" copy of a register value, and
  only update the real register if the new value is different from the old
  shadow value. The shadow value can be read using @, but it should only be
  changed via punch. Or should the word be called "box" - as in shadow
  boxing?)

: shadow   create  ( 'set-code initial)  ,  , ;
: punch  ( new-value 'body)
   push  r@ @  ( shadow)  over xor if  ( different)
      dup r@ !  pop cell+ @execute  ^
   then  pop  2drop ;


' _DP.SELECT -1  shadow select

: select!   ( sel - reg)  dup -10 and  select punch  0c and ;

( Adds a read or write of an AP register to a transfer.)
: AP.Rd  ( sel)    select!  3 +  >x     ;  ( set AP & RnW bit)
: AP.Wr  ( w sel)  select!  1+   >x  >w ;  ( set AP only)

( Generates a transfer made up of a single read AP or write AP - possibly
  preceded by a SELECT.)

: AP.Read   ( sel - w)  <xfer  AP.Rd  xfer>  w> ;
: AP.Write  ( w sel)    <xfer  AP.Wr  xfer> ;


-- -----------------------------------------------------------------------
-- These are addresses that go into SELECT.
-- -----------------------------------------------------------------------
( AHB-AP registers)
0000_0000 constant AHB.CSW
0000_0004 constant AHB.TAR
(    0008 reserved)
0000_000c constant AHB.DRW  ( Access size depends on CSW.size bits)

( Bank registers. These always generates word-sized accesses, 
  but require CSW.size bits to be set to word size.)

0000_0010 constant AHB.BD0  ( TAR and -10)
0000_0014 constant AHB.BD1  ( TAR and -10 + 4)
0000_0018 constant AHB.BD2  ( TAR and -10 + 8)
0000_001c constant AHB.BD3  ( TAR and -10 + 0c)

0000_00f8 constant AHB.ROM
0000_00fc constant AHB.IDR

( For KL25Z:)
( MDM-AP registers)
0100_0000 constant MDM.Status
0100_0004 constant MDM.Control
0100_00fc constant MDM.IDR

-- -----------------------------------------------------------------------
-- These are addresses in the chip's memory map.
-- -----------------------------------------------------------------------
( SCS debug registers)
e000_edf0 constant DHCSR  ( debug halting control/status reg)
e000_edf4 constant DCRSR  ( debug core register selector reg)
e000_edf8 constant DCRDR  ( debug core register data reg)
e000_edfc constant DEMCR  ( debug exception and monitor ctrl reg)

( Defines for AHB.CSW)
comment %%hardwired%%
0 constant CSW.byte    ( memory bus transaction sizes)
1 constant CSW.hword
2 constant CSW.word

 0 constant CSW.no-incr
10 constant CSW.single-incr
20 constant CSW.packed-incr  ( *not* supported on KL25Z!)

37 constant CSW.size-incr-mask
%%hardwired%%


( The interface for the interact code. Implemented by all debug transports.)

: t.chat  ( connect to device)
   spy on  led on
   DAP.Connect  00 DAP.SWD_Configure  DAP.Transfer_Configure
   DAP.Connect_Sequence
   <xfer  _DP.IDCODE  xfer>  w>  u.
   -fault
   <xfer  0 _DP.SELECT  5000_0000 _DP.CTRL ( pwr up sys & dbg)  xfer>
   spy off
;

: t.halt   complain ;
: t.run    complain ;
: t.step   complain ;

: t.getregs  ( buf)  complain ;  ( NYI)
: t.setregs  ( buf)  complain ;

( XXX add chunking to this? - use generic chunking code from stlink)
( XXX These shouldn't be used to transfer more that about 32 bytes of
  data at a time!)
( XXX Rewrite these to use TransferBlock?)

: t.read   ( buf a u)
   swap  ( buf u a)
   <xfer  AHB.TAR  AP.Wr  300_0012  AHB.CSW  AP.Wr
          dup  2 >> for  AHB.DRW  AP.Rd  next  xfer>
   bp @ -rot  cmove ;

: t.write  ( buf a u)
   swap  ( buf u a)
   <xfer  AHB.TAR  AP.Wr  300_0012  AHB.CSW  AP.Wr
          2 >> for  dup 4 +  swap lew@  AHB.DRW  AP.Wr  next  xfer>
   drop ;


( XXX The following is mostly intended for debugging the debugger. ;-)

( To and from byte lane(s)
: a>shift  ( a - #shifts)  3 and 8 * ;
: >lanes   ( data a - word)       a>shift << ;
:  lanes>  ( a word - data)  swap a>shift >> ;

: addr!  ( a - a)  -fault  <xfer  dup  AHB.TAR AP.Wr ;
: size!  ( size)         300_0000  or  AHB.CSW AP.Wr ;

: drw@   ( a - result)        AHB.DRW  AP.Rd  xfer>  w> lanes> ;
: drw!   ( data a)    >lanes  AHB.DRW  AP.Wr  xfer> ;

: rb  ( a - b)  ( read byte from target)   addr!  0 size!  drw@    0ff and ;
: rh  ( a - h)  ( read hword from target)  addr!  1 size!  drw@  0ffff and ;
: rw  ( a - w)  ( read word from target)   addr!  2 size!  drw@ ;

: wb  ( b a)  ( write byte to target)   addr!  0 size!  drw! ;
: wh  ( h a)  ( write hword to target)  addr!  1 size!  drw! ;
: ww  ( w a)  ( write word to target)   addr!  2 size!  drw! ;

.else  ." No supported USB devices found."

.then
