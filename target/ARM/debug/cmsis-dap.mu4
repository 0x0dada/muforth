( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

.ifndef >hilo  ld target/common/endian.mu4  .then

loading CMSIS-DAP support (USB debug of Cortex-M devices)

-- Thanks are due to ARM for developing this open-source standard. The
-- specification and reference implementation (!) are at
-- https://silver.arm.com/browse/CMSISDAP. An account is necessary to
-- access this.

-- XXX Can multiple DAP commands be packed into a single USB packet (ie,
-- HID report)?

hex


comment CMSIS-DAP-commands

  I have left out a few that I don't think are that interesting - eg, those
  that concern talking to JTAG-DPs. The only interface this currently works
  with is the Freedom Board's OpenSDA CMSIS-DAP, which only supports the
  SW-DP (since the target chip, a Kinetis KL25Z, only _has_ an SW-DP).

  Numbers are in hex.

  DAP.LED
    > 01 xx yy        xx=00 for Connect, 01 for Running;
                      NOTE: only Connect implemented on Freedom board
                      yy=00 for off, 01 for on
    < 01 00

  DAP.Connect
    > 02 pp         pp=00 for default, 01 for SWD, 02 for JTAG
    < 02 pp         pp=00 failed, 01 SWD, 02 JTAG

  DAP.Disconnect
    > 03
    < 03 ss         ss=standard status: 00=ok, ff=failed

  DAP.Write_ABORT
    > 08 xx yy yy yy yy   xx=which device - ignored for SWD
                          yy=abort register word
    < 08 ss

  DAP.SWJ_Pins
    > 10 pp mm dd dd dd dd   pp=pin values to set
                             mm=mask - which pins to change
                             dd=delay in us
    Mapping for pp and mm:
       Bit 0: SWCLK/TCK
       Bit 1: SWDIO/TMS
       Bit 2: TDI
       Bit 3: TDO
       Bit 5: nTRST
       Bit 7: nRESET

    < 10 pp                  pp = pin values read from device

  DAP.SWJ_Sequence
    > 12 nn dd ..       nn = bit count 1 .. 256 (0 encodes 256)
                        dd = bit data, lsb first
    < 12 ss

  DAP.SWD_Configure
    > 13 cc     cc<1:0> = 00 1 cycle turnaround
                          01 2 cycles
                          10 3 cycles
                          11 4 cycles
                cc<2>   = DataPhase: 0 = do not generate on WAIT/FAULT
                                     1 = always generate on WAIT/FAULT
                                         for sticky overrun
    > 13 ss

  DAP.Transfer_Configure
    > 04 ii ww ww mm mm    ii = idle cycles after each transfer
                           ww = # retries after each WAIT response
                           mm = # retries for value match
    < 04 ss


  DAP.Transfer
    > 05 ii nn  rr dd dd dd dd  rr dd dd dd dd ..
                          ii = DAP index - ignored for SWD
                          nn = transfer count: 1 .. 255
                          rr = transfer request
                          dd = optional data (word)
                               transfer data or match value

    Requests have the following format:

       Bit 0: APnDP: 0 = Debug Port (DP), 1 = Access Port (AP).
       Bit 1: RnW: 0 = Write Register, 1 = Read Register.
       Bit 2: A2 Register Address bit 2.
       Bit 3: A3 Register Address bit 3.
       Bit 4: Value Match (only valid for Read Register):
              0 = Normal Read Register, 1 = Read Register with Value Match.
       Bit 5: Match Mask (only valid for Write Register):
              0 = Normal Write Register, 1 = Write Match Mask (instead of Register).

    < 05 nn rr  dd dd dd dd ..
                          nn = transfers executed: 1 .. 255
                          rr = last response from target
                          dd = data words received from target 

    Responses have the following format:

       Bit 2..0: ACK (Acknowledge): 1 = OK (OK/FAULT for JTAG), 2 = WAIT, 4 = FAULT.
       Bit 3: 1 = Protocol Error (SWD)
       Bit 4: 1 = Value Mismatch (Read Register with Value Match)

  DAP.Transfer_Block
    > 06 ii nn nn rr  dd dd dd dd .. 
                          ii = DAP index - ignored for SWD
                          nn = transfer count: 1 .. 65535
                          rr = transfer request

    Request has the following format:

       Bit 0: APnDP: 0 = DP (Debug Port), 1 = AP (Access Port)
       Bit 1: RnW: 0 = Write Register, 1 = Read Register
       Bit 2: A2 := Register Address bit 2
       Bit 3: A3 := Register Address bit 3

    < 06 nn nn rr  dd dd dd dd ..
                          nn = transfers executed: 1 .. 65535
                          rr = last response from target
                          dd = data words received from target 

    Response has the following format:

       Bit 2..0: ACK (Acknowledge): 1 = OK, OK/FAULT (JTAG), 2 = WAIT, 4 = FAULT
       Bit 3: Protocol Error (SWD)

  DAP.Transfer_Abort
    > 07
    No response, but aborted Transfer or Transfer_Block will respond with
    information about actually transferred data.

end CMSIS-DAP-commands


c251 f002 hid-find-device  .if  ( Keil CMSIS-DAP)
   constant cmsis

 -- hid-read  ( 'buffer size dev - #read)
 -- hid-write ( 'buffer size dev)

( Device found - load support)

: uread   ( buf len - #read)  cmsis  hid-read ;
: uwrite  ( buf len)          cmsis  hid-write ;

( A simple buffer for chatty communication protocols. Words for putting
  values into a buffer and taking them out again.)

variable bp  ( buf pointer)
40 buffer sendbuf
40 buffer recvbuf
: !send  sendbuf  bp !  sendbuf 40 55 fill ;
: !recv  recvbuf  bp ! ;
: #send  bp @  sendbuf - ;
: +bp    1 bp +! ;

( XXX Note: this is different from how I named these in
  target/HC08/bdm-usb-host.m4. Change those as well?)

: >b  ( byte)    bp @  c!  +bp ;
: b>  ( - byte)  bp @  c@  +bp ;

( Little-endian 16-bit values. In the ARM world these are "halfwords".)
: >h  ( hword)    >hilo  >b >b ;
: h>  ( - hword)          b> b>  lohi> ;

( Little-endian 32-bit values. In the ARM world these are "words".)
: >w  ( word)    >3210  >b >b >b >b ;
: w>  ( - word)          b> b> b> b>  0123> ;

variable spy
: .send
   radix preserve  hex
   cr  sendbuf  #send for  c@+ swap u.  next  drop ;

: chat  ( - r0 r1)  ( return first two bytes of response)
   spy @ if  .send  then
   sendbuf  #send uwrite
   !recv  recvbuf  #64   uread  drop  b> b> ;

: <cmd  ( cmd)  !send  >b ;
:  cmd>   ( - r1)  sendbuf c@ ( cmd)  push  chat  swap pop xor if
   error" response didn't match command" then ;

:  check  ( r1)  if  error" DAP_ERROR response"  then ;

: DAP.LED  ( on/off)
   01 <cmd  00 >b  0= 1+ ( nonzero -> 0, zero -> 1)  >b  cmd> drop ;

: DAP.Connect
   02 <cmd  01 >b  cmd>  01 xor check ;

: DAP.SWD_Configure  ( config)
   13 <cmd  >b  cmd> check ;

( Send 56 1's then 8 0's.)
: DAP.Connect_Sequence
   12 <cmd  #64 >b  -1 >w  00ff_ffff >w  cmd> check ;

: DAP.Transfer_Configure
   04 <cmd  ( idle cycles) 04 >b  ( WAIT retries) 80 >h  ( match retries) 80 >h
   cmd> check ;

: <xfer   05 <cmd  00 ( DAP#) >b  00 ( count placeholder) >b ;
:  xfer>  ( req-count - resp-count)
   dup push  sendbuf 2 + c!  cmd>  pop xor if
      error" transactions not completed"  then
   b> dup 1 = if  drop ." OK "  ^ then
      dup 2 = if  drop ." WAIT " ^  then
      dup 4 = if  drop ." FAULT " ^ then
      dup 8 = if  drop ." Protocol error " ^ then
         10 = if  drop ." Value mismatch " then ; 

( Support for reading and writing basic DP and AP registers.)
: DP.ABORT   ( abort)  08 <cmd   00 >b  >w     cmd> check ;
: DP.IDCODE  ( - idcode)  <xfer  02 >b      1 xfer>  w> ;
: _DP.CTRL    ( ctrl)            04 >b  >w ;  ( NOTE: SELECT[0] must be 0)
: _DP.STAT    ( - stat)          06 >b ;      ( NOTE: SELECT[0] must be 0)
: _DP.SELECT  ( select)          08 >b  >w ;
: _DP.RESEND  ( - word)          0a >b ;
: _DP.RDBUFF  ( - word)          0e >b ;

: select!   ( addr - offset)  <xfer  dup -10 and  _DP.SELECT  0c and ;
: AP.Read   ( addr - w)  select!  ( offset)  3 +  >b  _DP.RDBUFF   3 xfer>  w> ;
: AP.Write  ( w addr)    select!  ( offset)  1 +  >b  >w      2 xfer> ;

( AHB-AP registers)
0000_0000 constant AP.CSW
0000_0004 constant AP.TAR
(    0008 reserved)
0000_000c constant AP.DRW

0000_0010 constant AP.BD0
0000_0014 constant AP.BD1
0000_0018 constant AP.BD2
0000_001c constant AP.BD3

0000_00f8 constant AP.ROM
0000_00fc constant AP.IDR

( For KL25Z:)
( MDM-AP registers)
0100_0000 constant MDM.Status
0100_0004 constant MDM.Control
0100_00fc constant MDM.IDR

( SCS debug registers)
e000_edf0 constant DHCSR  ( debug halting control/status reg)
e000_edf4 constant DCRSR  ( debug core register selector reg)
e000_edf8 constant DCRDR  ( debug core register data reg)
e000_edfc constant DEMCR  ( debug exception and monitor ctrl reg)

( XXX testing - now do something!)
: hi
   spy on
   1 DAP.LED
   DAP.Connect
   00 DAP.SWD_Configure  DAP.Transfer_Configure
   DAP.Connect_Sequence  DP.IDCODE u.
   -2 DP.ABORT ( clear any error flags)
   <xfer  0 _DP.SELECT  5000_0000 _DP.CTRL ( pwr up sys & dbg)  2 xfer>
   0 DAP.LED
;

.else  ." No supported USB devices found."

.then
