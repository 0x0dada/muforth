( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

ld target/common/endian.mu4

loading Tiva/Stellaris debug support

( TI won't just come out and say it, but their "ICDI" - in-circuit debug
  interface - is simply an implementation of GDB's remote debug protocol
  over bulk USB endpoints. All the documentation needed to talk to this
  interface is in the GDB docs!

  If you claim interface 2 on the board, and read endpoint 3 and write
  endpoint 2 - both 64 byte bulk endpoints - you'll be talking to a
  relatively standard GDB stub.)

( NOTE: In order to have a reasonable conversation with an ICDI-based board
  you have to do a "qSupported" query first, otherwise all memory reads
  will return 0, and it will be impossible to stop the core.)

hex

1cbe 00fd usb-find-device  .if  constant icdi

( Device found - load support)

2 icdi usb-claim-interface

( On OSX in particular, if you don't do this, the next time around the
  board wedges... Weird.)

: done   2 icdi  usb-release-interface  icdi usb-close ;

: uread   ( buf len - #read)  3  icdi  usb-read ;
: uwrite  ( buf len)          2  icdi  usb-write ;

( Binary data is sent escaped.)
: escape-byte  ( b dest - b' dest')
   char {  over c!  ( escape char)
   swap  20 xor  swap ;

: ?escape  ( b dest - b' dest')
   over  char $ = if  escape-byte  ^  then
   over  char # = if  escape-byte  ^  then
   over  char { = if  escape-byte     then ;

: ?unescape  ( b src - b' src')
   over  char { = if  c@+  swap 20 xor  swap  then ;

( Let's size the buffer so we can move 256 bytes at a time. For writing,
  the buffer will look like this:

  $M2000f000,100:xx ... xx#ss

  The overhead is: 7 punct + 3 len + 8 address = 18 bytes. We need 2 bytes
  in the buffer for each byte read or written; so 256 * 2 + 18 total. Let's
  round up our overhead to a multiple of 8.)

variable bp  ( buf pointer)
218 constant #maxbuf  ( these are HEX numbers!)
#maxbuf buffer buf

: 0buf  buf #maxbuf 55 fill ;
: !buf  buf bp ! ;
: #buf  bp @  buf - ;
: +bp   1 bp +! ;

( XXX Note: this is different from how I named these in
  target/HC08/bdm-usb-host.m4. Change those as well?)

: >b  ( byte)    bp @  c!  +bp ;
: b>  ( - byte)  bp @  c@  +bp ;

: >string  ( a u)  tuck  bp @ swap cmove  bp +! ;
: >num
   radix preserve  hex  <# #s #>  ( a u)  >string ;

: >nyb      0f and  >digit  >b ;
: nyb>          b>  digit>  0f and ;  ( hopefully it was actually hex... ;-)

: >hex  ( b)    dup  4 >> >nyb  >nyb ;
: hex>  ( - b)  nyb> 4 <<       nyb> + ;

: >hexstring  ( a u)
   ?for  c@+ swap  >hex  next  then  drop ;

: hexstring>  ( a u)
   ?for  hex> over c!  1+  next  then  drop ;

: checksum  ( - sum)
   #buf  1-  ( don't count $)  !buf +bp  ( skip $)
   0 ( sum)  swap ?for  b> +  next  then  0ff and ;

: sum  ( a u - sum)
   0 -rot ( sum)  ?for  c@+ push  +  pop  next  then  drop  0ff and ;

: checksum2  ( - sum)
   buf 1+  ( skip $)  #buf 1-  sum ;

( Whether to spy on traffic to DAP.)
variable spy

: recv
   buf #maxbuf uread
   spy @ if  cr ." < "  buf swap type  then ;

: send-recv
   spy @ if  cr ." > "  buf #buf type  then
   buf #buf uwrite  recv ;

: ack?  buf c@  char + = ;

: ?check  ( - n)
   !buf  b> char $ = if
      0 0 begin  b>  dup char # xor while  +  1 u+  repeat
      drop  0ff and  hex> = if  ( checksums match?)  2/  !buf +bp  ^  then
      error" checksum failed"  ^  then
   error" invalid packet start" ;

: <pkt  ( begin a debug packet)
   0buf  !buf  char $ >b ;

: pkt>  ( end a debug packet)
   -- checksum  char # >b  >hex  0 >b
   checksum2  char # >b  >hex  0 >b
   begin  send-recv  ack? until
   ( kludge) recv
   -- begin  recv  ?start ;
   ;

: cmd    ( char)    <pkt  >b        pkt> ;
: cmd,n  ( n char)  <pkt  >b  >num  pkt> ;

compiler
: <cmd>           \c char  compile cmd ;
: <cmd,n>   ( n)  \c char  compile cmd,n ;
forth

( debug)
spy on
: r  recv ;

: t.cycle          <cmd>   i ;
: t.cycles  ( n)   <cmd,n> i ;
: t.step           <cmd>   s ;
: t.halt           <cmd>   ? ;
: t.run            <cmd>   c ;
: t.go    ( addr)  <cmd,n> c ;
: t.getregs        <cmd>   g ;
: t.getreg  ( n)   <cmd,n> p ;

: t.setreg  ( value n)
   <pkt  char P >b  >num  char = >b  pad lew!  pad 4 >hexstring  pkt> ;

: t.read  ( buf a u)
   push ( u)
   <pkt  char m >b  >num  char , >b  r@ >num  pkt>
   -- !buf +bp  ( should do ?check)
   ?check  r@ ( u)  = if  pop ( u)  hexstring>  ^  then
   shunt  error" size mismatch" ;

: t.chat
   <pkt  " qSupported" >string  pkt> ;

: pc@   #15 t.getreg ;

.else  ." No supported USB devices found."

.then
