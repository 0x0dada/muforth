( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2010 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

" ARM kernel "  file[#

( 2010-feb-03 - Heavily modified! and changed to DTC.)
( 2006-apr-01.)

__meta  ( fire up the metacompiler!!)

assembler hex

( Register usage.)
comment moved-from-assembler
 09 constant top ( t)  ( data stack top)
 0a constant ct  ( c)  ( for loop count reg)
 0b constant up  ( u)  ( user pointer; for multitasking!)
 0c constant sp  ( s)  ( data stack pointer)
 0d constant rp  ( r)  ( return stack pointer)
moved-from-assembler

7 constant count  ( for for/next loops)
6 constant top
5 constant rp
4 constant ip

decimal

macro: push  ( r)  4 sp -) !  \f swap  str  ;
macro: pop   ( r)  4 sp )+    \f swap  ldr  ;

macro: nest    ( r)  4 rp -) !  \f swap  str  ;
macro: unnest  ( r)  4 rp )+    \f swap  ldr  ;

( top is considered st0)
macro: st1   0 sp +)  ;  ( address the second item on the stack)
macro: st2   4 sp +)  ;  ( address the third item on the stack)
macro: st3   8 sp +)  ;  ( address the fourth item on the stack)

macro: next  4 ip )+ pc ldr  ;

( capture compiles a branch-and-link -over- the following cell; it captures
  the address of the following cell in lr)
macro: capture   here [ 2 cells ] +  bl  ;

( lr@ loads the cell at lr into a reg)
macro: lr@  ( reg)   0 lr +)  \f swap ( reg)  ldr  ;

macro: load-relocated  ( lit reg)   capture   \f swap a, ( lit)   lr@  ;
macro: load-literal    ( lit reg)   capture   \f swap ,  ( lit)   lr@  ;

macro: blr ( reg)  ( bl thru a register)
     pc lr mov  ( capture return address - beyond following instruction)
     ( reg) pc mov  ( jump via reg)  ;

( Useful macro for the "prologue" of parent does> words: saves the lr to a
  register, since the child will be doing a bl to the parent, and we don't
  want to clobber the value in lr, which is a pointer to the child's data.)

macro: save-lr  lr r0 mov  ;

==========================================================================
Start of meta-compiled kernel
==========================================================================

target  ( compile into target vocab)

==========================================================================
Kernel header

These fields are at fixed offsets and shall not be moved or mucked with, on
pain of death!
==========================================================================

1 , ( Kernel/C API interface structure version) 

label fp-entry ( FORTH parameters entry field)
0 a, ( start address of FORTH Kernel will be patched later)

( The following addresses will be patched later.
  And, ip0 is the first FORTH instruction to execution.
  entry point above points to code which begins the inner interpreter.
  rp0 and sp0 are the start address for rp and sp, respectively.
  h0 == sp0, as it turns out. Does that mean we can rid ourselves of h0? )
label 'ip0  0 a,
label 'rp0  4 Ki a,
label  'h0  8 Ki a, ( will be loaded into top and then stored into h )
label 'sp0  8 Ki a,

label exit-context
0 ,   ( r0 -- caller's set jmp context address)
0 ,   ( pc -- caller's long jmp routine address)

label 'type     0 ,  -- pointer to C function: void type(char *s, int n)

( Not implemented yet)
label '?key     0 ,  -- ptr to C: cell_t qkey(void)
label 'key      0 ,  -- ptr to C: cell_t key(void)
label 'readline 0 ,  -- ptr to C: ??? readline(???)
label 'getfile  0 ,  -- ptr to C: ??? getfile(???)


==========================================================================
End of kernel header, start of real kernel
==========================================================================

==========================================================================
Meta-compiler's version of defining words.

It makes sense to start with the meta-defining words so we can build
interesting things other than just code words.

We'll be defining the target-resident versions later in the kernel, which
is why we define labels here for dovar, doconst, docolon, and dodoes. We
patch their values into the target-resident defining words when we define
them.
==========================================================================

meta: create    new
                ;code  dovar    top push   lr top mov        next  ;c

meta: constant  new  ,
                ;code  doconst  top push   0 lr +) top ldr   next  ;c

meta: variable   create          cell  allot ;
meta: 2variable  create   [ 2 cells ]  allot ;

meta: :   new   __meta-colon
                ;code  docolon  ip nest   lr ip mov   next  ;c

meta: <dodoes>  save-lr  code,
                ;code   dodoes  ip nest   lr ip mov
                                top push  r0 top mov   next  ;c

definer: does>   <;code>  <dodoes>  __meta-colon ;

( Explanation of dodoes: child word executes bl to parent; lr points to
  child's data; parent saves lr in r0; executes bl to dodoes; lr points to
  list of forth words to execute.)

==========================================================================
Words to talk to the C environment.
==========================================================================

code entry
     { r1 r2 ( throw-away registers)
       ip rp top sp } r0 ldm
     "0decafbad r3 load-literal  r3 push
     next

code bye
   ( 0   if        1         then   >r1       )
     0 # top cmp   1 # top mov 0=   top r1 mov

   ( exit-context dup       @ >r0
                      cell+ @ >pc
     But we do this all in assembler using r3 as a base
     and then load multiple into r0 pc )

     exit-context r3 load-relocated
     { r0 pc } r3 ldm  ;c

code type ( a u -- )   implements type
     'type r3 load-relocated  ( r3 points the address of type)
     0 r3 +) r2 ldr           ( r2 now contains the address of type)
     top r1 mov               ( r1 == u)
     r0 pop                   ( r0 == a)
     r2 blx                   ( call type)
     top pop                  ( load top)
     next  ;c

code ?key ( - f)
     '?key r3 load-relocated
label key-call
     r3 blr   top push   r0 top mov   next  ;c

code key ( - ch)
     'key r3 load-relocated   key-call b  ;c

code readline  ( ???)  next  ;c
code getfile  ( ???)  next  ;c


==========================================================================
Definition of the low-level words - the Forth virtual machine.
==========================================================================

code ^ implements ^
   ip unnest   next  ;c

code +     r0 pop   top r0 top add   next  ;c
code d+  ;c  ( UNDEF)
code -     r0 pop   top r0 top sub   next  ;c
code *     r0 pop   r0 top top mul   next  ;c
code and   r0 pop   top r0 top and   next  ;c
code bic   r0 pop   top r0 top bic   next  ;c
code or    r0 pop   top r0 top or    next  ;c
code xor   r0 pop   top r0 top eor   next  ;c

code negate   0 # top top rsb   next  ;c
code dnegate  ;c  ( UNDEF)
code invert       top top mvn   next  ;c

code dup   top push  next  ;c
code nip   r0  pop   next  ;c
code drop  top pop   next  ;c

code swap  top r0 mov   st1 top ldr   st1 r0 str  next  ;c
code over  top push     st2 top ldr   next  ;c
: tuck  ( a b - b a b)  swap over ;

code >r   top nest   top pop      next  ;c
code r>   top push   top unnest   next  ;c
code r@   top push   0 rp +) top ldr   next  ;c

.ifndef rot-in-forth

code rot  ( r1 r0 top - r0 top r1)
   { r1 r0  } sp ldm ia   r0 lr mov
   { lr top } sp stm ia
   r1 top mov next  ;c

code -rot  ( r1 r0 top - top r1 r0)
   { r1 r0  } sp ldm ia
   { top r1 } sp stm ia
   r0 top mov next ;c

.else
:  rot   >r swap  r> swap ;
: -rot   swap >r  swap r> ;
.then

code <<       r0 pop   r0 top lsl top mov   next  ;c
code >>       r0 pop   r0 top asr top mov   next  ;c
code u>>      r0 pop   r0 top lsr top mov   next  ;c
code rotate   r0 pop   r0 top ror top mov   next  ;c

code 2/    top 1 #asr top mov  next  ;c
code u2/   top 1 #lsr top mov  next  ;c
code 2*    top 1 #lsl top mov  next  ;c

code u<    r0 pop  top r0  cmp   -1 # top mov u<   0 # top mov u>=  next  ;c
code <     r0 pop  top r0  cmp   -1 # top mov  <   0 # top mov  >=  next  ;c
code 0<            top top tst   -1 # top mov 0<   0 # top mov 0>=  next  ;c
code 0=            top top tst   -1 # top mov 0=   0 # top mov ne   next  ;c

comment =========================
               Stack Words

  sp@   pushes the current stack pointer onto the stack.
        If one writes  5 sp@ @ .  one will get 5 printed.
  sp!   resets the stack pointer to its initial value.
  depth pushes the number of stack elements on the stack
        before depth was invoked.
        =========================

code depth   ( -- # )
     'sp0 r3 load-relocated   0 r3 +) r3 ldr
     sp r3 r3 sub   top push   r3 2 #lsr top mov   next ;c

code sp@     ( -- a )
     top push  sp top mov  next ;c

code sp!     ( -- )
     'sp0 r3 load-relocated   0 r3 +) sp ldr
     "0decafbad top load-literal   next ;c



comment =========================
               Intrinsics
        =========================

code lit implements lit
   top push   4 ip )+ top ldr   next  ;c

code (branch) implements (branch)
.ifdef relbranch
   4 ip )+ r0 ldr   r0 ip ip add   next  ;c
.else
   0 ip +) ip ldr   next  ;c
.then

code (0branch) implements (0branch)
   top top tst   top pop
label zbr1
.ifdef relbranch
   4 ip )+ 0 ldr 0=   0 ip ip add 0= ( jump)
.else
   0 ip +) ip ldr 0= ( jump)
.then
   4 # ip ip add ne ( skip)   next  ;c 

code (=0branch) implements (=0branch)
   top top tst   zbr1 b  ;c

code (for) implements (for)
   count nest   top count mov   top pop   next  ;c

code (?for) implements (?for)
   top top tst   top r0 mov   top pop
.ifdef relbranch
   4 ip )+ r0 ldr 0=   r0 ip ip add 0= ( jump)
.else
   0 ip +) ip ldr 0= ( jump)
.then
   next 0= ( !!)
   count nest   r0 count mov   4 # ip ip add   next  ;c

code (next) implements (next)
   1 # count count sub s   count unnest 0=   4 # ip ip add 0=   next 0=
.ifdef relbranch
   4 ip )+ r0 ldr   r0 ip ip add   next  ;c
.else
   0 ip +) ip ldr   next  ;c
.then

code @    0 top +) top ldr   next  ;c
code c@   0 top +) top ldrb  next  ;c

code !    { r0 r1 } ! sp ldm   0 top +) r0 str    r1 top mov   next  ;c
code c!   { r0 r1 } ! sp ldm   0 top +) r0 strb   r1 top mov   next  ;c

code +!   { r0 r1 } ! sp ldm   0 top +) r2 ldr ( @ -> r2)    r0 r2 r0 add
          0 top +) r0 str   r1 top mov   next  ;c

code cell+   4 # top top add   next  ;c
code 1+      1 # top top add   next  ;c
code 1-      1 # top top sub   next  ;c

0 constant 0
1 constant 1
-1 constant -1
2 constant 2

4 constant cell

code cell/  ( n - n/4)   top 2 #asr top mov  next  ;c
code cells  ( n - n*4)   top 2 #lsl top mov  next  ;c

: >     swap <  ;
: 2dup   over  over ;
: 2drop  drop  drop ;
: min   2dup >  if swap then  drop  ;
: max   2dup <  if swap then  drop  ;
: s->d  ( n - d)  ( sign-extend)  dup 0< ;  ( high word on top)
: abs   ( n - |n|)   s->d  if   negate  then ;
: dabs  ( d - |d|)   s->d  if  dnegate  then ;



==========================================================================
Basic dictionary words.
==========================================================================
variable h  ( dictionary pointer)
: here    h @ ;
: allot   h +! ;
: c,  here c!    1 allot ;
: ,   here !  cell allot ;

( Alignment.)
: aligned  [ cell 1- ] +  [ cell negate ] and ;

: compile  r>  dup cell+  >r  @ , ;  ( fig)
: literal  compile lit  , ;

==========================================================================
Basic console output.
==========================================================================
32 constant bl  ( ASCII code for blank - that is, space)
13 constant #CR
10 constant #LF

: emit   ( ch)  sp@  1  type  drop ;
: space   bl emit ;
: spaces  ( n)  0 max  ?for  space  next  then  ;
: cr  #CR emit  #LF emit ;


==========================================================================
Support for compiled strings.
==========================================================================
( Assume that compiled strings are:
    * prefixed with a length byte
    * padded at the end to a cell boundary)

: count  ( z" - a u)  dup 1+  swap c@ ;  ( fig)

( fig combines pulling out the count, skipping over the string and count,
  and type'ing it out all into one word.)
-- : (.")  r@ count  dup 1+ r> + >r  type ; ( fig)

( We could define a similar word, but ours has to skip over the length and
  the trailing padding:)
-- : (.")  r@ count  dup 1+  r> + aligned >r  type ; ( fig)

( Or we could factor differently, and have ." compile (")
( followed by type, in which case we have:)
: (")  ( - a u)  r@ count  dup 1+  r> + aligned >r ;   implements (")

( It all depends on how you want to use your string literals.)

==========================================================================
Making new names in the dictionary.
==========================================================================
variable current
variable .forth.      ( XXX fixed up by metac)
variable .compiler.   ( XXX fixed up by metac)
variable last         ( cfa of last word defined)

code cmove  ( source dest count)  ( UNDEF)  ;c

: code,   here last !  ( make a code field)  0 , ;
: token,  ( a u)  dup 1+ aligned  allot  ( room for name+len+padding)
          dup here 1- c! ( len)  here over 1+ -  swap cmove ;

: link,   here  current @  dup  @  ,  !  ( last-link 2! ) ;

: name,  ( a u)  token,  link,  code, ;

( patch rewrites the bl instruction at cfa to call to 'code.)
: |pc-  ( to from - offset)   8 + ( compensate for prefetch)  - ;
: >branch-offset  ( to from - bits)  |pc-  cell/  "00ffffff and ;
: patch     ( 'code cfa)  tuck >branch-offset  "eb000000 or ( op)
            swap ! ;

comment super-botched
( XXX It's a botch that there are two kinds of (;code) - one that points
  the last word to the code that follows it - currently used by the
  target-resident does> - and one that fetches a literal from the cell that
  follows it - currently used by the meta-compiler to patch the
  target-resident defining words with the code sequences that were defined
  earlier ... when the meta-compiler versions of the defining words were
  defined.

  Got all that? ;-)
super-botched

( (;code@) ( is followed by a literal - a pointer to code - that is used to
  patch the last word. Used by the meta-compiler to point the following
  versions of create, constant, and : to code that was already laid down.)

: (;code@)   r> @  last @  patch ;  implements (;code)

( (;code)  ( patches last to point to the code that directly follows it.
  Compiled by does> , below.)

: (;code)   r>  last @  patch ;

==========================================================================
Target-resident defining words.
==========================================================================
: -]  ;  ( UNDEF)  ( XXX how are we doing compilation state?)

: create    name,      ;code   dovar
: constant  name,  ,   ;code   doconst

: variable  create  cell allot ;

: :         name,  -]  ;code   docolon

target-compiler
: does>   compile (;code)
          [ here  assemble  lr r0 mov  ;c  cell negate allot  @ ] ,
          code,  [ dodoes ] last @ patch ;

target

( Test of nifty dodoes magic.)
meta: konst   create ,  does> @ ;
"5600 konst yippee

==========================================================================
Token parsing.
==========================================================================
( XXX two variables, start and end?)
2variable source  ( start, end)
variable first

( XXX should skip and scan simply read and write first and end?)
( Skip while char at a equals ch and not at end of input.)
code skip  ( end a ch - a+)  ;c  ( UNDEF)

( Scan while char at a doesn't equal ch and not at end of input.)
code scan  ( end a ch - a+ trailing)  ;c  ( UNDEF)

( XXX this code assumes skip and scan do -not- take end as a param)
: (token)   ( last trailing - a u)
   over  first @  - ( count)  >r
   + ( last+trailing)  first @  swap first !  ( consume input)  r> ;

: token  ( - a u)
   first @ bl skip ( leading whitespace)  dup first !
   ( first)   bl scan  (token) ;

: parse  ( ch - a u)
   first @  swap scan  (token) ;

==========================================================================
  Go forth and multiply ... and divide.

  These routines are all based on a handful of low-level primitives:
     um* : u1 u2 - ud  ( all unsigned)
      m* : n1 n2 -  d  ( all signed)
  um/mod : ud  u - urem uquot  ( all unsigned)
  fm/mod :  d  n - mod quot  [signed floored division]

  Any word whose name starts with 'u' is unsigned, both in its arguments
  and its results; the others are signed.

  All of the */ variants calculate a double-length intermediate product.

  To calculate a single-length signed product, calculate a double-length
  _unsigned_ product and drop the high-order word. Weird but true. And an
  extra-credit challenge: is "m* drop" always equal to "um* drop"? Why or
  why not? ;-)

==========================================================================
code um*     ( n1 n2 - ud)
   st1 r0 ldr   top r0 top r0 umull   st1 r0 str  next ;c

code  m*     ( n1 n2 - d)
   st1 r0 ldr   top r0 top r0 smull   st1 r0 str  next ;c


==========================================================================
um/mod  ( ud u -- rem quo)

This algorithm uses long division.  It first attempts to subtract the
divisor from the 64 bit dividend.  If the divisor is bigger than the
dividend (which will be true after the subtraction if the carry is set)
then it unwinds the subtraction.  Else, it sets a bit indicating the 
subtraction was applied, thus building up the quotient.

All this happens by keeping the divisor in the 32 bits of r2 and shifting
the dividend up through the pair (r1:r0).  The high order bit of the
dividend (after the subtraction) will always be 0 (unless the subtraction
needs to be backed out).

Also note that as the dividend is being shifted up, the quotient is formed
in the low order bits of the r0 register.  Each time the subtraction was
successful, the low order bit is set.

After the divisor has been subtracted through the dividend 32 times,
whatever remains in the r1 (the high portion of the dividend) is
necessarily the remainder.
==========================================================================

code um/mod  ( ud  u - urem uquot)  
     top r2 mov   -- Divisor
     st1 r1 ldr   -- Dividend, hi
     st2 r0 ldr   -- Dividend, lo
     32 # r3 mov  -- Loop count
     here

     1  # r0 r0 lsl s -- Shift the dividend
     31 # r1 r1 ror   --

     r1 r2 r1 sub s   -- Subtract divisor into dividend
     1 # r0 or cc     -- Carry clear: Sub OK, tag quotient
     r1 r2 r1 add cs  -- Else, undo subtraction

     
     1 # r3 sub s -- Decrement counter
     b ne         -- Branch until done

     st1 r1 str   -- Remainder
     r0 top mov   -- Quotient
     next  ;c

code fm/mod  (  d  n - mod quot)  ;c  ( UNDEF)

: *       ( n1 n2 - n1*n2)   um*  drop  ;  ( This is what fig does!)

:  */mod  ( n1 n2 n3 - r q)  >r   m*   r>           fm/mod ;
: u*/mod  ( u1 u2 u3 - r q)  >r  um*   r>           um/mod ;

:  /mod   ( n1    n2 - r q)  >r  s->d  r>  (  d1 n2)  fm/mod ;
: u/mod   ( u1    u2 - r q)         0 swap ( ud1 u2)  um/mod ;

:  */     ( n1 n2 n3 - n1*n2/n3)   */mod  nip ;
: u*/     ( u1 u2 u3 - u1*u2/u3)  u*/mod  nip ;

:  /      ( n1 n2 - quot)    /mod  nip ;
: u/      ( u1 u2 - uquot)  u/mod  nip ;

:  mod    ( n1 n2 - mod)     /mod  drop ;
: umod    ( u1 u2 - umod)   u/mod  drop ;


==========================================================================
Numeric conversion - input.
==========================================================================
variable radix   ( the current input & output number base)
variable dpl     ( decimal point location)

: *digit  ( ud a digit - ud*base+digit a)
   swap >r ( a)  swap ( lo dig hi)  radix @ um* drop  rot ( dig hi*radix lo)
   radix @ um*  d+  r>  dpl @ 0< 1+  dpl +!  ;

==========================================================================
Numeric conversion - output.
==========================================================================
: >digit   ( n - ch)  ( convert 1 binary digit to char; hex to uppercase)
   9 over u<  7 and +  [ char 0 ] +  ;

: /digit   ( ud - udquot urem)
   0 radix @ um/mod  ( 0:hi / radix -> urhi uqhi)  >r
   ( urhi:lo)  radix @ um/mod  ( urlo uqlo)  r> rot  ;

( XXX Should we convert numbers by pushing digits onto the stack
  instead?)

( Longest number we can convert is a negative base-2 double-number.)
65 aligned allot here constant pad  ( 64 digits + sign + alignment)

variable hld
: hold   -1 hld +!  hld @ c! ;
: <#     pad hld !  ;
: #>     ( ud - a #)  2drop  hld @  pad over - ;
: sign   ( n -)   0< if  [ char - ] hold  then  ;

: #     ( ud - ud')   /digit  >digit  hold  ;
: #s    ( ud - 0 0)   begin  #  2dup or 0=  until  ;

: (ud.)   ( ud - a #)  <#  #s  #>  ;
: ud.     ( ud -)      (ud.)  type  space  ;

: (u.)    ( u - a #)   0  (ud.)  ;
: u.      ( u -)       (u.)  type  space  ;

: (d.)    ( d - a #)   dup >r ( sign)  dabs  <#  #s  r> sign  #>  ;
: d.      ( d -)       (d.)  type  space  ;

: (.)     ( n - a #)   s->d  (d.)  ;
: .       ( n -)       (.)  type  space  ;

0 .if
( This should truncate to field length. Actually, it shouldn't. Does it?)
( UNUSED)
: truncating-field   ( a c field - a' field)   tuck swap -  ( a field field-c)
   s->d if  drop ^  then  ?for  bl hold  next then  #>  ;
.then

( Non-truncating field.)
: field   ( a c field - a c)  over - spaces  ;

:  (.r)   ( n field - a #)   >r  (.)   r>  field  ;
:   .r    (.r)  type  ;

: (u.r)   ( u field - a #)   >r  (u.)  r>  field  ;
:  u.r    (u.r)  type  ;

( Useful shortcut.)
: ?  @ .  ;

==========================================================================
Support words for compiling control structures.
==========================================================================

( Mark a branch source for later fixup.)
: mark>  ( - src)  here  0 , ;

( Resolve a forward or backward jump, from src to dest.)
( When using absolute branch addresses, this is easy: just store dest at src.)
: <resolve  ( dest src)  ! ;
: resolve>  ( src dest)  swap <resolve ;

target-compiler
: =if   ( - src)        compile (=0branch)  mark> ;
: if    ( - src)        compile  (0branch)  mark> ;
: then  ( src)          here resolve> ;
: else  ( src0 - src1)  compile   (branch)  mark>  swap  \tc then ;

: begin   ( - dest)  here ;
: =until  ( dest -)       \tc =if  <resolve ;
: until   ( dest -)        \tc if  <resolve ;
: again   ( dest -)     compile   (branch)  mark>  <resolve ;
: =while  ( dest - src dest)  \tc =if  swap ;
: while   ( dest - src dest)   \tc if  swap ;
: repeat  ( src dest -)   \tc again  \tc then ;

( n for .. next         goes n times; 2^wordsize if n=0 )
( n ?for .. next then   goes n times; 0 if n=0 )

: for     ( - dest)      compile (for)          \tc begin ;
: ?for    ( - src dest)  compile (?for)  mark>  \tc begin ;
: next    ( dest -)      compile (next)  mark>  <resolve ;

target

comment ===================
        More Stack routines
        ===================

: not     0= ;
: u+  ( a b c - a+c b)  swap >r + r> ;  ( "under-plus")

comment **multitasker**

( How about a multitasker? First we need user variables...)

( Multitask!)

( 15-sep-1998.  This is new.  I figured this all out when I couldn't sleep.
  There is a new [to me] and beautiful way to do multitasking that is in
  between my old way and the elusive polyFORTH brochure's "one machine
  instruction per task" way.  My new way is the middle way, and is intimately
  related to indirect threaded code; the major difference is that it is -not-
  the `canonical Chuck' way to do ITC.  The `word' pointer -- in this case
  it points to a -task- -- points -at- rather than -after- the code pointer.
  It just works out more nicely this way.

  There is a necessary adjustment, however.  In this new way what determines
  whether a task is awake or asleep is its code pointer.  If it points to
  `robin' the task is asleep, and `robin' will cycle to the next task [and
  take only two instructions!].  If the task is awake, its code points to
  `restore', which sets up the user pointer `u' and pops the task's context
  and executes `next', as usual.  The adjustment is this:  where do we store
  the sleep/wakeup count information, which used to be also the awake/asleep
  flag?  The answer is, `where it matters'.  In the case of an i/o queue,
  the `right place' for this information is in the queue, -not- in the task
  that reads from or writes to it.

  In this new world order the tasks or interrupt service routines that used
  to simply increment or decrement a counter have a little bit more work to
  do to wake or lull a task.  But it's not too bad, and the task loop is
  purer, more flexible, and one instruction quicker per task!

  Generally, when a task is using a resource that resource points to the task.
  This has two purposes:  when this pointer is zero, the resource is -free-.
  When non-zero, it points to the task that should be woken when the resource
  is `ready'.  The task points back at some part of the resource, thru the
  `depend' pointer.  Thus if a task is waiting on serial input from a queue,
  the queue -resource- would point to the task; the task's `depend' would
  point to the count of characters available to be read from the queue.  When
  a character comes in from the serial port, the service routine puts the
  character in the queue and increments the count.  It then checks if the
  `depend' pointer has become non-zero, or >0, or whatever the criterion is.
  If so, it wakes the task by changing its `status' code pointer.

  Alternatively the ISR could increment the counter pointed to by the task's
  `depend' pointer.  ISR.owner->task.depend->counter.  These details are a
  bit fuzzy still.)

definer: +user  ( size)
   create  #user \f @ ,  #user \f +!
   ;code   ??
   0 +user status      ( code pointer; determines the wakefulness of the task)
   0 +user me          ( synonym)
cell +user link        ( link to next task in list)
cell +user bottom      ( bottom of D stack)
cell +user top         ( pointer to saved stack)

{
target
0 cells constant status
1 cells constant link
2 cells constant bottom
3 cells constant top
forth
}

( 15-sep-1998.  This is now different; see above.  The idea still applies;
  only the location of the counters has changed.  Well, that and that the
  counters now run `the right way'.

  If a task has an associated IRQ, use STATUS as a sema-
  phore -- use AWAIT to sleep and <task> #] dec, [in IRQ
  routine] to awaken.  Incrementing and decrementing STATUS is
  an atomic action.  In this case only  ACTIVATE ever sets STATUS.
  This will happen before the interrupt is enabled so it's OK.

  In other cases it doesn't matter; however, incrementing and
  decrementing STATUS makes a useful auto-wakeup semaphore.)

( On what other architecture can you write a multitasker loop in 6
  instructions?)

code pause
   { top ct rp lr } ! sp stm                   ( save context on stack)
   ' top ( offset in user area) up +) sp str   ( save stack ptr in user area)

label wait ( robin)
   ' link ( offset)   up +) up ldr  ( follow task link)
   ' status ( offset) up +) pc ldr  ( jump thru status)

label run
   ' top ( offset in user area) up +) sp ldr     ( setup sp)
   { top ct rp pc } ! sp ldm         ( load context and go!)  ;c

**multitasker**


comment =============
        console
        =============

decimal
: pause ;  ( not yet!)
0 .if
: key?   [ uart1 "14 + ] c@  1 and ;
: key   begin  key? 0= while  pause  repeat  [ uart1 ] c@ ;
.then

( Say hello!)
: hi  ." Hello, world."  cr ;

( Printing hex.)
: 16/mod   ( n - q r)  dup 4 u>>   swap 15 and ;

: .   8 for  16/mod >digit swap  next  drop
      8 for  emit  next  space ;

: ?a   dup 15 and 0= if  cr  dup .  space  then ;
: @+   ( a - a+ n)  dup cell+  swap @ ;
: dump  ( a n - a+n)   for  ?a  @+ .  next ;

: echo  begin  key  dup #13 xor while  1+ emit  repeat  drop  cr ;

decimal

: count2  "13579bdf 8 for 16/mod >digit emit  next drop  cr ;

: chars  32  [ 128 32 - ] for  dup emit  1+  next  drop  cr ;

: times  6789 123456 * .   -1029484 485 * .  cr ;

: delay  100_000 for next ;

: doit   echo  times  count2
   begin  chars  delay  again  [

comment =========================
               Warm
        =========================

decimal

comment ===================
        Stack Test Routines
        ===================

: stack-test
  sp@ . sp! sp@ . cr
  depth . sp@ depth . drop depth . cr 
  depth . sp@ . depth . cr
  1 2 3 . . . depth . cr
  depth . 1 2 3 depth . sp@ @ . drop sp@ @ . drop sp@ @ . drop depth . cr 
  ." rotate tests" cr
  1 2 3 . . . cr
  1 2 3 rot       . . .  ." <- should be 1 3 2" cr
  1 2 3 -rot      . . .  ." <- should be 2 1 3" cr
;

: print-eq    ( d -- )
  ." = "  . . cr ;

: mul  ( a b --)
  2dup  over . dup .  ." um* "  um*  print-eq
  2dup  over . dup .  ."  m* "  um*  print-eq
        over . dup .  ."   * "    *  ." = " . cr ;

: mul-test
  1 2            mul
  100000 100000  mul
  -1 10000       mul
  10000 -1       mul
  -1 -1          mul
  0  -1          mul
  -1  0          mul
;

: warm
  h !   hi  mul-test   stack-test   0 bye ;

0 .if
code _boot   # rp mov  # sp mov   ' doit b  ;c
' _boot { 'boot !
.then

#]file
