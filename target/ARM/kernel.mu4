( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2010 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

" ARM kernel "  file[#

( 2010-feb-03 - Heavily modified! and changed to DTC.)
( 2006-apr-01.)

assembler hex

( Register usage.)
comment moved-from-assembler
 09 constant top ( t)  ( data stack top)
 0a constant ct  ( c)  ( for loop count reg)
 0b constant up  ( u)  ( user pointer; for multitasking!)
 0c constant sp  ( s)  ( data stack pointer)
 0d constant rp  ( r)  ( return stack pointer)
moved-from-assembler

7 constant count  ( for for/next loops)
6 constant top
5 constant rp
4 constant ip

macro: push  ( r)  4 sp -) !  \f swap  str  ;
macro: pop   ( r)  4 sp )+    \f swap  ldr  ;

macro: nest    ( r)  4 rp -) !  \f swap  str  ;
macro: unnest  ( r)  4 rp )+    \f swap  ldr  ;

( top is considered st0)
macro: st1   0 sp +)  ;  ( address the second item on the stack)
macro: st2   4 sp +)  ;  ( address the third item on the stack)
macro: st3   8 sp +)  ;  ( address the fourth item on the stack)

macro: next  4 ip )+ pc ldr  ;

( capture compiles a branch-and-link -over- the following cell; it captures
  the address of the following cell in lr)
macro: capture   here 8 \f +  bl  ;

( lr@ loads the cell at lr into a reg)
macro: lr@  ( reg)   0 lr +)  \f swap ( reg)  ldr  ;

macro: load-relocated  ( lit reg)   capture   \f swap a, ( lit)   lr@  ;
macro: load-literal    ( lit reg)   capture   \f swap ,  ( lit)   lr@  ;

macro: blr ( reg)  ( bl thru a register)
     pc lr mov  ( capture return address - beyond following instruction)
     ( reg) pc mov  ( jump via reg)  ;


comment =====================================================================
        The real kernel starts here!!
        =====================================================================

__meta

target  ( compile into target vocab)

1 , ( Kernel/C API interface structure version) 

0 a, ( start address of FORTH Kernel will be patched later)

0 a, ( ip0)
0 a, ( rp0)
0 a, ( h0    - will be loaded into top)
0 a, ( sp0)

label callers-set-jmp-context
0 ,   ( r0 -- caller's set jmp context address)
0 ,   ( pc -- caller's long jmp routine address)

label 'type  -- pointer to C function: void type(char *s, int n)
0 ,
label '?key       -- ptr to C: cell_t qkey(void)
0 ,
label 'key        -- ptr to C: cell_t key(void)
0 ,
label 'readline   -- ptr to C: ??? readline(???)
0 ,
label 'getfile    -- ptr to C: ??? getfile(???)
0 ,

code bye
     callers-set-jmp-context r3 load-relocated
     { r0 pc } r3 ldm  ;c

code type ( a u -- )   implements type
     'type r3 load-relocated   top r1 mov   r0 pop   r3 blr
     top pop   next  ;c

code ?key ( - f)
     '?key r3 load-relocated
label key-call
     r3 blr   top push   r0 top mov   next  ;c

code key ( - ch)
     'key r3 load-relocated   key-call b  ;c

code readline  ( ???)  next  ;c
code getfile  ( ???)  next  ;c


definer: create    new     ;code   top push   lr top mov        next  ;c
definer: constant  new  ,  ;code   top push   0 lr +) top ldr   next  ;c

definer: variable  create  cell allot ;

definer: :         new  -]  ;code   ip nest   lr ip mov   next  ;c

( Explanation of dodoes: child word executes bl to parent; lr points to
  child's data; parent saves lr in r0; executes bl to dodoes; lr points to
  list of forth words to execute.)

( XXX This is subject to change, when I figure out a better way. Right now
  the deep subtlety of the problem is making my head spin. ;-)

( Note that this isn't -really- a CODE word. If this were an ITC forth,
  we'd have to define this differently. We're using code here because it
  does what we want: creates a new name, and turns on the assembler -
  without compiling a code field.)

code dodoes implements dodoes
   ip nest   lr ip mov
   top push  r0 top mov   next  ;c


code ^ implements ^
   ip unnest   next  ;c

code +     r0 pop   top r0 top add   next  ;c
code -     r0 pop   top r0 top sub   next  ;c
code *     r0 pop   r0 top top mul   next  ;c
code and   r0 pop   top r0 top and   next  ;c
code bic   r0 pop   top r0 top bic   next  ;c
code or    r0 pop   top r0 top or    next  ;c
code xor   r0 pop   top r0 top eor   next  ;c

code negate   0 # top top rsb   next  ;c
code invert       top top mvn   next  ;c

code dup   top push  next  ;c
code nip   r0  pop   next  ;c
code drop  top pop   next  ;c

code swap  top r0 mov   st1 top ldr   st1 r0 str  next  ;c
code over  top push     st2 top ldr   next  ;c

( XXX Is this right?)
code rot  ( r1 r0 top - r0 top r1)
   { r1 r0  } sp ldm   r0 lr mov
   { lr top } sp stm
   r1 top mov next  ;c

( XXX Is this right?)
code -rot  ( r1 r0 top - top r1 r0)
   { r1 r0  } sp ldm
   { top r1 } sp stm
   r0 top mov next ;c

code <<       r0 pop   r0 top lsl top mov   next  ;c
code >>       r0 pop   r0 top asr top mov   next  ;c
code u>>      r0 pop   r0 top lsr top mov   next  ;c
code rotate   r0 pop   r0 top ror top mov   next  ;c

code 2/    top 1 #asr top mov  next  ;c
code u2/   top 1 #lsr top mov  next  ;c
code 2*    top 1 #lsl top mov  next  ;c

code u<    r0 pop  top r0  cmp   -1 # top mov u<   0 # top mov u>=  next  ;c
code <     r0 pop  top r0  cmp   -1 # top mov  <   0 # top mov  >=  next  ;c
code 0<            top top tst   -1 # top mov 0<   0 # top mov 0>=  next  ;c
code 0=            top top tst   -1 # top mov 0=   0 # top mov ne   next  ;c

code lit implements lit
   top push   4 lr )+ top ldr   next  ;c

code (branch) implements (branch)
.ifdef relbranch
   4 ip )+ r0 ldr   r0 ip ip add   next  ;c
.else
   0 ip +) ip ldr   next  ;c
.then

code (0branch) implements (0branch)
   top top tst   top pop
label zbr1
.ifdef relbranch
   4 ip )+ 0 ldr 0=   0 ip ip add 0= ( jump)
.else
   0 ip +) ip ldr 0= ( jump)
.then
   4 # ip ip add ne ( skip)   next  ;c 

code (=0branch) implements (=0branch)
   top top tst   zbr1 b  ;c

code (for) implements (for)
   count nest   top count mov   top pop   next  ;c

code (?for) implements (?for)
   top top tst   top r0 mov   top pop
.ifdef relbranch
   4 ip )+ r0 ldr 0=   r0 ip ip add 0= ( jump)
.else
   0 ip +) ip ldr 0= ( jump)
.then
   next 0= ( !!)
   count nest   r0 count mov   4 # ip ip add   next  ;c

code (next) implements (next)
   1 # count count sub s   count unnest 0=   4 # ip ip add 0=   next 0=
.ifdef relbranch
   4 ip )+ r0 ldr   r0 ip ip add   next  ;c
.else
   0 ip +) ip ldr   next  ;c
.then

code >r   top nest   top pop      next  ;c
code r>   top push   top unnest   next  ;c
code r@   top push   0 rp +) top ldr   next  ;c

code @    0 top +) top ldr   next  ;c
code c@   0 top +) top ldrb  next  ;c

code !    { r0 r1 } ! sp ldm   0 top +) r0 str    r1 top mov   next  ;c
code c!   { r0 r1 } ! sp ldm   0 top +) r0 strb   r1 top mov   next  ;c

code +!   { r0 r1 } ! sp ldm   0 top +) r2 ldr ( @ -> r2)    r0 r2 r0 add
          0 top +) r0 str   r1 top mov   next  ;c

code cell+   4 # top top add   next  ;c
code 1+      1 # top top add   next  ;c
code 1-      1 # top top sub   next  ;c

0 constant 0
1 constant 1
-1 constant -1
2 constant 2

4 constant cell

variable h  ( dictionary pointer)
: here    h @ ;
: allot   h +! ;
: c,  here c!    1 allot ;
: ,   here !  cell allot ;

( Alignment.)
: aligned  [ cell 1- ] +  [ cell negate ] and ;

: compile  r>  dup cell+  >r  @ , ;  ( fig)
: literal  compile lit  , ;

( Words for compiled strings.)

( Assume that compiled strings are:
    * zero-terminated
    * prefixed with a length byte
    * padded at the end to a cell boundary)

: count  ( z" - a u)  dup 1+  swap c@ ;  ( fig)

( fig combines pulling out the count, skipping over the string and count,
  and type'ing it out all into one word.)
-- : (.")  r@ count  dup 1+ r> + >r  type ; ( fig)

( We could define a similar word, but ours has to skip over the zero
  terminator and any trailing padding:)
-- : (.")  r@ count  dup 2 +  r> + aligned >r  type ; ( fig)

( Or we could factor differently, and have ." compile (")
( followed by type, in which case we have:)
: (")  ( - a u)  r@ count  dup 2 +  r> + aligned >r ;   implements (")

( It all depends on how you want to use your string literals.)

( Let's try it!)
: hi  ." Hello world!" ;


( Support words for compiling control structures.)

( Mark a branch source for later fixup.)
: mark>  ( - src)  here  0 , ;

( Resolve a forward or backward jump, from src to dest.)
( When using absolute branch addresses, this is easy: just store dest at src.)
: <resolve  ( dest src)  ! ;
: resolve>  ( src dest)  swap <resolve ;

target-compiler
: =if   ( - src)        compile (=0branch)  mark> ;
: if    ( - src)        compile  (0branch)  mark> ;
: then  ( src)          here resolve> ;
: else  ( src0 - src1)  compile   (branch)  mark>  swap  \tc then ;

: begin   ( - dest)  here ;
: =until  ( dest -)       \tc =if  <resolve ;
: until   ( dest -)        \tc if  <resolve ;
: again   ( dest -)     compile   (branch)  mark>  <resolve ;
: =while  ( dest - src dest)  \tc =if  swap ;
: while   ( dest - src dest)   \tc if  swap ;
: repeat  ( src dest -)   \tc again  \tc then ;

( n for .. next         goes n times; 2^wordsize if n=0 )
( n ?for .. next then   goes n times; 0 if n=0 )

: for     ( - dest)      compile (for)          \tc begin ;
: ?for    ( - src dest)  compile (?for)  mark>  \tc begin ;
: next    ( dest -)      compile (next)  mark>  <resolve ;

comment **multitasker**

( How about a multitasker? First we need user variables...)

( Multitask!)

( 15-sep-1998.  This is new.  I figured this all out when I couldn't sleep.
  There is a new [to me] and beautiful way to do multitasking that is in
  between my old way and the elusive polyFORTH brochure's "one machine
  instruction per task" way.  My new way is the middle way, and is intimately
  related to indirect threaded code; the major difference is that it is -not-
  the `canonical Chuck' way to do ITC.  The `word' pointer -- in this case
  it points to a -task- -- points -at- rather than -after- the code pointer.
  It just works out more nicely this way.

  There is a necessary adjustment, however.  In this new way what determines
  whether a task is awake or asleep is its code pointer.  If it points to
  `robin' the task is asleep, and `robin' will cycle to the next task [and
  take only two instructions!].  If the task is awake, its code points to
  `restore', which sets up the user pointer `u' and pops the task's context
  and executes `next', as usual.  The adjustment is this:  where do we store
  the sleep/wakeup count information, which used to be also the awake/asleep
  flag?  The answer is, `where it matters'.  In the case of an i/o queue,
  the `right place' for this information is in the queue, -not- in the task
  that reads from or writes to it.

  In this new world order the tasks or interrupt service routines that used
  to simply increment or decrement a counter have a little bit more work to
  do to wake or lull a task.  But it's not too bad, and the task loop is
  purer, more flexible, and one instruction quicker per task!

  Generally, when a task is using a resource that resource points to the task.
  This has two purposes:  when this pointer is zero, the resource is -free-.
  When non-zero, it points to the task that should be woken when the resource
  is `ready'.  The task points back at some part of the resource, thru the
  `depend' pointer.  Thus if a task is waiting on serial input from a queue,
  the queue -resource- would point to the task; the task's `depend' would
  point to the count of characters available to be read from the queue.  When
  a character comes in from the serial port, the service routine puts the
  character in the queue and increments the count.  It then checks if the
  `depend' pointer has become non-zero, or >0, or whatever the criterion is.
  If so, it wakes the task by changing its `status' code pointer.

  Alternatively the ISR could increment the counter pointed to by the task's
  `depend' pointer.  ISR.owner->task.depend->counter.  These details are a
  bit fuzzy still.)

definer: +user  ( size)
   create  #user \f @ ,  #user \f +!
   ;code   ??
   0 +user status      ( code pointer; determines the wakefulness of the task)
   0 +user me          ( synonym)
cell +user link        ( link to next task in list)
cell +user bottom      ( bottom of D stack)
cell +user top         ( pointer to saved stack)

{
target
0 cells constant status
1 cells constant link
2 cells constant bottom
3 cells constant top
forth
}

( 15-sep-1998.  This is now different; see above.  The idea still applies;
  only the location of the counters has changed.  Well, that and that the
  counters now run `the right way'.

  If a task has an associated IRQ, use STATUS as a sema-
  phore -- use AWAIT to sleep and <task> #] dec, [in IRQ
  routine] to awaken.  Incrementing and decrementing STATUS is
  an atomic action.  In this case only  ACTIVATE ever sets STATUS.
  This will happen before the interrupt is enabled so it's OK.

  In other cases it doesn't matter; however, incrementing and
  decrementing STATUS makes a useful auto-wakeup semaphore.)

( On what other architecture can you write a multitasker loop in 6
  instructions?)

code pause
   { top ct rp lr } ! sp stm                   ( save context on stack)
   ' top ( offset in user area) up +) sp str   ( save stack ptr in user area)

label wait ( robin)
   ' link ( offset)   up +) up ldr  ( follow task link)
   ' status ( offset) up +) pc ldr  ( jump thru status)

label run
   ' top ( offset in user area) up +) sp ldr     ( setup sp)
   { top ct rp pc } ! sp ldm         ( load context and go!)  ;c

**multitasker**


comment **console**

: pause ;  ( not yet!)
: emit   ( ch)
   begin  [ uart1 "14 + ] c@ "20 and  0= while  pause  repeat
   [ uart1 ] c! ;

: key?   [ uart1 "14 + ] c@  1 and ;
: key   begin  key? 0= while  pause  repeat  [ uart1 ] c@ ;

: cr  13 emit  10 emit ;
: space  32 emit ;

( Printing hex.)
: >digit   ( n - ch)  ( convert 1 binary digit to char; hex to uppercase)
   9 over u<  7 and +  [ char 0 ] +  ;

: 16/mod   dup 4 u>>   swap 15 and ;

: .   8 for  16/mod >digit swap  next  drop
      8 for  emit  next  space ;

: ?a   dup 15 and 0= if  cr  dup .  space  then ;
: @+  dup 4 +  swap @ ;
: dump  ( a n - a+n)   for  ?a  @+ .  next ;
: 1+  1 + ;

: echo  begin  key  dup #13 xor while  1+ emit  repeat  drop  cr ;

decimal

: count2  "13579bdf 8 for 16/mod >digit emit  next drop  cr ;

: chars  32  [ 128 32 - ] for  dup emit  1+  next  drop  cr ;

: times  6789 123456 * .   -1029484 485 * .  cr ;

: delay  100_000 for next ;

: doit   echo  times  count2
   begin  chars  delay  again  [

**console**

0 .if
code _boot   # rp mov  # sp mov   ' doit b  ;c
' _boot { 'boot !
.then

#]file
