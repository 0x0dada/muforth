( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2010 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

" ARM meta compiler (one) "  file[#

forth  decimal

( Metacompiler vocabs)

( .meta. is where meta-compiler specific words go - esp if they would
  otherwise shadow a host word of the same name. @ is a good example - the
  meta version write into the target image, using a local, image-relative
  address. .meta. contains special versions of : , variables associated
  with resolving forward references in the meta-compiler, and any labels or
  equates defined inside code words.

  .assembler. contains definitions of instructions, registers, addressing
  modes, and words to build control structures. It is searched when
  building code words, and also when compiling macros.

  .definer. is like .compiler. It contains special versions of [ ; and also
  words like ;code and does> which are useful for building defining words.
  .definer. is searched both when we execute the __definer colon compiler -
  used to make new defining words - and also when compiling assembler
  macros.

  .meta-compiler. is like .definer. but for the -target- colon compiler. This
  will contain target versions of [ ; if then begin while etc. It is sealed
  since we don't want to get any host words by accident.)

sealed .meta.             ( the `meta' version of .forth.)
sealed .meta-compiler.    ( the `meta' version of .compiler.)
sealed .assembler.        ( the host-resident target assembler)
sealed .definer.          ( compiler words specific to target defining words)

( Chains created with parallel have an extra field, which points directly
  into the meta-compiled at the heads compiled there, rather than linking
  to the heads in muFORTH's dictionary.)

: parallel  sealed  0 , ( parallel link field) ;

parallel .target.           ( the target words - like `forth' on the host)
parallel .target-compiler.  ( the target-resident compiler words -
                              .target-compiler. is to .target.
                                 as  .compiler. is to .forth. )

: meta                        .meta. definitions ;
: meta-compiler      .meta-compiler. definitions ;
: assembler              .assembler. definitions ;
: definer                  .definer. definitions ;
: target                    .target. definitions ;
: target-compiler  .target-compiler. definitions ;

compiler
: \m   ( compile from meta)                        .meta. \chain ;
: \mc  ( compile from meta-compiler)      .meta-compiler. \chain ;
-- : \a   ( compile from assembler)              .assembler. \chain ;
: \d   ( compile from definer)                  .definer. \chain ;
-- : \t   ( compile from target)                    .target. \chain ;
meta-compiler
: \tc  ( compile from target-compiler)  .target-compiler. \chain ;

forth
( The various token consumers for each mode.)

( Note: There is a subtle difference between the search orders for
  assembling and making assembler macros. When compiling macros we need the
  special ; from .definer. that exits back to __meta, so we search .definer.
  first. We also need comment words and such, so we have to put .compiler.
  on the menu. But we search it -after- we search .assembler.

  We do this because .assembler. contains words to build control structures
  - if/then, begin/while/repeat - in assembler. We want these versions to
  "trump" the ones that the host colon would normally find.

  __asm mode will find the assembler versions just fine; it doesn't look in
  .compiler. at all, so there is no confusion. But when making a macro, since
  .compiler. is searched -after- .assembler. , to get to the host colon
  compiler's if/then and friends you have to use \ .)

-:  ."  (assembling)"  ;
-:
    .assembler. find  if  execute  ^  then
         .meta. find  if  execute  ^  then  ( equates are in .meta.)
        .forth. find  if  execute  ^  then  ( utility words in .forth.)
                                            number ;
mode __asm


-:  ."  (compiling an assembler macro)"  ;
-:
      .definer. find  if  execute  ^  then  ( special compiler words ...)
    .assembler. find  if  compile, ^  then  ( the assembler's if/then/begin ...)
     .compiler. find  if  execute  ^  then  ( ... trump the compiler's)
         .meta. find  if  compile, ^  then  ( equates are in .meta.)
        .forth. find  if  compile, ^  then  ( utility words in .forth.)
                                            number literal ;
mode __macro


( The meta-interpreter. We're in this mode when we're building the target
  image, and when in between [ and ] when running the target colon
  compiler.)

-:  ."  (meta)"  ;
-:
         .meta. find  if  execute  ^  then
        .forth. find  if  execute  ^  then
                                            number ;
mode __meta


( __definer is for compiling new words that are part of the meta-compiler.
  __definer is to __meta as __macro is to __asm.)

-:  ."  (compiling a meta defining word)" ;
-:
      .definer. find  if  execute  ^  then  ( special compiler words ...)
     .compiler. find  if  execute  ^  then  ( ... trump the host compiler's)
         .meta. find  if  compile, ^  then
        .forth. find  if  compile, ^  then  ( utility words in .forth.)
                                            number literal ;
mode __definer


variable 'target-number   ( convert token to a number, specific to target)
variable 'target-literal  ( compile a target literal)

( Finally, we have the definition of the meta-compiler's colon compiler.)

( Execution behaviour of .target. words is to compile themselves!)
-:  ."  (compiling a target colon word)"  ;
-:  .meta-compiler. find  if  execute  ^  then
           .target. find  if  execute  ^  then
           'target-number @execute  'target-literal @execute ;
mode __meta-colon


( Common things we'll always want when meta-colon compiling.)
meta-compiler
: (     \f ( ;   ( comments are nice!)
: --    \f -- ;  ( ditto!)

: .if      \ .if   ;  ( and conditional compilation is nice too)
: .else    \ .else ;
: .then    \ .then ;
: .ifdef   \ .ifdef ;
: .ifndef  \ .ifndef ;
: .def     \ .def ;

meta
: {    \ [ ;  ( escape back to the host forth)
: \f               ' execute ;  ( execute a forth word from meta)
forth
: }    __meta ;  ( return to meta)
: \m   .meta. chain' execute ;  ( execute a meta word from forth)

#]file
