( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2010 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)


( A startup file analogous to muforth's startup file. It expands the
  capabilities of a bare-bones ARM kernel so that it can be used
  interactively.)

==========================================================================
Make searching vocab chains easier.
==========================================================================

( Roll tokenizing and searching into one.)
: token'  ( chain - a u 0 | cfa -1)   token  rot  find ;

: huh?  ( flag)  if ^ then  complain;

: chain'   token'  huh?  ;
: \chain   chain'  , ;  ( compile a word from a particular chain)

( XXX .forth. or current?)  
: '     .forth. chain' ;
-- : '     current @ chain' ;
compiler
: [']   '  literal ;
: \     .compiler. \chain ;
forth


==========================================================================
Setting defer'd words and values.
==========================================================================

( Fixing up defer'ed words.)
: now  ' ;
: is   ' cell+ ( >body) ! ;   ( Usage: now (number) is number )
: to   is ; ( assigning to values is the same!)


==========================================================================
Support words for compiling control structures.
==========================================================================

( Mark a branch source for later fixup.)
: >mark  ( - src)  here  0 , ;

( Resolve a forward or backward jump, from src to dest.)
( When using absolute branch addresses, this is easy: just store dest at src.)
: <resolve  ( dest src)  ! ;
: >resolve  ( src dest)  swap <resolve ;

compiler
: =if   ( - src)        compile (=0branch)  >mark ;
: if    ( - src)        compile  (0branch)  >mark ;
: then  ( src)          here >resolve ;
: else  ( src0 - src1)  compile   (branch)  >mark  swap  \ then ;

: begin   ( - dest)  here ;
: =until  ( dest -)       \ =if  <resolve ;
: until   ( dest -)        \ if  <resolve ;
: again   ( dest -)     compile   (branch)  >mark  <resolve ;
: =while  ( dest - src dest)  \ =if  swap ;
: while   ( dest - src dest)   \ if  swap ;
: repeat  ( src dest -)   \ again  \ then ;

( n for .. next         goes n times; 2^wordsize if n=0 )
( n ?for .. next then   goes n times; 0 if n=0 )

: for     ( - dest)      compile (for)          \ begin ;
: ?for    ( - src dest)  compile (?for)  >mark  \ begin ;
: next    ( dest -)      compile (next)  >mark  <resolve ;

( do, loop, +loop)
: do      ( - src dest)   compile (do)     >mark  \ begin ;
: loop    ( src dest)     compile (loop)   >mark  <resolve  \ then ;
: +loop   ( src dest)     compile (+loop)  >mark  <resolve  \ then ;
forth


==========================================================================
Fancy math operators.
==========================================================================
:  */mod  ( n1 n2 n3 - r q)  >r   m*   r>             fm/mod ;
: u*/mod  ( u1 u2 u3 - r q)  >r  um*   r>             um/mod ;

:  /mod   ( n1    n2 - r q)  >r  s->d  r>  (  d1 n2)  fm/mod ;
: u/mod   ( u1    u2 - r q)         0 swap ( ud1 u2)  um/mod ;

:  */     ( n1 n2 n3 - n1*n2/n3)   */mod  nip ;
: u*/     ( u1 u2 u3 - u1*u2/u3)  u*/mod  nip ;

:  /      ( n1 n2 - quot)    /mod  nip ;
: u/      ( u1 u2 - uquot)  u/mod  nip ;

:  mod    ( n1 n2 - mod)     /mod  drop ;
: umod    ( u1 u2 - umod)   u/mod  drop ;


==========================================================================
Numeric conversion - input.
==========================================================================
variable radix   ( the current input & output number base)
variable dpl     ( decimal point location)

: base   radix ;  ( Compatibility)

: radixer  constant  does> @  radix ! ;

( In order to keep this compilable by the target -before- it knows how to
  parse numbers - which is what we're defining now! - let's keep the
  calculated constants. I thought of converting - and in fact started to
  convert - these to numbers that the -metacompiler- could parse and
  compile, but that limits us to loading this code -only- via the
  metacompiler. I like the idea that the target is going to bootstrap
  itself!)

2 2* 2* dup 2* ( 16!)  radixer hex
dup            (  8!)  radixer octal
2 +            ( 10!)  radixer decimal
2                      radixer binary

decimal
( On and off)
: on  -1 swap !  ;
: off  0 swap !  ;

( Punctuation in numbers: sign, radix, decimal point, separators.)
: punct  ( a u ch - a' u' matched)
   over if ( still chars to process)  swap >r  over c@  xor if
   ( no match)  r>            0 ^  then  ( return false)
   ( match)     r>  1 -1 v+  -1 ^  then  ( a+1 u-1 true)
   ( end of input)  drop  r> drop ;      ( return to caller's caller!)

: ?sign  char - punct ;

: ?radix
        char " punct  if  hex ^  then
        char # punct  if  decimal ^  then
        char ' punct  if  octal ^  then
        char % punct  if  binary ^  then ;

( . resets dpl; others leave it unchanged; this means that embedding . in a
  number causes a double number to be pushed, and dpl set to the count of
  digits _after_ the _last_ . in the number.)

: punctuation
.ifdef debug-number-input
        cr ." punctuation "  .s
.then
        char . punct  if  dpl off  ^  then
        char , punct  if   ^  then
        char - punct  if   ^  then
        char / punct  if   ^  then
        char : punct  if   ^  then
        char _ punct  if   ^  then  complain ;

: digit?    ( ch - digit -1 | junk 0)
   char 0 -  [ 2 2* 2* 1+ ]  ( 9)   over u< if  ( !decimal)
          [ 2 2* 2* 2* 1+ ]  ( 17)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, UPPERCASE)
          [ 2 2* 2* 2* 2* ]  ( 32)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, lowercase)
      ( junk)  0 ^
   then  then  ( hex) [ 2 2* 1+ 2* ]  ( 10) +  then  ( decimal)
   dup radix @  u<  ;

: @digit?   ( a - a digit -1 | a junk 0)   dup c@  digit?  ;

: *digit  ( ud a digit - ud*base+digit a)
   swap >r ( a)  swap ( lo digit hi)
   radix @ um*  drop  rot ( digit hi*radix lo)
   radix @ um*            ( digit hi*radix lo*radix_lo lo*radix_hi)
   d+
   r>  dpl @ 0< 1+  dpl +! ;  ( increment dpl if dpl >= 0)

: convert  ( ud a count - ud' a+ count-)
           ( a+ is first unconvertible char)
.ifdef debug-number-input
   cr ." convert "  .s
.then
   =if  for  @digit?  while  *digit  1+  next  0 ^
                      then  drop ( non-digit)  r> ( count-)
   then  ( 0) ;

: digits   ( ud a count - ud' a+ count- #converted)
.ifdef debug-number-input
   cr ." digits " .s
.then
   dup >r ( chars left)  convert  r> over - ( count of digits converted) ;

: (number)  ( a u - d)
   radix preserve
   >r >r  0 0  r> r>  ?radix  ?sign >r
   0 >r ( #digits converted)  dpl on
   begin  digits  r> + >r  =while  punctuation  repeat  2drop ( a u)
   r> ( #digits)  0= if  r> drop complain  then
   r> ( sign)  if dnegate then  ( apply saved sign) ;

( Connect to the token consumers.)

 now (number)             is number
-:   (number) literal ;   is number,

==========================================================================
Numeric conversion - output.
==========================================================================
: >digit   ( n - ch)  ( convert 1 binary digit to char; hex to uppercase)
   9 over u<  7 and +  [ char 0 ] +  ;

: /digit   ( ud - udquot urem)
   0 radix @ um/mod     ( 0:hi / radix -> urhi uqhi)  >r
     radix @ um/mod  ( urhi:lo / radix -> urlo uqlo)  r> rot  ;

: s->d  ( n - d)  ( sign-extend)  dup 0< ;  ( high word on top)
: dabs  ( d - |d|)   s->d  if  dnegate  then ;

( XXX Should we convert numbers by pushing digits onto the stack
  instead?)

( Longest number we can convert is a negative base-2 double-number.)
65 aligned allot here constant pad  ( 64 digits + sign + alignment)

variable hld
: hold   -1 hld +!  hld @ c! ;
: <#     pad hld !  ;
: #>     ( ud - a #)  2drop  hld @  pad over - ;
: sign   ( n -)   0< if  [ char - ] hold  then  ;

: #     ( ud - ud')   /digit  >digit  hold  ;
: #s    ( ud - 0 0)   begin  #  2dup or 0=  until  ;

: (ud.)   ( ud - a #)  <#  #s  #>  ;
: ud.     ( ud -)      (ud.)  type  space  ;

: (u.)    ( u - a #)   0  (ud.)  ;
: u.      ( u -)       (u.)  type  space  ;

: (d.)    ( d - a #)   dup >r ( sign)  dabs  <#  #s  r> sign  #>  ;
: d.      ( d -)       (d.)  type  space  ;

: (.)     ( n - a #)   s->d  (d.)  ;
: .       ( n -)       (.)  type  space  ;

0 .if
( This should truncate to field length. Actually, it shouldn't. Does it?)
( UNUSED)
: truncating-field   ( a c field - a' field)   tuck swap -  ( a field field-c)
   s->d if  drop ^  then  ?for  bl hold  next then  #>  ;
.then

( Non-truncating field.)
: spaces  ( n)  0 max  ?for  space  next  then  ;
: field   ( a c field - a c)  over - spaces  ;

:  (.r)   ( n field - a #)   >r  (.)   r>  field  ;
:   .r    (.r)  type  ;

: (u.r)   ( u field - a #)   >r  (u.)  r>  field  ;
:  u.r    (u.r)  type  ;

( Useful shortcut.)
: ?  @ .  ;


==========================================================================
Utility.
==========================================================================
: >     swap <  ;
: min   2dup >  if swap then  drop  ;
: max   2dup <  if swap then  drop  ;
: abs   ( n - |n|)   s->d  if   negate  then ;

