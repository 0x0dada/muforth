( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading ARM v6-M Thumb2 assembler

( Core of ARMv6-M assembler - for Cortex-M0, M0+, M3, and M4)

hex

( XXX Idea for solving the postfix S problem: when searching .assembler. ,
  first search for token; if found, great; if not, and token ends in 's',
  search again for token with length smaller by one char!

  The opcodes that can end in 's' should be in .assembler. _without_ the 's'.)

: 4#  # # # # ;
: __  char _ hold ;
: debug-show   dup  radix preserve  binary  <# 4# __ 4# __ 4# __ 4# #>  cr  type ;

: op,  debug-show  \m h, ;

( Make these create/does words so it's easy to change their behaviour.)
: reg   constant  ( regnum)  does> @ ;
assembler
#15 reg pc
#14 reg lr
#13 reg sp
#12 reg r12
#11 reg r11
#10 reg r10
  9 reg r9
  8 reg r8
  7 reg r7
  6 reg r6
  5 reg r5
  4 reg r4
  3 reg r3
  2 reg r2
  1 reg r1
  0 reg r0

forth

( Many of these instructions only allow the use of the low registers - r0
  to r7. Make sure we're doing the right thing.)

: ?low  ( reg op - op reg)
   over 8 u< if  swap  ^  then
   error" only registers r0 to r7 allowed" ;

( These are named to suggest where they would put the 3-bit field if the
  instruction is in octal.)
: r00   ( reg op - op')  ?low  6 <<  or ;
: 0r0   ( reg op - op')  ?low  3 <<  or ;
: 00r   ( reg op - op')  ?low        or ;

( Like above, but shifted 8 bits left. The octal metaphor doesn't work here!)
: r000  ( reg op - op')  ?low  8 <<  or ;

( For building opcodes with 4-bit register field, R.)
: 0R  ( reg op - op')  ( R -> r0_000_rrr)
   over  8 and  4 << or
   swap 07 and       or ;

: R0  ( reg op - op')  ( R -> 0r_rrr_000)
   swap  0f and  3 <<  or ;

( Register lists (masks)
: >mask  ( n - 2^n)  1 swap << ;

assembler
feebfeeb constant {  ( - mark)
: }    ( mark Rx .. Ry - mask)
   0 ( mask)   begin  over \a { xor while  swap >mask or  repeat  nip
   0ffff and ;

( Mark immediate values by pushing a negative number on top of them. This
  way we can distinguish between immediate and register values, which are
  always >= 0.)

: #   ( imm - imm -1)  -1 ;

forth

: imm?  ( bits - is-imm)  0< ;


( Offsets.)
: hoff  ( off op - off/2 op)  swap  2/    swap ;
: woff  ( off op - off/4 op)  swap  2 >>  swap ;

( Tests to see if a value fits into a field of a certain bit width.)
: ufits?  ( value bits - f)     u>>        0= ;   ( unsigned)
: sfits?  ( value bits - f)   1- >>  1+  2 u< ;   ( signed)

( Immediate fields)
: ifits  ( imm op #bits - op bits)
   rot swap  ( op imm #bits)  2dup ufits? if  >mask 1-  and  ^  then
   error" immediate value too large" ;

: i5  ( imm op)  5 ifits  6 <<  or ;
: i3  ( imm op)  3 ifits  6 <<  or ;
: i8  ( imm op)  8 ifits        or ;
: i7  ( imm op)  7 ifits        or ;


( Shift-immed register - low register only!)
: sh-imm  constant  does> @  ( i5 Rm Rd op)  00r  0r0  i5  op, ;
0000 sh-imm lsli
0800 sh-imm lsri
1000 sh-imm asri

( 3 register instructions - low registers only!)
: 3reg  constant  does> @  ( Rm Rn Rd op)  00r  0r0  r00  op, ;
1800 3reg addr3
1a00 3reg subr3

( 3 bit immediate - low registers only!)
: 2reg-i3  constant  does> @  ( i3 Rn Rd op)  00r  0r0  i3  op, ;
1c00 2reg-i3 addi3
1e00 2reg-i3 subi3

( 8 bit immediate - low registers only!)
: 1reg-i8  constant  does> @  ( i8 Rd op)  r000  i8  op, ;
2000 1reg-i8 movi8
2800 1reg-i8 cmpi8
3000 1reg-i8 addi8
3800 1reg-i8 subi8

( Data processing, low registers only!)
: 2reg   constant  does> @  ( Rm Rdn op)  00r  0r0  op, ;

4080 2reg lslr
40c0 2reg lsrr
4100 2reg asrr
4280 2reg cmpr

assembler
4000 2reg ands
4040 2reg eors
( lsls, lsrs, asrs, cmp register go here)
4140 2reg adcs
4180 2reg sbcs
41c0 2reg rors
4200 2reg tst
4240 2reg negs  ( mov negated)
42c0 2reg cmn
4300 2reg orrs
4340 2reg muls
4380 2reg bics
43c0 2reg mvns  ( mov complemented)
forth


( 4-bit register)
: 2anyreg  constant  does> @  ( Rm Rdn op)  0R  R0  op, ;
4400 2anyreg addr2
4500 2anyreg cmpr2  ( NOTE: high registers _only_!)
4600 2anyreg movr2
4700 2anyreg bx

assembler
: bx   ( Rm)  \a r0 ( Rdn)  bx ;
: blx  ( Rm)  \a r8 ( Rdn)  bx ;
forth

: ?index   ( allowed this)
   u< if  error" indexing type not allowed"  then ;

: sp-or-pc   ( offset Rn ix Rt op)   r000  or  nip  woff i8  op, ;

: do-ldr-pc   ( offset Rn ix Rt 'body)
   @  3 ?index  ( ix-pc allowed)                     0  sp-or-pc ;

: do-str-sp   ( offset Rn ix Rt 'body)
   @+ @ swap  2 ?index  ( ix-sp allowed)  800 and ( L)  sp-or-pc ;

: do-str-imm  ( offset ix Rt 'body)
   @+ cell+ swap  1 ?index  ( ix-imm allowed)
   @+ push ( op-imm)  00r  or  swap pop ( scale) >>  i5  op, ;

: do-str-reg  ( ix Rt 'body)
   cell+ @  ( op-reg)  00r  or  op, ;

( For indexing. V6-M only has pre-indexing - no writeback - so there are
  only two indexing operators:)

assembler
: +)   ( offset Rn - offset ... cfa)
   dup pc = if  4800  ['] do-str-pc  ^  then  ( ix type 3)
   dup sp = if  9000  ['] do-str-sp  ^  then  ( ix type 2)
         0  0r0       ['] do-str-imm ;        ( ix type 1)

: r+)  ( Rm Rn - ix cfa)
         0  0r0  r00  ['] do-str-reg ;        ( ix type 0)
forth

( One Ring to rule them all?)
: ring    ( scale op-imm op-reg ix-max)  create  , , , ,
          ( ... cfa Rt 'body)  does>  rot execute ;

assembler
( scale op-imm op-reg ix-max)
    2    6000   5000    2   ring  str
    2    6800   5800    3   ring  ldr

    1    8000   5200    1   ring  strh
    1    8800   5a00    1   ring  ldrh

    0    7000   5400    1   ring  strb
    0    7800   5c00    1   ring  ldrb

    0       0   5e00    0   ring  ldrsh   ( scale is ignored - ix-reg only)
    0       0   5600    0   ring  ldrsb
forth

( add to pc/sp)
( i8 is scaled *4)
( same structure as ld/st sp offset!)
0a000 ldr-str-sp add-pc
0a800 ldr-str-sp add-sp

( add/sub imm to sp)
( i8 is scaled *4)
: sp-offset  constant  does> @  ( i7 op)  woff  i7  op, ;
0b000 sp-offset add-to-sp
0b080 sp-offset sub-from-sp

( 0b100 & 0b300 are cbz - not in ARMv6-M)

( Sign- and zero-extend)
assembler
0b200 2reg sxth
0b240 2reg sxtb
0b280 2reg uxth
0b2c0 2reg uxtb
forth

: stackop
   create  ( op 9threg)  >mask ,  ,
   does> @+ @  ( reglist 9thregmask op)
      -rot  over and  if  100 or  then  01ff and  or  op, ;

( Push goes here. 8 bit reglist plus lr bit.)
( 0b400 + reglist + lr << 8)
assembler
0b400 \a lr stackop push
forth

: 0op  constant  does> @  op, ;
assembler
0b662 0op cpsie
0b672 0op cpsid
forth

( 0b700 & 0b800 undefined)

( 0b900 & 0bb00 are cbnz - not in ARMv6-M)

( Byte and halfword reverses)
assembler
0ba00 2reg rev
0ba40 2reg rev16
( 0ba80 is ???)
0bac0 2reg revsh
forth

( 0bb00 undefined)

( Pop goes here. 8 bit reglist plus pc bit.)
( 0bc00 + reglist + pc << 8)
assembler
0bc00 \a pc stackop pop
forth

: op-i8   constant  does> @  ( i8 op)  over imm? if nip then  i8  op, ;

( Breakpoint)
assembler
0be00 op-i8 bkpt
forth

( Hints.)
( 0bfx0 are hints; 0bfxm are IT - when m != 0. Not in ARMv6-M)
assembler
0bf00 0op nop
0bf10 0op yield
0bf20 0op wfe
0bf30 0op wfi
0bf40 0op sev
forth


( ldm/stm)
assembler
( Low 8 registers only!)
0c000 1reg-i8 stm  ( reglist Rn)
0c800 1reg-i8 ldm
forth

( Conditional branch.)
( Condition field:
  0  EQ  Z=1
  1  NE  Z=0
  2  CS  C=1   aka HS   NOTE: different from other architectures!
  3  CC  C=0   aka LO         ARM uses "natural" carry, which = ~borrow
  4  MI  N=1
  5  PL  N=0
  6  VS  V=1
  7  VC  V=0
  8  HI  C=1 and Z=0
  9  LS  C=0 or  Z=1
 10  GE  N=V
 11  LT  N!=V
 12  GT  N=V and Z=0
 13  LE  N!=V or Z=1
 14  AL  always    NOTE: always and never are NOT encoded in any ARMv6-M
 15  ??  never     instruction. Ever.

  b<cond> encoding: 0d000 + <cond> << 8 + offset
  offset is _signed_ and scaled *2; offset from pc+4
)

( 2cond defines both a condition and its complement. NOTE: These compile a
  conditional branch with the opposite sense than their mnemonic! Ie, u<
  compiles branch if higher or same.)

( Condition codes compile a conditional branch instruction with zero
  offset, and push the address of the offset byte.)

: 2cond  ( cond)  8 <<  dup  100 xor ( complement cond)  constant  constant ;
assembler
 0 2cond  0=  0!=
 2 2cond  cs  cc
 2 2cond  u>= u<
 4 2cond  0<  0>=
 6 2cond  vs  vc
 8 2cond  u>  u<=
0a 2cond  >=  <
0c 2cond  >   <=
forth

( svc and friend(s)
assembler
0de00 op-i8 undef   ( branch always encoding!)
0df00 op-i8 svc     ( branch never encoding!)
forth

: bad-branch   error" branch offset too large" ;

: branch-offset  ( dest src - offset)
   4 + ( compensate for prefetch)  -  2/ ;

: offset-fits?  ( offset #bits - masked-offset -1 | offset 0)
   2dup sfits? if  >mask 1-  and  -1 ^  then  drop  0 ;

( Complains if offset doesn't fit.)
: masked-offset  ( offset #bits - bits)
   offset-fits?  if ^ then  bad-branch ;

( Long unconditional branch.)
( 0e000 + i11 offset: signed and scaled *2. offset from pc+4.)
: >bra  ( offset - op)  #11 masked-offset  e000 + ;
assembler
: b   ( dest)   \m here  branch-offset  >bra  op, ;
forth


( 0e800 - ffff are 32-bit encodings! See ARM/ARMv7/thumb32-asm.mu4 for
  details!)


( If branching backward, and conditional branch can't reach, change sense
  of conditional branch to branch forward around an unconditional backward
  branch.)

meta
: resolve  ( dest src)
   push  r@  ( dest src)  branch-offset
   r@ image-h@  f000 and  d000 = if
      ( cond branch)  8 offset-fits? if  pop image-c!  ^  then
      dup 0< if  ( backwards)
         r@ image-h@  ff00 and  100 xor  pop image-h!
         1- ( branch back past one more instruction)  >bra  op,  ^
      then  shunt  bad-branch
   then
   ( uncond branch)  >bra  pop image-h! ;
forth

( Control structure words.)
assembler
: always  (      - src)  \m here         e000    op, ;  ( uncond jump)
: if      ( cond - src)  \m here   swap  d000 +  op, ;  ( cond jump)
: then    ( src)         \m here   swap  \m resolve ;   ( >resolve)
: else    ( src - src2)  \a always  swap  \a then ;

: begin   ( - dest)      \m here ;
: again   ( dest)        \a always  \m resolve ;
: until   ( dest cond)   \a if      \m resolve ;
: while   ( dest - src dest)  \a if  swap ;
: repeat  ( src dest)    \a again  \a then ;
forth

( Testing)
assembler
: ;c   \ [ ;  ( back to forth)  ( should go to __meta, but not defined yet)
forth


( Save an image that we can try to disassemble with objdump, and send to
  device using stlink.)

( Super-simple raw binary image. No address info is saved!)
: save-image
   token, create-file ( fd)
   dup ( fd)  image  #image aligned  write
   close-file ;

( XXX for test)
-:  ."  (assembling)"  ;
-:
    .assembler. find  if  execute  ^  then
      .equates. find  if  execute  ^  then
         .meta. find  if  execute  ^  then
        .forth. find  if  execute  ^  then  ( utility words in .forth.)
                                            number ;
mode __asm

.ifdef asm-tests

( tests)
ram
@ram org  ( RAM start)

__asm
( imm shifts - low regs)
4 # r5 r7 lsli
8 # r3 r2 lsri
#31 # r4 r0 asri

( 3 regs - low regs)
r4 r5 r6 addr3l
r0 r1 r2 subr3l
6 # r5 r6 addi3
7 # r1 r2 subi3

( 8-bit imm - low regs)
44 # r6 movi8
0fc # r1 cmpi8
33 # r3 addi8
23 # r7 subi8

( alu low register)
r3 r5 tst
r7 r2 cmpr
r1 r4 bic

( 4-bit reg fields)
lr r8 addr2
r3 pc cmpr2
sp r5 movr2
lr bx
r9 blx

r0 bx
r1 bx
r2 bx
r3 bx
r4 bx
r5 bx
r6 bx
r7 bx
r8 bx
r9 bx
r10 bx
r11 bx
r12 bx
sp bx
lr bx
pc bx

r0 blx
r1 blx
r2 blx
r3 blx
r4 blx
r5 blx
r6 blx
r7 blx
r8 blx
r9 blx
r10 blx
r11 blx
r12 blx
sp blx
lr blx
pc blx

( ldr str indexd)
r0 r1 r2 str-ix
r3 r4 r5 strh-ix
r6 r7 r0 strb-ix
r1 r2 r3 ldrsb-ix
r4 r5 r6 ldr-ix
r7 r0 r1 ldrh-ix
r2 r3 r4 ldrb-ix
r5 r6 r7 ldrsh-ix

( ldr str base+offset, ie imm)
20 # r0 r1 str-imm
33 # r2 r3 ldr-imm
49 # r4 r5 strb-imm
53 # r6 r7 ldrb-imm
67 # r0 r1 strh-imm
98 # r2 r3 ldrh-imm

( ldr str rel to sp)
0ae # r0 str-sp
0dc # r1 ldr-sp

( load reg with pc or sp + offset)
0ce # r2 add-sp
0d9 # r3 add-pc

( offset the sp)
0b4 # add-to-sp
0c2 # sub-from-sp

__forth


save-image stmf0-test.img

.then
