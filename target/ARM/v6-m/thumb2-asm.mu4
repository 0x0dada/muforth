( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( Core of ARMv6-M assembler - for Cortex-M0, M0+, M3, and M4)

hex

( XXX Idea for solving the postfix S problem: when searching .assembler. ,
  first search for token; if found, great; if not, and token ends in 's',
  search again for token with length smaller by one char!

  The opcodes that can end in 's' should be in .assembler. _without_ the 's'.)

: 4#  # # # # ;
: __  char _ hold ;
: debug-show   dup  radix preserve  binary  <# 4# __ 4# __ 4# __ 4# #>  cr  type ;

: op,  debug-show  \m h, ;

( Make these create/does words so it's easy to change their behaviour.)
: reg   constant  ( regnum)  does> @ ;
assembler
#15 reg pc
#14 reg lr
#13 reg sp
#12 reg r12
#11 reg r11
#10 reg r10
  9 reg r9
  8 reg r8
  7 reg r7
  6 reg r6
  5 reg r5
  4 reg r4
  3 reg r3
  2 reg r2
  1 reg r1
  0 reg r0

forth
: reg?  ( n - f)  1_0000 u< ;

: ?reg  ( n op - op reg)
   over reg? 0=  if  error" expected a register"  then  swap ;

( These are named to suggest where they would put the 3-bit field if the
  instruction is in octal.)
: r00  ( reg op - op')  ?reg  07 and  6 <<  or ;
: 0r0  ( reg op - op')  ?reg  07 and  3 <<  or ;
: 00r  ( reg op - op')  ?reg  07 and        or ;

( Like above, but shifted 8 bits left. The octal metaphor doesn't work here!)
: r000  ( reg op - op')  ?reg  07 and  8 <<  or ;

( For building opcodes with 4-bit register field, R.)
: 0R  ( reg op - op')  ( R -> r0_000_rrr)
   ?reg  dup 8 and  4 <<  swap  07 and  or or ;

: R0  ( reg op - op')  ( R -> 0r_rrr_000)
   ?reg  0f and  3 <<  or ;

( Register lists (masks)
: >mask  ( n - 2^n)  1 swap << ;

assembler
feebfeeb constant {  ( - mark)
: }    ( mark Rx .. Ry - mask)
   0 ( mask)   begin  over \a { xor while  ?reg >mask or  repeat  nip
   0ffff and ;

( Let's allow 16 bits for immediate values. Since Thumb16 immediates can
  only be 8 bits - but can encode 10-bit values - this should be fine.
  Let's combine the "type" and value. By checking the 1_0000 bit, we can
  tell a register operand from an immed operand.)

: #   ( imm - bits)  0ffff and  1_0000 or ;
forth

: ?imm  ( n op - op imm)
   over reg?  if  error" expected immediate value"  then  swap 0ffff and ;

( Offsets.)
: hoff  ( off op - op off/2)  swap  2/ ;
: woff  ( off op - op off/4)  swap  2 >> ;

( Immediate fields)
: i5  ( imm op)  swap  1f and  6 <<  or ;
: i3  ( imm op)  swap  07 and  6 <<  or ;
: i8  ( imm op)  swap 0ff and        or ;
: i7  ( imm op)  swap  7f and        or ;

( Shift-immed register - low register only!)
: sh-imm  constant  does> @  ( i5 Rm Rd op)  00r  0r0  i5  op, ;
assembler
0000 sh-imm lsli
0800 sh-imm lsri
1000 sh-imm asri
forth

( 3 register instructions - low registers only!)
: 3reg  constant  does> @  ( Rm Rn Rd op)  00r  0r0  r00  op, ;
assembler
1800 3reg addr3
1a00 3reg subr3
forth

( 3 bit immediate - low registers only!)
: 2reg-i3  constant  does> @  ( i3 Rn Rd op)  00r  0r0  i3  op, ;
assembler
1c00 2reg-i3 addi3
1e00 2reg-i3 subi3
forth

( 8 bit immediate - low registers only!)
: 1reg-i8  constant  does> @  ( i8 Rd op)  r000  i8  op, ;
assembler
2000 1reg-i8 movi8
2800 1reg-i8 cmpi8
3000 1reg-i8 addi8
3800 1reg-i8 subi8
forth

( Data processing, low registers only!)
: 2reg   constant  does> @  ( Rm Rdn op)  00r  0r0  op, ;

assembler
4000 2reg and
4040 2reg eor
4080 2reg lslr
40c0 2reg lsrr
4100 2reg asrr
4140 2reg adc
4180 2reg sbc
41c0 2reg ror
4200 2reg tst
4240 2reg rsb
4280 2reg cmpr
42c0 2reg cmn
4300 2reg orr
4340 2reg mul
4380 2reg bic
43c0 2reg mvn
forth


( 4-bit register)
: 2anyreg  constant  does> @  ( Rm Rdn op)  0R  R0  op, ;
: bx       constant  does> @  ( Rm     op)      R0  op, ;
assembler
4400 2anyreg addr2
4500 2anyreg cmpr2  ( NOTE: high registers _only_!)
4600 2anyreg movr2
4700 bx   bx
4780 bx   blx
forth

comment previous-bx
forth
4700 2anyreg _bx
assembler
: bx   ( Rm)  r0 ( Rdn)  _bx ;
: blx  ( Rm)  r8 ( Rdn)  _bx ;
forth
previous-bx

( ldr pc-imm)
assembler
( ea = align[pc+4] + [i8 << 2]
  i8 is _unsigned_ - forward offsets only!)
: ldr-pc-imm   ( offset Rt)  4800  r000  woff i8  op, ;
forth

( ldr/str h/b/sb)
assembler
5000 3reg str-ix
5200 3reg strh-ix
5400 3reg strb-ix
5600 3reg ldrsb-ix
5800 3reg ldr-ix
5a00 3reg ldrh-ix
5c00 3reg ldrb-ix
5e00 3reg ldrsh-ix
forth

( ldr/str base+offset)
( NOTE: use + not or here!)
( Depending on size of datum, offset is _scaled_.
  byte     => *1
  halfword => *2
  word     => *4
  XXX NOTE: need words to check and calculate offsets!)

( XXX NOTE: L bit is bit #11 - 800 hex.)
: stri    constant  does> @  ( off*4 Rn Rt op)  00r  0r0  woff i5  op, ;
: strbi   constant  does> @  ( off   Rn Rt op)  00r  0r0  swap i5  op, ;
: strhi   constant  does> @  ( off*2 Rn Rt op)  00r  0r0  hoff i5  op, ;
assembler
6000 stri str-imm
6800 stri ldr-imm

7000 strbi strb-imm
7800 strbi ldrb-imm

8000 strhi strh-imm
8800 strhi ldrh-imm
forth

( ldr/str sp-rel)
( XXX same code as op-i8, different base op)
( As above, since we're moving a word-sized datum, i8 is scaled *4.)
: ldr-str-sp  constant  does> @  ( i8 Rt op)  r000  woff i8  op, ;
assembler
9000 ldr-str-sp str-sp
9800 ldr-str-sp ldr-sp

( add to pc/sp)
( i8 is scaled *4)
( same structure as ld/st sp offset!)
0a000 ldr-str-sp add-pc
0a800 ldr-str-sp add-sp
forth

( add/sub imm to sp)
( i8 is scaled *4)
: sp-offset  constant  does> @  ( i7 op)  woff  i7  op, ;
assembler
0b000 sp-offset add-to-sp
0b080 sp-offset sub-from-sp
forth

( 0b100 & 0b300 are cbz - not in ARMv6-M)

( Sign- and zero-extend)
assembler
0b200 2reg sxth
0b240 2reg sxtb
0b280 2reg uxth
0b2c0 2reg uxtb
forth

: stackop
   create  ( op 9threg)  >mask ,  ,
   does> @+ @  ( reglist 9thregmask op)
      -rot  over and  if  100 or  then  01ff and  or  op, ;

( Push goes here. 8 bit reglist plus lr bit.)
( 0b400 + reglist + lr << 8)
assembler
0b400 \a lr stackop push
forth

: 0op  constant  does> @  op, ;
assembler
0b662 0op cpsie
0b672 0op cpsid
forth

( 0b700 & 0b800 undefined)

( 0b900 & 0bb00 are cbnz - not in ARMv6-M)

( Byte and halfword reverses)
assembler
0ba00 2reg rev
0ba40 2reg rev16
( 0ba80 is ???)
0bac0 2reg revsh
forth

( 0bb00 undefined)

( Pop goes here. 8 bit reglist plus pc bit.)
( 0bc00 + reglist + pc << 8)
assembler
0bc00 \a pc stackop pop
forth

: op-i8   constant  does> @  ( i8 op)  ?imm i8  op, ;

( Breakpoint)
assembler
0be00 op-i8 bkpt
forth

( Hints.)
( 0bfx0 are hints; 0bfxm are IT - when m != 0. Not in ARMv6-M)
assembler
0bf00 0op nop
0bf10 0op yield
0bf20 0op wfe
0bf30 0op wfi
0bf40 0op sev
forth


( ldm/stm)
assembler
( Low 8 registers only!)
0c000 1reg-i8 stm  ( reglist Rn)
0c800 1reg-i8 ldm
forth

( Conditional branch.)
( Condition field:
  0  EQ  Z=1
  1  NE  Z=0
  2  CS  C=1   aka HS   NOTE: different from other architectures!
  3  CC  C=0   aka LO         ARM uses "natural" carry, which = ~borrow
  4  MI  N=1
  5  PL  N=0
  6  VS  V=1
  7  VC  V=0
  8  HI  C=1 and Z=0
  9  LS  C=0 or  Z=1
 10  GE  N=V
 11  LT  N!=V
 12  GT  N=V and Z=0
 13  LE  N!=V or Z=1
 14  AL  always    NOTE: always and never are NOT encoded in any ARMv6-M
 15  ??  never     instruction. Ever.

  b<cond> encoding: 0d000 + <cond> << 8 + offset
  offset is _signed_ and scaled *2; offset from pc+4
)

( svc and friend(s)
assembler
0de00 op-i8 undefined   ( branch always encoding!)
0df00 op-i8 svc         ( branch never encoding!)
forth

( Long unconditional branch.)
( 0e000 + i11 offset: signed and scaled *2. offset from pc+4.)

( 0e800 - ffff are 32-bit encodings! See ARM/ARMv7/thumb32-asm.mu4 for
  details!)

( Save an image that we can try to disassemble with objdump, and send to
  device using stlink.)

( Super-simple raw binary image. No address info is saved!)
: save-image
   token, create-file ( fd)
   dup ( fd)  image  #image aligned  write
   close-file ;

( XXX for test)
-:  ."  (assembling)"  ;
-:
    .assembler. find  if  execute  ^  then
      .equates. find  if  execute  ^  then
         .meta. find  if  execute  ^  then
        .forth. find  if  execute  ^  then  ( utility words in .forth.)
                                            number ;
mode __asm

.ifdef asm-tests

( tests)
ram
@ram org  ( RAM start)

__asm
( imm shifts - low regs)
4 # r5 r7 lsli
8 # r3 r2 lsri
#31 # r4 r0 asri

( 3 regs - low regs)
r4 r5 r6 addr3l
r0 r1 r2 subr3l
6 # r5 r6 addi3
7 # r1 r2 subi3

( 8-bit imm - low regs)
44 # r6 movi8
0fc # r1 cmpi8
33 # r3 addi8
23 # r7 subi8

( alu low register)
r3 r5 tst
r7 r2 cmpr
r1 r4 bic

( 4-bit reg fields)
lr r8 addr2
r3 pc cmpr2
sp r5 movr2
lr bx
r9 blx

r0 bx
r1 bx
r2 bx
r3 bx
r4 bx
r5 bx
r6 bx
r7 bx
r8 bx
r9 bx
r10 bx
r11 bx
r12 bx
sp bx
lr bx
pc bx

r0 blx
r1 blx
r2 blx
r3 blx
r4 blx
r5 blx
r6 blx
r7 blx
r8 blx
r9 blx
r10 blx
r11 blx
r12 blx
sp blx
lr blx
pc blx

( ldr str indexd)
r0 r1 r2 str-ix
r3 r4 r5 strh-ix
r6 r7 r0 strb-ix
r1 r2 r3 ldrsb-ix
r4 r5 r6 ldr-ix
r7 r0 r1 ldrh-ix
r2 r3 r4 ldrb-ix
r5 r6 r7 ldrsh-ix

( ldr str base+offset, ie imm)
20 # r0 r1 str-imm
33 # r2 r3 ldr-imm
49 # r4 r5 strb-imm
53 # r6 r7 ldrb-imm
67 # r0 r1 strh-imm
98 # r2 r3 ldrh-imm

( ldr str rel to sp)
0ae # r0 str-sp
0dc # r1 ldr-sp

( load reg with pc or sp + offset)
0ce # r2 add-sp
0d9 # r3 add-pc

( offset the sp)
0b4 # add-to-sp
0c2 # sub-from-sp

__forth


save-image stmf0-test.img

.then
