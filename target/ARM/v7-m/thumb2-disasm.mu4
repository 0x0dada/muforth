( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( Extend the disassembler to include ARM v7-m instructions.)

hex

: dotreg  constant ( shift)
          does> @  ( op shift - op)  over swap u>>  .reg ;

#16 dotreg Rn
#12 dotreg Rt
  8 dotreg Rd
  0 dotreg Rm

: Rd,  Rd comma ;
: Rn,  Rn comma ;

: 0n0n  ( n - 0n0n)  ( take 8 bit number; replicate into 32 bits)
   dup #16 << + ;

: thumb-expand-imm  ( op - op imm32)
   dup 0ff and  push
   dup #12 u>> 7 and  over #26 bit@  3 << +  ( hi4)
   dup 0=  if  drop  pop                     ( 000n)  ^  then
   dup 1 = if  drop  pop  0n0n               ( 0n0n)  ^  then
   dup 2 = if  drop  pop  0n0n      8 <<     ( n0n0)  ^  then
   dup 3 = if  drop  pop  0n0n  dup 8 << +   ( nnnn)  ^  then
   ( If not 0 to 3, we shift. This part is complicated!)
   2*  r@ 7 bit@ +  #32 swap -  ( #shifts)
   pop 80 or  swap << ;

( XXX is this the same for reg-spec'd shift amounts?)
: .imm-shift  ( op - op)
   Rm space
   dup 6 u>>  3 and  over #12 u>>  7 and +  ( imm5 = shift amount)
   over 4 u>>  3 and  dup 3 u< if  4 * z" lsl lsr asl " + 4 type  imm  ^  then
   drop ( type)  =if  ." rrx"  drop  ^  then  ." ror "  imm ;

( This is complicated because there are versions of various instructions
  that don't have an Rd - Rd=1111 - or don't have an Rn - Rn=1111.)

: .tst.w   ." tst    "  Rn, ;
: .teq.w   ." teq    "  Rn, ;
: .cmn.w   ." cmn    "  Rn, ;
: .cmp.w   ." cmp    "  Rn, ;

( XXX should append s when bit set)
: .mov.w   ." mov    "  Rd, ;
: .mvn.w   ." mvn    "  Rd, ;

: .alu-op  ( op - op f)
   01f0_0f00 0010_0f00 match .tst.w  ( and, S=1, Rd=pc)
   01f0_0f00 0090_0f00 match .teq.w  ( eor, S=1, Rd=pc)
   01f0_0f00 0110_0f00 match .cmn.w  ( add, S=1, Rd=pc)
   01f0_0f00 01b0_0f00 match .cmp.w  ( sub, S=1, Rd=pc)
   01ef_0000 004f_0000 match .mov.w  ( orr, Rn=pc)
   01ef_0000 006f_0000 match .mvn.w  ( orn, Rn=pc)
   dup #21 u>> 0f and
   ( XXX should append s when bit set)
   z" andbicorrorneor?????????add???adcsbc???subrsb???" .op3  Rd, Rn,  0 ;

: .alu-shifted-reg-imm   .alu-op  drop  .imm-shift ;
: .alu-modified-imm      .alu-op  drop  thumb-expand-imm  imm ;

( Placeholder for ops that have to be matched, so that following ops don't
  match, but that are not yet fleshed out.)
: NYI  ." ** matched but not implemented **" ;

: .reglist.w  ( op - op)  dup  0ffff and  .reglist ;
: .pop.w   ." pop    "  .reglist.w ;
: .push.w  ." push   "  .reglist.w ;

: .stm.w  ( op z" - op)
   over #20 bit@  swap .op5  
   Rn  dup #21 bit@ ( W)  if  char ! emit  then
   comma  .reglist.w ;

: .stmia.w   z" stmialdmia" .stm.w ;
: .stmdb.w   z" stmdbldmdb" .stm.w ;

: .undef.w
   ." undef  "
   dup         0fff and
   over #16 u>>  0f and  #12 << +  imm ;


( The description of bcond.w in the v7-m architecture manual is incomplete!
  See ARM v-7ar architecture manual - DDI0406C - p334 for details.

  Offset = sign_ext(S:J2:J1:imm6:imm11:0

  NOTE: though the encoding is very similar to bl and bra.w, the J1 and J2
  bits are treated differently, and are prepended in a different order as
  well!)

: .bcond.w
   dup #22 u>>  .cond
   dup           7ff and          ( imm11 in v7-ar manual)
   over #16 u>>   3f and  #11 <<  ( imm6 ditto)  +
   over #13 bit@  ( J1)   #17 <<  ( J1 ditto)  +
   over #11 bit@  ( J2)   #18 <<  ( J2 ditto)  +
   over #26 bit@  ( S)  if  [ 1 #19 << negate ] +  then
   1- ( compensate for op2 fetch)
   ( hword offset)  .branch-pc ;

: .bra.w   ." b.w    "  .bl-dest ;

( Disassemble the v7-m instructions that aren't in v6-m.)
: shred16-v7m  ( op - op)
   ( First try the v6-m code.)
   shred16-v6m  =if  ( matched)  ^  then  drop

   ( All the 16-bit v7m instructions!)
   0  ( no match) ;

: shred32-v7m  ( op - op)
   ( First try the v6-m code.)
   shred32-v6m  =if  ( matched)  ^  then  drop

   ( All the 32-bit v7-m instructions!)
   fe00_8000 ea00_0000 match  .alu-shifted-reg-imm
   fa00_8000 f000_0000 match  .alu-modified-imm
   ffff_0000 e8bd_0000 match  .pop.w
   ffff_0000 e92d_0000 match  .push.w
   ffc0_0000 e880_0000 match  .stmia.w
   ffc0_0000 e900_0000 match  .stmdb.w
   fff0_f000 f7f0_a000 match  .undef.w
   fb80_d000 f380_8000 match  NYI
   f800_d000 f000_8000 match  .bcond.w
   f800_d000 f000_9000 match  .bra.w
   0  ( no match) ;

' shred16-v7m  is shred16
' shred32-v7m  is shred32
