( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR SPI programmer commands (host)

hex

( Having loaded a simple driver that talks to either a serial-connected or
  USB-connected device that can talk SPI to an AVR target, load the bulk of
  the commands for talking to the target.)

: avr2  ( b0 b1 b2 b3 - r2)  ( do command; return second-to-last byte of response)
   avr.Read  pad 2 + c@ ;

: avr3  ( b0 b1 b2 b3 - r3)  ( do command; return last byte of response)
   avr.Read  pad 3 + c@ ;

: prog  ( enable programming)
   avr.Hello
   4 for  avr.ResetLow  0ac 53 0 0 avr2  53 = if  pop drop ^ then
           avr.ResetHigh  next
   ." Couldn't enable serial programming" ;

: unprog  ( disable programming)
   avr.ResetHigh  avr.Bye ;

: sig  ( - s0 s1 s2)
   30 0 0 0 avr3
   30 0 1 0 avr3
   30 0 2 0 avr3 ;

: fuses  ( - fuse hfuse efuse)
   50 0 0 0 avr3
   58 8 0 0 avr3
   50 8 0 0 avr3 ;

: lock  ( - lock)
   58 0 0 0 avr3 ;


( XXX quick and dirty test to read chip -- assuming 168)

: image,  ( b)  p@  c!  1 p +! ;
: pw  ( p, as word pointer)  image-p@  u2/ ;
: addr   ( - word-addr-hi word-addr-lo)  pw  >hilo ;
-- : avr3  drop  cr  rot u. swap u. u.  00 ;

: w,  >hilo  image, image, ;
: fill-image
   0 image-p!
   0  #32 Ki for  dup w,  2 +  next  drop ;

: erase-image
   0 image-p!
   #32 Ki for  0 w,  next ;

: read-chip
   erase-image
   0 image-p!
   prog  avr.FastClock
   [ #512 #64 / ] for  ( program pages)
      #64 for  ( page of 64 words)
         20  addr  0  avr3  image,  ( read flash lo byte)
         28  addr  0  avr3  image,  ( read flash hi byte)
      next  char . emit
   next
   unprog ;

: read-chip-fast
   erase-image
   0 image-p!
   prog  avr.FastClock
   [ #flash #128 / ] for  ( program pages)
      20  addr  8  p@  #128  avr.BulkRead
      #128 p +!
      char . emit
   next
   unprog ;

: read-eeprom
   erase-image
   0 image-p!
   prog  avr.FastClock
   [ #eeprom #128 / ] for  ( 512 bytes in 128 byte chunks)
      0a0  addr  0  p@  #128  avr.BulkRead
      #128 p +!
      char . emit
   next
   unprog ;

: blank?
   0 image-p!
   0ff
   #16 Ki for
      p@ c@  1 p +!  and
   next ;

( Write 8k words to 168 chip; each instruction word gets its address as a
  value. Makes for an easy test.)

40 constant w/page  ( words per page -- mega168)

0 .if
: avr.BulkWrite  ( cmd ahi alo toggle buf len)  drop
   cr  2push  rot u. swap u. u.  pop u.  pop u. ." bulkwrite" ;
.then

: lo-addr   0  pw  [ w/page 1- ] and ;
: hi-addr   pw  [ w/page negate ] and  w/page -  >hilo ;

( NOTE: this programming command is *not* available on the mega8515. You
  have to simply delay instead.)
: ?busy
   begin  0f0 0 0 0 avr3  1 and  0= until ;

: erase
   0ac 80 0 0 avr.Write  ( erase chip)  ?busy ;

: prog-test
   fill-image
   prog  avr.FastClock
   erase
   0 image-p!
   [ #flash #128 / ] for  ( program pages)
      40  lo-addr  8  p@  #128  avr.BulkWrite
      -- lo-addr  cr  swap u. u.
      #128 p +!
      4c  hi-addr  0  avr.Write  ?busy
      -- hi-addr  cr  swap u. u.  ." page"
      char . emit
   next
   unprog ;

: flash-image
   prog  avr.FastClock
   erase
   'flash region  swap image-p!  ( len)
   #127 +  #128 / for  ( program pages)
      40  lo-addr  8  p@  #128  avr.BulkWrite
      -- lo-addr  cr  swap u. u.
      #128 p +!
      4c  hi-addr  0  avr.Write  ?busy
      hi-addr  cr  swap u. u.  ." page"
      -- char . emit
   next
   unprog ;

: verify
   0 image-p!
   #8 Ki for  p@ lew@  image-p@  xor  if  dup u. then   2 p +!  next ;

: save-image
   token, create-file ( fd)  dup  0 image+  #image  write  close-file ;

: restore-image
   token, open-file-ro ( fd)  dup  0 image+  #image  read  u.  close-file ;
