( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR chat-over-TWI (improved)

( Unlike the related simple version, this one allows streaming reads and
  writes.)

__meta

hex

comment %%

Commands for a simple client debug stub for talking to an AVR chip over IIC.

         sends            returns
  =================================
  SetAddr  <lo>  <hi>     nothing
  ReadProgram             <byte>
  ReadData                <byte>
  WriteData  <byte>       nothing
  Go                      nothing

  ReadData, WriteData read and write data memory -- including the general
        registers, stack pointer, all the i/o registers, and all the RAM.

  ReadProgram reads program memory (flash)

  SetAddr sets the address to be used for reading & writing memory

  Go execute code from the address set by SetAddr
%%

%0001_000 2* equ slave-addr
7 equ TWINT  ( bit#)  ( ack after all other actions)
6 equ TWEA   ( bit#)  ( enable receipt of slave address)
2 equ TWEN   ( bit#)

1 TWINT <<
1 TWEA  << or
1 TWEN  << or equ tw-reset


comment %%

Status codes for slave receive mode:

  60  own addr+write received and ACKed
  68  as above, but lost arbitration first
  70  general call addr received and ACKed
  78  as above, but lost arbitration first
  80  prev addressed with own address; data byte recvd and ACKed
  88  as above, NACKed
  90  prev addressed with general call; data byte recvd and ACKed
  98  as above, NACKed
  a0  STOP or repeated START received while in slave receive mode

  Status codes for slave transmit mode:

  a8  own addr+read received and ACKed
  b8  data byte xmitted and ACKed
  c0  as above, but NACKed
  c8  last byte xmitted (TWEA=0), ACKed
%%

flash
4 org  ( skip reset vector)

comment register-use

  r16 -- 10 hex -- is used for checking and passing around TWI status
  r17 -- 11 hex -- is used solely for acknowledging TWINT bit
  r24 -- 18 hex -- is used for data bytes
  r30/31 -- aka z -- is used to point to memory

register-use

label restart  ( pop one return, ack int, then return)
   0 pop  0 pop
   ( fall thru)

( Ack TWINT. Make sure TWEA and TWEN also set.)
label ack-twint
   tw-reset 11 ldi  TWCR 11 sts  ret  ;c

( Wait for TWINT; read status; mask prescaler bits; return in r16)
label wait-twint
   begin  TWCR 10 lds  TWINT 10 sbrs  rjmp ( again)
   TWSR 10 lds  0f8 10 andi  ret  ;c

label read-byte
   wait-twint rcall
   80 10 cpi  restart  0= until  ( restart protocol)
   TWDR 18 lds  ack-twint rjmp  ;c

( This is a bit tricky! Since the host had to send a new transaction for
  the read, on the first byte we're going to see _two_ interrupts: first,
  that while addressed as a slave receiver we got a STOP or RESTART; and
  second, that we were addressed as slave+read. We have to watch for, and
  ack, both.

  If we want to send multiple bytes back to the master, we have to look for
  and accept both a8 - addressed as slave+read - and b8 - byte transmitted
  and ACKed. Our caller can sit in a loop since the host will NACK the last
  byte, and we'll get a c0 status, and restart.)

label expect-start
   wait-twint rcall
   0a0 10 cpi  restart  0= until  ( we should see START/RESTART)
   ack-twint rcall
   ( fall thru)

( Returns to caller if either we were just addressed, or the last byte
  written was ACKed by the master.)

label write-another?
   wait-twint rcall
   0e8 10 andi  0a8 10 cpi  restart  0= until  ( match a8 and b8)  ret  ;c

( After sending byte and acking interrupt, wait for ACK/NACK and only
  return to caller if ok to send another byte.)

label write-byte
   TWDR 18 sts  ack-twint rcall  write-another? rjmp  ;c

( Command routines.)
( On reads, keep streaming bytes from memory to TWI, as long as last byte
  was ACKed.)

label read-data
   expect-start rcall
   begin  18 ld z+    write-byte rcall  again  ;c

label read-program
   expect-start rcall
   begin  18 ld pmz+  write-byte rcall  again  ;c

label set-addr
   read-byte rcall  18 zl mov
   read-byte rcall  18 zh mov  ret  ;c

( On writes, keep streaming bytes from TWI into memory, until read-byte
  gets something other than an 80 status.)

label write-data
   read-byte rcall  18 st z+  write-data rjmp  ;c

( Clear TWEA so we NACK our address while executing code. Do this without
  resetting TWINT again.)

label go
   TWCR 10 lds  1 TWEA << invert 10 andi  TWCR 10 sts
   ijmp  ;c

( Dispatch.)
label process
   wait-twint rcall
   ack-twint rcall
   60 10 cpi  process  0= until  ( wait til addressed as slave+write)
   read-byte rcall  ( cmd)

   10 18 cpi  set-addr      0= not until
   11 18 cpi  read-program  0= not until
   12 18 cpi  read-data     0= not until
   13 18 cpi  write-data    0= not until
   14 18 cpi  go            0= not until

   ( unknown... restart!)
   ret  ;c

label delay
   11 clr
   begin
      10 clr
      begin  10 dec  0= until
   11 dec  0= until
   ret  ;c

label blink
   \m here  2 +  rcall
   ( fall thru)

label toggle
   0ff 10 ldi  PINB 10 out  PINC 10 out  PIND 10 out  ( toggle all pins!)
   delay rjmp  ;c

label blinky
   0ff 10 ldi  PORTB 10 out  PORTC 10 out  PORTD 10 out
   0ff 10 ldi   DDRB 10 out   DDRC 10 out   DDRD 10 out
   8 13 ldi  begin  blink rcall  delay rcall  13 dec  0= until  ret  ;c

RESET handler
   @ram #ram + 1- >hilo
   10 ldi  SPL 10 out
   10 ldi  SPH 10 out

   blinky rcall

   ack-twint rcall
   begin  process rcall  again  ;c
