( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR chat-over-TWI (improved)

( Unlike the related simple version, this one allows streaming reads and
  writes.)

__meta

hex

comment %%

Commands for a simple client debug stub for talking to an AVR chip over IIC.

         sends            returns
  =================================
  SetAddr  <lo>  <hi>     nothing
  ReadProgram             <byte>
  ReadData                <byte>
  WriteData  <byte>       nothing
  Go                      nothing

  ReadData, WriteData read and write data memory -- including the general
        registers, stack pointer, all the i/o registers, and all the RAM.

  ReadProgram reads program memory (flash)

  SetAddr sets the address to be used for reading & writing memory

  Go execute code from the address set by SetAddr
%%

%0001_000 2* equ slave-addr
7 equ TWINT  ( bit#)  ( ack after all other actions)
6 equ TWEA   ( bit#)  ( enable receipt of slave address)
2 equ TWEN   ( bit#)

1 TWINT <<
1 TWEA  << or
1 TWEN  << or equ tw-reset


comment %%

Status codes for slave receive mode:

  60  own addr+write received and ACKed
  68  as above, but lost arbitration first
  70  general call addr received and ACKed
  78  as above, but lost arbitration first
  80  prev addressed with own address; data byte recvd and ACKed
  88  as above, NACKed
  90  prev addressed with general call; data byte recvd and ACKed
  98  as above, NACKed
  a0  STOP or repeated START received while in slave receive mode

Status codes for slave transmit mode:

  a8  own addr+read received and ACKed
  b8  data byte xmitted and ACKed
  c0  as above, but NACKed
  c8  last byte xmitted (TWEA=0), ACKed
%%

.ifdef bootloader
   boot
   .ifdef mega168  0f8dfe0 fuses !  .then
.else
   app
   .ifdef mega168  0f9dfe0 fuses !  .then
.then

comment register-use

  r0/r1              is used for writing flash (via SPM instruction)
  r26/27 -- aka x -- is used for status and data bytes
  r30/31 -- aka z -- is used to point to memory

  These are also registers that are considered "scratch" by the
  meta-compiler's conventions.

register-use

label restart  ( pop one return, ack int, then return)
   x popw
   ( fall thru)

( Ack TWINT. Make sure TWEA and TWEN also set.)
label ack-twint
   tw-reset xh ldi  TWCR xh sts  ret  ;c

( Wait for TWINT; read status; mask prescaler bits; return in xl)
label wait-twint
   begin
.meta. .contains application-task-hook .if
      ( Caller save the chat registers so application doesn't have to
        worry about them. We only care about Z and R0/R1 because we use Z
        for addresses and might be building up a word value in R0/R1 to
        write to flash.)
      z pushw  0 pushw
      application-task-hook rcall
      0 popw  z popw
.then
      TWCR xl lds  TWINT xl sbrs
   again
   TWSR xl lds  0f8 xl andi  ret  ;c

label read-byte
   wait-twint rcall
   80 xl cpi  restart  0= until  ( restart protocol)
   TWDR xl lds  ack-twint rjmp  ;c

( This is a bit tricky! Since the host had to send a new transaction for
  the read, on the first byte we're going to see _two_ interrupts: first,
  that while addressed as a slave receiver we got a STOP or RESTART; and
  second, that we were addressed as slave+read. We have to watch for, and
  ack, both.

  If we want to send multiple bytes back to the master, we have to look for
  and accept both a8 - addressed as slave+read - and b8 - byte transmitted
  and ACKed. Our caller can sit in a loop since the host will NACK the last
  byte, and we'll get a c0 status, and restart.)

label expect-start
   wait-twint rcall
   0a0 xl cpi  restart  0= until  ( we should see START/RESTART)
   ack-twint rcall
   ( fall thru)

( Returns to caller if either we were just addressed, or the last byte
  written was ACKed by the master.)

label write-another?
   wait-twint rcall
   0e8 xl andi  0a8 xl cpi  restart  0= until  ( match a8 and b8)  ret  ;c

( After sending byte and acking interrupt, wait for ACK/NACK and only
  return to caller if ok to send another byte.)

label write-byte
   TWDR xl sts  ack-twint rcall  write-another? rjmp  ;c


.ifdef bootloader

( Support for self-programming.)

( Bits in SPMCSR:
  SPMIE   RWWSB   --      RWWSRE  BLBSET  PGWRT   PGERS   SELFPRGEN
    7       6      5        4       3       2       1       0        )

label do-spm
   SREG xh in  cli  SPMCSR xl out  spm  SREG xh out
   begin  SPMCSR xl in  0 xl sbrc  again  ret  ;c


( On word writes, keep streaming bytes from TWI into memory, until
  read-byte gets something other than an 80 status.)

label write-word
   begin  read-byte rcall  xl 0 mov  ( low byte to r0)
          read-byte rcall  xl 1 mov  ( hi byte to r1)
          %0000_0001 ( SELFPRGEN)  xl ldi  do-spm rcall
          2 z adiw
   again  ;c

label erase-page
   %0000_0011 (  PGERS + SELFPRGEN)  xl ldi  do-spm rjmp  ;c

label program-page
   %0000_0101 (  PGWRT + SELFPRGEN)  xl ldi  do-spm rjmp  ;c

label clear-page-buffer
   %0001_0001 ( RWWSRE + SELFPRGEN)  xl ldi  do-spm rjmp  ;c

.then
   

( Command routines.)
( On reads, keep streaming bytes from memory to TWI, as long as last byte
  was ACKed.)

label read-data
   expect-start rcall
   begin    z+ xl ld  write-byte rcall  again  ;c

label read-program
   expect-start rcall
   begin  pmz+ xl ld  write-byte rcall  again  ;c

label read-sp
   expect-start rcall
   SPL xl in  write-byte rcall
   SPH xl in  write-byte rjmp  ;c

label set-addr
   read-byte rcall  xl zl mov
   read-byte rcall  xl zh mov  ret  ;c

( On writes, keep streaming bytes from TWI into memory, until read-byte
  gets something other than an 80 status.)

label write-data
   begin  read-byte rcall  z+ xl st  again  ;c


( Clear TWEA so we NACK our address while executing code. Do this without
  resetting TWINT again.)

label go
   TWCR xl lds  1 TWEA << invert xl andi  TWCR xl sts
   x popw  ( throw away top return address)
   xl pop  SREG xl out  ( pop status)
   t popw  x popw  y popw  z popw  ( pop all 4 pointer regs)
   ret  ;c


( Dispatch.)
label process
   wait-twint rcall
   ack-twint rcall
   60 xl cpi  process  0= until  ( wait til addressed as slave+write)
   read-byte rcall  ( cmd)

   10 xl cpi  set-addr      0= not until
   11 xl cpi  read-program  0= not until
   12 xl cpi  read-data     0= not until
   13 xl cpi  write-data    0= not until
   14 xl cpi  go            0= not until
   15 xl cpi  read-sp       0= not until  ( sp points to partial stack frame)

.ifdef bootloader

   ( Support for self-programming.)
   20 xl cpi  0= if  write-word         rjmp  then
   21 xl cpi  0= if  erase-page         rjmp  then
   22 xl cpi  0= if  program-page       rjmp  then
   23 xl cpi  0= if  clear-page-buffer  rjmp  then

.then

   ( unknown... restart!)
   ret  ;c

label chat-entry  ( callable from other code!)
   ( Unless host changes it, stacked PC points to caller - usually interact.)
   z pushw  y pushw  x pushw  t pushw  ( push all 4 pointer regs)
   SREG xl in  xl push  ( push status)

   ack-twint rcall
   begin  process rcall  again  ;c

label interact
   begin  chat-entry rcall  again  ;c

label delay
   zh clr
   begin
      zl clr
      begin  zl dec  0= until
   zh dec  0= until
   ret  ;c

label blink
   \m here  2 +  rcall
   ( fall thru)

label toggle
   0 PINB sbi  ( toggle B0)
   delay rjmp  ;c

label blinky
   01 xl ldi  PORTB xl out  ( set B0)  DDRB xl out  ( set B0 as output)
   30 xl ldi  PORTC xl out  DDRC xl out  ( set up SCL/SDA)
   8 tl ldi  begin  blink rcall  delay rcall  tl dec  0= until  ret  ;c

RESET default-handler
   @ram #ram + ( ramend)  1-  ( stack bottom)  >hilo
   xl ldi  SPL xl out
   xl ldi  SPH xl out

.ifdef bootloader
   ( Move vectors to boot section)
   ( First set IVCE; then clear IVCE and set IVSEL.)
   .ifdef mega8515  -- idiots!! this is a different register on 8515.
   ---GICR     | INT1    INT0    INT2    --      --      --      IVSEL   IVCE    
   1 xl ldi  GICR xl out
   2 xl ldi  GICR xl out
   .else
   -- MCUCR    | --      BODS    BODSE   PUD     --      --      IVSEL   IVCE    
   1 xl ldi  MCUCR xl out
   2 xl ldi  MCUCR xl out
   .then
.then

   blinky rcall
.meta. .contains application-init-hook .if
   application-init-hook rcall
.then

   begin  interact rcall  again  ;c
