( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR interaction

variable chatting

( XXX Don't define chat words unless there is support in a connected
  device. Right now if no USB device is plugged in, the serial host code is
  loaded, which is currently behind the times and doesn't support chatting
  with AVR devices. Until this gets fixed, conditionally compile the chat
  code. At least this way it's still possible to compile and either program
  over serial or write the image to a hex file.)

.ifdef z!  ( support for setting the target's Z memory pointer)

: +chat  chatting on ;

( A copy of what we hope the current memory pointer on the target is. We
  update it when we do operations that are post-increment on the target.)

variable _z

: _z!        ( a)  dup _z !  z! ;
: _z@        ( - a)    _z @ ;  ( does _not_ talk to target)

: _z*        ( - b)  1 _z +!  z* ;       ( data memory)
: _zcell*    ( - w)  2 _z +!  zcell* ;   ( data memory)
: _zp*       ( - b)  1 _z +!  zp* ;      ( program memory)
: _zpcell*   ( - w)  2 _z +!  zpcell* ;  ( program memory)

( Don't set the memory fetch words; we need to specify program or data!)
( XXX need these for image? setting >data for image is meaningless!)

: >chat-data
         ['] _z*      is |c*
         ['] _zcell*  is |cell* ;

: >chat-prog
         ['] _zp*      is |c*
         ['] _zpcell*  is |cell* ;

: >chat  ['] _z!  is |p!
         ['] _z@  is |p@
                   2 |cell !  ( size of cell)
                   2 |addr !  ( size of addr)

         ['] >chat-data  is >data
         ['] >chat-prog  is >prog

         >prog  ( default) ;


( chat-entry has pushed an "exception frame" onto the stack.

  The order, low to high: rah ral sreg tl th xl xh yl yh zl zh pch pcl
                  offset:  <skip>    0  1  2  3  4  5  6  7  8  9  10

  rah/ral is the return address to the "process" routine.
  NOTE: PC is pushed big-endian!
)

variable chat-frame  ( loaded from rp0)
: treg  ( offset)  constant  does> @  chat-frame @  +  z! ;

0 treg .SREG
1 treg .T
3 treg .X
5 treg .Y
7 treg .Z
9 treg .PC


( Target has cell size of 16 bits.)
meta
: cell   2  ;
: cell/  2/ ;
: cells  2* ;

: rp0  \eq SPL z!  zcell*  1+ ;      ( bottom of target's R stack)
: sp0  chat-frame @  -2 and  64 - ;  ( bottom of target's D stack;
                                       room for 32 values on R)
: sp!  ( target-sp)      .Y  zcell& ;
: sp@  ( - target-sp)    .Y  zcell* ;
: top!  ( target-top)    .T  zcell& ;
: top@  ( - target-top)  .T  zcell* ;

( PC on R stack is big-endian and is a cell address, not a byte address.)
: pc!  ( target-cfa)    \m cell/ >lohi  .PC  z& z& ;
: pc@  ( - target-cfa)                  .PC  z* z*  hilo> \m cells ;

: depth  \m sp0 \m sp@ -  \m cell/ ;  ( depth of actual stack)
: u.  u. ;
: .  . ;
: .s  .s ;

forth
: 2sp  space space ;
: .b8  binary  <#  # # # #  char _ hold  # # # #  #> type  2sp ;
: .w   zcell*  .hcell  2sp ;

-- 005f reg  SREG     | I       T       H       S       V       N       Z       C       

: .regs
   radix preserve
   cr  ." ITHS_VNZC     T     X     Y     Z    SP    PC"
       (  1000_0011  1234  3456  8738  abab  3a00  3b66 )
   cr  .SREG z* .b8  .T .w  .X .w  .Y .w  .Z .w
       chat-frame @ .hcell 2sp  \m pc@ .hcell ;


( The semantics of moving cells to and from the target stack are a bit
  complicated.

  When the target stack is empty, sp0 = sp, and the top register contains
  garbage.

  When the target stack isn't empty, the distance between sp0 and sp is
  2*depth, but the bottom-most cell is garbage, and top is valid.)

: stack>  ( "push" stack to target)
   depth 0= if  "cafe \m top!  \m sp0 \m sp!  ^  then
   \m top!
   depth 7 min  ( more than that would be silly)
   \m sp0 over 1+ \m cells -  dup \m sp! ( top of D stack)  z!
   ?for  zcell&  next  then  ( copy each cell as a word to D stack)
   "cafe zcell& ( push bottom) ;

: stack<  ( "pop" stack from target)
   \m depth 0 max 8 min  ( more than that would be silly)  =if
   \m sp@ z!  1- dup ( depth, excluding top)  =if
   for  zcell*  pop 2push  next  ( starting with top, push to R)
   for  2pop push  next  ( pop from R to reverse order)
   0 0  then  2drop  \m top@  0  then  drop ;

( Get target's hardware SP - ie, forth's return stack ptr - and store into
  chat-frame.)

: get-rp   \m rp0  2 + ( skip ret addr)  chat-frame ! ;

: chat  +chat  >chat  avrchat.Hello  get-rp  .regs ;
: copy-ram ;  ( XXX no-op)
: runwait  zgo  get-rp  .regs ;

( XXX Should we try to automatically connect to target?)
: remote  ( cfa)  ( execute target forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  \m pc!  stack>  runwait  stack< ;

: rx  ( cfa)  ( execute target non-forth word)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  \m pc!          runwait ;


( Interacting with a chatty, connected target.)

-:  ."  (interacting with target)"  ;
-:
      .meta. find  if  execute          ^  then  ( labels are in .meta.)
    .target. find  if  execute  remote  ^  then  ( execute as forth word)
   .equates. find  if  execute          ^  then
.ifdef no-number                                 complain ;
.else                                            number ;
.then
mode __target

( for testing)
: r  ( ioaddr)       z!  z* ; 
: w  ( byte ioaddr)  z!  z& ;


.else  ( NO CONNECTED CHAT TARGET!)

: chat  error" No connected chat-capable target." ;
: >chat ;

.then


( Set |@ and |c@ to _some_ form of target fetch. Prefer to get bytes from
  target if we're connected. This word is useful so we can set an initial
  state for target's  du  and  dis  so that inspect won't crash when it
  runs |@ to get a default ea.)

: >target  chatting @ if  >chat ^  then  >image ;


( Define our own key bindings for memory dumping and disassembly. We'll
  default to host bindings if there isn't one in our array. This way we
  only have to define the "delta" between host and target behaviours.)

128 array avr-seekeys

( Default key action is to run host key code)
host-seekeys avr-seekeys  128 cells cmove

( Dump one line of memory from target program memory.)
: 1dump  ( a)
   hex-bytes
   >image    >prog  dup .addr  dup .hex-cells
   chatting @ if
      >chat  >prog  dup _addr  dup .hex-cells
   then
   drop ;

( So we can easily look at the signature embedded into the image.)
: 1dump-chars  ( a)
   hex-bytes
   >image >prog
   dup _addr  dup .chars
   dup .addr  dup .hex-bytes
   dup _addr  dup .hex-cells
   drop ;

( In the strange case that we switch to dumping data via the 'a' key, but
  don't happen to be connected to a target, we'll get "deadbeef" to remind
  us.)

: 1dump-data  ( a)
   hex-bytes
   >target >data
   dup _addr  dup .chars
   dup .addr  dup .hex-bytes
   dup _addr  dup .hex-cells
   drop ;

avr-seekeys  -1
   2dup  du-mode dumping        >target  skip+  skip-  1dump        ( a - a')
   2dup  du-mode dumping-data   >target  skip+  skip-  1dump-data   ( a - a')
   2dup  du-mode dumping-chars  >target  skip+  skip-  1dump-chars  ( a - a')
         du-mode disasming      >target  dis+   dis-   1dis         ( a - a')

avr-seekeys 'seekeys !  ( switch over to our bindings)

key: d  ( a - a 0)   dumping  0 ;
key: a  ( a - a 0)   dumping-data  0 ;
key: C  ( a - a 0)   dumping-chars  0 ;  ( small c is "call")
key: i  ( a - a 0)   disasming  0 ;

host-seekeys 'seekeys !  ( back to host bindings)


( Interactive)

( make an alias so we can still get to it)
: _du  du ;

: du   ( a - a')   dumping    inspect ;
: dis  ( a - a')   disasming  inspect ;

: da  ( a - a')  ( dump DAta)
   chatting @ 0= if error" no connected target - no data memory available"  then
   dumping-data  inspect ;


meta
: du   du ;
: dis  dis ;

forth
