( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR interaction

variable chatting

: +chat  chatting on ;

( A copy of what we hope the current memory pointer on the target is. We
  update it when we do operations that are post-increment on the target.)

variable _z

: _z!        ( a)  dup _z !  z! ;
: _z@        ( - a)    _z @ ;  ( does _not_ talk to target)

: _z*        ( - b)  1 _z +!  z* ;       ( data memory)
: _zcell*    ( - w)  2 _z +!  zcell* ;   ( data memory)
: _zp*       ( - b)  1 _z +!  zp* ;      ( program memory)
: _zpcell*   ( - w)  2 _z +!  zpcell* ;  ( program memory)

( Don't set the memory fetch words; we need to specify program or data!)
( XXX need these for image? setting >data for image is meaningless!)

: >chat-data
         ['] _z*      is |c*
         ['] _zcell*  is |cell* ;

: >chat-prog
         ['] _zp*      is |c*
         ['] _zpcell*  is |cell* ;

: >chat  ['] _z!  is |p!
         ['] _z@  is |p@
                   2 |cell !  ( size of cell)

         ['] >chat-data  is >data
         ['] >chat-prog  is >prog

         >prog  ( default) ;

( Set |@ and |c@ to _some_ form of target fetch. Prefer to get bytes from
  target if we're connected. This word is useful so we can set an initial
  state for target's  du  and  dis  so that inspect won't crash when it
  runs |@ to get a default ea.)

: >target  chatting @ if  >chat ^  then  >image ;


( Define our own key bindings for memory dumping and disassembly. We'll
  default to host bindings if there isn't one in our array. This way we
  only have to define the "delta" between host and target behaviours.)

128 array avr-seekeys

( Default key action is to run host key code)
host-seekeys avr-seekeys  128 cells cmove

avr-seekeys 'seekeys !    ( switch over to our bindings)

( Dump one line of memory from target program memory.)
: 1dump  ( a)
   hex-bytes
   >image    >prog  dup .addr  dup .hex-cells
   chatting @ if
      >chat  >prog  dup _addr  dup .hex-cells
   then
   drop ;

( In the strange case that we switch to dumping data via the 'a' key, but
  don't happen to be connected to a target, we'll get "deadbeef" to remind
  us.)

: 1dump-data  ( a)
   hex-bytes
   >target >data
   dup _addr  dup .chars
   dup .addr  dup .hex-bytes
   dup _addr  dup .hex-cells
   drop ;

: dumping
   16 see-skip !
   ['] skip+  advance!
   ['] skip-  retreat!
   ['] 1dump  inspect! ;

: dumping-data
   dumping
   ['] 1dump-data  inspect! ;

( XXX Always disassemble from image memory?)
: disasming
   >image >prog
   2 see-skip !
   ['] i-skip  advance!
   ['] skip-   retreat!
   ['] 1dis    inspect! ;

key: d  ( a - a 0)   dumping  0 ;
key: a  ( a - a 0)   dumping-data  0 ;
key: i  ( a - a 0)   disasming  0 ;

( Interactive)

( make an alias so we can still get to it)
: du-host  -1 see-addr-mask !  dumping  du ;

: du  ( a - a')
   avr-seekeys 'seekeys !    ( switch over to our bindings)
   "0ffff see-addr-mask !
   dumping  inspect ;

: da  ( a - a')  ( dump DAta)
   chatting @ 0= if error" no connected target - no data memory available"  then
   avr-seekeys 'seekeys !    ( switch over to our bindings)
   "0ffff see-addr-mask !
   dumping-data  inspect ;

: dis  ( a - a')
   avr-seekeys 'seekeys !    ( switch over to our bindings)
   "0ffff see-addr-mask !
   disasming  inspect ;

: chat  +chat  >chat  twi.Hello ;

: copy-ram ;  ( XXX no-op)
: runwait  zgo  begin  "7f twi.Ping  0= until ;

@ram #ram + 2 - constant go-pc

meta
: r0  \eq SPL z!  zcell*  1+ ;  ( bottom of target's R stack)
: s0  \m r0  64 - ;  ( bottom of target's D stack; room for 32 values on R)
: sp!  ( target-sp)    \a y z!  zcell& ;
: sp@  ( - target-sp)  \a y z!  zcell* ;
: pc!  ( target-cfa)   go-pc z!  2/ zcell& ;
: top!  \a t z!  zcell& ;
: top@  \a t z!  zcell* ;

: cell   2  ;
: cell/  2/ ;
: cells  2* ;
: depth  \m s0 \m sp@ -  \m cell/ ;  ( depth of actual stack)
: u.  u. ;
: .  . ;
: .s  .s ;
: du   du ;
: dis  dis ;

( The semantics of moving cells to and from the target stack are a bit
  complicated.

  When the target stack is empty, s0 = sp, and the top register contains
  garbage.

  When the target stack isn't empty, the distance between s0 and sp is
  2*depth, but the bottom-most cell is garbage, and top is valid.)

forth
: stack>  ( "push" stack to target)
   depth 0= if  "cafe \m top!  \m s0 \m sp!  ^  then
   \m top!
   depth 7 min  ( more than that would be silly)
   \m s0 over 1+ \m cells -  dup \m sp! ( top of D stack)  z!
   ?for  zcell&  next  then  ( copy each cell as a word to D stack)
   "cafe zcell& ( push bottom) ;

: stack<  ( "pop" stack from target)
   \m depth 0 max 8 min  ( more than that would be silly)  =if
   \m sp@ z!  1- dup ( depth, excluding top)  =if
   for  zcell*  pop 2push  next  ( starting with top, push to R)
   for  2pop push  next  ( pop from R to reverse order)
   0 0  then  2drop  \m top@  0  then  drop ;

( XXX Should we try to automatically connect to target?)
: remote  ( cfa)  ( execute target word on stack)
   chatting @ 0= if  error" not connected to target"  then
   copy-ram  \m pc!  stack>  runwait  stack< ;


( Interacting with a chatty, connected target.)

-:  ."  (interacting with target)"  ;
-:
      .meta. find  if  execute          ^  then  ( labels are in .meta.)
    .target. find  if  execute  remote  ^  then
   .equates. find  if  execute          ^  then
.ifdef no-number                                 complain ;
.else                                            number ;
.then
mode __target

( for testing)
: r  ( ioaddr)       z!  z* ; 
: w  ( byte ioaddr)  z!  z& ;
