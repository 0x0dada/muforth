( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR Forth kernel

__meta

label kstart  ;c

( Stack ops.)
code dup  ( a - a a)
   t dpushw  ret  ;c

code over  ( a b - a b a)
   kl ld 0 ,y  kh ld 1 ,y  ( fall thru)

label push-literal
   t dpushw  k t movw  ret  ;c

code nip  ( a b - b)
   k dpopw  ret  ;c

code 2drop
   here 2 + rcall
   ( fall thru)
code drop
   t dpopw  ret  ;c

code swap  ( a b - b a)
   k dpopw  push-literal rjmp  ;c

( Return stack ops.)
code >r
   g0 popw  ( ra)  t pushw  g0 pushw  drop rjmp  ;c

code r>
   g0 popw  ( ra)  k popw   g0 pushw  push-literal rjmp  ;c

code -rot  ( a b c - c a b)
   here 2 + rcall  ;c
   ( fall thru)

: rot  ( a b c - b c a)   >r swap  r> swap ;


( Unary ops.)
code invert
   tl com  th com  ret  ;c

code negate
   tl neg  g0 g0 eor  th g0 sbc  g0 th mov  ret  ;c

code 2*
   tl tl add  th th adc  ret  ;c

code 2/
   th asr  begin  tl ror  ret  ;c

code u2/
   th lsr  again  ;c


0 .if
code dnegate
   2 dpopw  2 neg  0 0 eor   3 0 sbc   0 3 mov  2 dpushw
                   0 0 eor  tl 0 sbc  0 tl mov   again  ;c
.then


( Binary ops.)
code -
   negate rcall  ( fall thru)  ;c

code  +
litop +     kl tl add  kh th adc  ret  ;c

code  and
litop and   kl tl and  kh th and  ret  ;c

code  or
litop or    kl tl or   kh th or   ret  ;c

code  xor
litop xor   kl tl eor  kh th eor  ret  ;c

( Fetch and store.)
code @   ( addr - w)
   t z movw
label @-common
   tl ld z+  th ld z+  ret  ;c

code c@  ( addr - b)
   t z movw
label c@-common
   tl ld z+  th clr  ret  ;c

code !   ( w addr)
   t z movw  <drop>
label !-common
   tl st z+  th st z+  drop rjmp  ;c

code c!  ( b addr)
   t z movw  <drop>
label c!-common
   tl st z+            drop rjmp  ;c

( XXX need to combine; fetch and store, literal versions.)
code @lit   ( - w)  ( addr in k)
   <dup>  k z movw  @-common rjmp  ;c

code c@lit  ( - b)  ( addr in k)
   <dup>  k z movw  c@-common rjmp  ;c

code !lit   ( w)  ( addr in k)
   k z movw  !-common rjmp  ;c

code c!lit  ( b)  ( addr in k)
   k z movw  c!-common rjmp  ;c

( Tests and compares.)
code 0=
   th tl or  1 tl subi ( Z -> C)
label makeflag  ( C -> -1; NC -> 0)
   tl tl sbc ( C -> 0ff)  tl th mov  ret  ;c

code 0<
   th th add ( N -> C)  makeflag rjmp  ;c

( XXX Need stack and literal versions...)
label do-compare
   k dpopw  tl kl sub  th kh sbc ( k - t)  ret  ;c

code u<
   do-compare rcall ( k - t)  makeflag rjmp  ;c

code <
   do-compare rcall ( k - t)
   < if .C bset  makeflag rjmp  then
        .C bclr  makeflag rjmp  ;c

label kend  ;c

( Program memory fetch, word and byte.)
( XXX any point in having literal versions?)
code pm@   ( addr - w)
   t z movw  tl ld pmz+  th ld pmz+  ret  ;c

code pmc@  ( addr - b)
   t z movw  tl ld pmz+  th clr  ret  ;c

kstart kend replicate-kernel

( XXX test code)
: d0   "000f and ;
: d1   "00f0 and ;
: d2   "0f00 and ;
: d3   "f000 and ;

: fetching
   [ "005d  load-literal -]  @lit
   [ "005f  load-literal -]  c@lit
   "cafe  [ "0010  load-literal -]  !lit
   "be  [ "0012  load-literal -]  c!lit
   "ba  [ "0013  load-literal -]  c!lit
;
