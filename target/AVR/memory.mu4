( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR memory image

( Space for compiling into. AVRs can get big; for now let's limit ourselves
  to 64k address space. Since the program space is word-addressed, this
  means 32k words.

  XXX: We should really define this in a device/xxx file that gets loaded
  _before_ this one.)

( Memory images should be stored in the dictionary like strings: prefixed
  by their length. When we push an image, we push the address of its first
  byte, but the previous cell countains the count, if we want to do bounds
  checking or address wrapping.)

: make-image  create  ( #bytes)  aligned  dup ,  allot
         does>  cell+ ( skip count) ;

64 Ki make-image  flash-image
 4 Ki make-image  eeprom-image

( bounds is just like count for strings, but I don't want to depend on
  count's implementation.)

: bounds  ( image - a u)  dup cell- @  ( a u) ; 

variable image  ( image buffer pointer; points to either flash- or eeprom-image)
( sanity default)  flash-image image !

: #image  image @  cell- @  ( get byte count) ;
: 'image  image @           ( get address) ;

: wrap   [ #image 1- ] and ;
: +a  ( a1 a2 - sum)  +  wrap ;  ( add and wrap to 16bit address)

: image+  ( target - host)  wrap  'image + ;
: image-  ( host - target)        'image -  wrap ;

( DEBUG: Define show-comma to show code as it's compiled.)
.ifdef show-comma
: .debug-comma  dup  .h8_ ;
.else
: .debug-comma ;
.then

( DEBUG: Define show-c! to show writes to image.)
.ifdef show-c!
: .debug-c!   cr  ( byte addr)  2dup .hcell_  .h8 ;
: .debug-w!   cr  ( word addr)  2dup .hcell_  .hcell ;
.else
: .debug-c! ;
: .debug-w! ;
.then

: image-c@             image+ c@ ;
: image-c!  .debug-c!  image+ c! ;

( AVRs are little-endian.)
: image-@  ( a - w)           image+ lew@ ;
: image-!  ( w a)  .debug-w!  image+ lew! ;

: image-p!  image+ p! ;
: image-p@         p@ image- ;

: target-*   ( - cell)  c* c* lohi> ;  ( little-endian 16-bit word)

defer >data ( dump data memory)
defer >prog ( dump program memory)

here "beefdead ,  ( bogus data space value)  constant no-data
: beef*  p@  3 and  no-data +  c@  1 p +! ;
: beefcell*   beef* beef* lohi> ;

: >image-data
   ['] beef*      is |c*
   ['] beefcell*  is |cell* ;

: >image-prog
   [']       c*  is |c*
   ['] target-*  is |cell* ;

: >image
   ['] image-p!  is |p!
   ['] image-p@  is |p@
                  2 |cell !  ( size of cell)

   ['] >image-data  is >data
   ['] >image-prog  is >prog

   >prog  ( default) ;

>image

( Dictionary operators.)
variable h   ( image dictionary pointer pointer; points to one of:)
   2variable 'ram     ( ram pointer, origin)
   2variable 'flash   ( flash pointer, origin)
   2variable 'ee      ( eeprom pointer, origin)

: ram     'ram     h ! ;  ( XXX reset image or not?)
: flash   'flash   h !   flash-image   image ! ;
: eeprom  'ee      h !   eeprom-image  image ! ;
: in-flash?  h @  'flash = ;
: in-ram?    h @  'ram = ;
: org    ( a) ( set dict pointer)  h @  ! ;

meta
( XXX alignment policy? Should , always align? Should allot? Should we even
  have two spaces? We will never, in this architecture, want to , or c,
  into ram; we will only need "ram here" and "ram allot".)

: here  ( - a)  h @ @ ;
: aligned  1+  -2 and ;
: align    \m here \m aligned  org ;
: allot ( n)    h @ +! ;
: c,    ( ch)   .debug-comma  \m here image-c!  1 \m allot ;
: ,     ( w)    ( \m align)  >hilo  \m c, ( lo)  \m c, ( hi) ;

forth
( return the origin & number of bytes in current region)
: region  ( - a u)  h @  2@  ( origin ptr)  over - ;

( Initialization.)
: erase  ( image)  bounds "ff fill ;
: wipe   flash-image erase
         eeprom-image erase ;

: ram!      ( ram-origin)  dup 'ram   2!  ( set ptr and origin to origin) ;
: flash!  ( flash-origin)  dup 'flash 2!  ( set ptr and origin to origin) ;
: ee!    ( eeprom-origin)  dup 'ee    2!  ( set ptr and origin to origin) ;

( Erase image, default origins: ram to @ram, and flash to @flash.)
( XXX FIXME KLUDGE)  0 constant @flash  0 constant @eeprom
: clean-slate
   wipe  @ram ram!  @flash flash!  @eeprom ee!  flash  0 org ;

clean-slate
