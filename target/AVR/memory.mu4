( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR memory image

( Space for compiling into. AVRs can get big; for now let's limit ourselves
  to 64k address space. Since the program space is word-addressed, this
  means 32k words.

  XXX: We should really define this in a device/xxx file that gets loaded
  _before_ this one.)

( Memory images should be stored in the dictionary like strings: prefixed
  by their length. When we push an image, we push the address of its first
  byte, but the previous cell countains the count, if we want to do bounds
  checking or address wrapping.)

variable image  ( image buffer pointer; points to either flash- or eeprom-image)

: make-image  create  ( #bytes)  aligned  dup ,  allot
              does>  cell+ ( skip count)  image ! ;

64 Ki make-image  flash-image
 4 Ki make-image  eeprom-image

: #image  image @  cell- @  ( get byte count) ;
: 'image  image @           ( get address) ;

: wrap   #image 1-  and ;
: +a  ( a1 a2 - sum)  +  wrap ;  ( add and wrap to 16bit address)

: image+  ( target - host)  wrap  'image + ;
: image-  ( host - target)        'image -  wrap ;

( DEBUG: Define show-comma to show code as it's compiled.)
.ifdef show-comma
: .debug-comma  dup  .h8_ ;
.else
: .debug-comma ;
.then

( DEBUG: Define show-c! to show writes to image.)
.ifdef show-c!
: .debug-c!   cr  ( byte addr)  2dup .hcell_  .h8 ;
: .debug-w!   cr  ( word addr)  2dup .hcell_  .hcell ;
.else
: .debug-c! ;
: .debug-w! ;
.then

: image-c@             image+ c@ ;
: image-c!  .debug-c!  image+ c! ;

( AVRs are little-endian.)
: image-@  ( a - w)           image+  leh@ ;
: image-!  ( w a)  .debug-w!  image+  leh! ;


defer >data ( dump data memory)
defer >prog ( dump program memory)

here "d0d0dead ,  constant no-data
-: ( buf a u)  ( copy over "dead data" reminder)
   for  dup 3 and no-data + c@ push  1+ swap  pop over c!  1+ swap  next
   2drop ;

: >image-data   [ ]  is |read ;  ( nothing useful to show if not chatting)

-: ( buf a u)  swap image+ -rot  cmove ;
: >image-prog   [ ]  is |read ;  ( read from current image buffer)

: >image
   ['] leh@  is |cell@
              2 |cell !  ( size of cell)
              2 |addr !  ( size of addr)

   ['] >image-data  is >data
   ['] >image-prog  is >prog

   >prog  ( default) ;

>image

( Dictionary operators.)
variable h   ( image dictionary pointer pointer; points to one of:)
   2variable 'ram     ( ram pointer, origin)
   2variable 'app     ( application flash pointer, origin)
   2variable 'boot    ( bootloader flash pointer, origin)
   2variable 'ee      ( eeprom pointer, origin)

: ram     'ram     h ! ;  ( XXX reset image or not?)
: app     'app     h !   flash-image  ;
: boot    'boot    h !   flash-image  ;
: eeprom  'ee      h !   eeprom-image ;

: org    ( a) ( set dict pointer)  h @  ! ;

meta
( XXX alignment policy? Should , always align? Should allot? Should we even
  have two spaces? We will never, in this architecture, want to , or c,
  into ram; we will only need "ram here" and "ram allot".)

: here  ( - a)  h @ @ ;
: aligned  1+  -2 and ;
: align    \m here \m aligned  org ;
: allot ( n)    h @ +! ;
: c,    ( ch)   .debug-comma  \m here image-c!  1 \m allot ;
: ,     ( w)    ( \m align)  >hilo  \m c, ( lo)  \m c, ( hi) ;

forth
( return the origin & number of bytes in current region)
: region  ( - a u)  h @  2@  ( origin ptr)  over - ;

( Initialization.)
: erase  'image #image "ff fill ;  ( erases _current_ image)
: wipe
   eeprom-image erase
   flash-image erase ;  ( leaves flash-image as _current_ image)

: ram!      ( ram-origin)  dup 'ram   2!  ( set ptr and origin to origin) ;
: app!      ( app-origin)  dup 'app   2!  ( set ptr and origin to origin) ;
: boot!     ( app-origin)  dup 'boot  2!  ( set ptr and origin to origin) ;
: ee!    ( eeprom-origin)  dup 'ee    2!  ( set ptr and origin to origin) ;
