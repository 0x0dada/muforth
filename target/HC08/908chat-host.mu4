( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( I couldn't take it any more - the 908 ROM monitor was driving me crazy.
  It's slow, and there is still an odd bug with the PC - the "image" of it on
  the stack frame - not getting properly initialised... but only when the
  target is first connected!

  I decided to try out some simple ideas. Instead of the Nibble Machines
  loader, we have this! Rather than a Bootloader, it's a Byteloader?)

loading HC08 Chat (host)

decimal

( Spying on the protocol.)
variable spy  spy off

: send          spy @ if ." >"  dup .h8_ then  _send ;
: recv   _recv  spy @ if ." <"  dup .h8_ then ;

.ifdef chat1

( Original chat protocol)

( Host side)
: c.Bye        00 send  ;  ( commands 0 and 1 are ignored by the chat target)  
: c.Idle       01 send  ;
: c.RunWait    02 send  recv ( flags)  drop ;  ( wait for response)
: c.Run        02 send  ;                      ( don't wait)
: c.Id         03 send  recv ;
: c.SetH       04 send  send ;
: c.SetX       05 send  send ;
: c.GetH       06 send  recv ;
: c.GetX       07 send  recv ;
: c.HXtoSP     08 send  ;
: c.SPtoHX     09 send  ;
: c.ReadNext   10 send  recv ;
: c.WriteNext  11 send  send ;

.else  ( chat2)

( Simpler, slightly improved chat protocol)

( Host side)
: c.Bye        00 send  ;  ( command 0 is ignored by the chat target)  
: c.Run        01 send  ;  ( start target executing; don't wait)
: c.SetHX      02 send  >lohi send send ;
: c.GetHX      03 send        recv recv hilo> ;
: c.HXtoSP     04 send  ;
: c.SPtoHX     05 send  ;
: c.ReadNext   06 send  recv ;
: c.WriteNext  07 send  send ;

( These are not chat protocol commands, but are "faked" for compatibility.)
: c.RunWait    c.Run  recv ( flags)  drop ;  ( wait for response)
: c.Idle       c.Bye ;  ( XXX shouldn't even be defining this)
: c.Id   "1807 ( SDIDL)  c.SetHX c.ReadNext
   dup "0af = if  drop "0ff ^  then  ( 908 will return 0af) ;

.then

.ifdef chat1

( Resynchronise the protocol - just to make sure. We throw away any unread
  input, and then send one ChatIdle, just in case we were in the middle of
  a SetH/SetX/WriteNext. This puts us back into a known state.)

: resync  flush  c.Idle ;

( We resync right before reading from a new memory address, and when
  getting the SP. We don't do these all the time, but when we do, we'd like
  to get the right addresses! By "sprinkling" these protocol resets
  throughtout the interaction, it's difficult for the two machines to stay
  out of whack for very long. Doing a "du" or ".regs" usually resets
  things.)

: c.SetHX  resync  >lohi  c.SetH  c.SetX ;
: c.GetHX                 c.GetH  c.GetX  hilo> ;

.else  ( chat2)

( In this case we send two dummy bytes in case we were doing a SetHX.)

: resync  flush  c.Bye c.Bye ;

.then

: c.GetSP  resync  c.SPtoHX  c.GetHX ;
: c.SetSP                    c.SetHX  c.HXtoSP ;


: c.GetRegs  ( - SP H CC A X PCH PCL)
   c.GetSP ( sets HX too!)
   6 for  c.ReadNext  next ;

: c.SetRegs  ( PCL PCH X A CC H)
   c.SPtoHX
   6 for  c.WriteNext  next ;

: chat
   115200 bps
   c.Bye  c.Bye  ( exit BDM loop, if running)

   ( Wire our versions into the interact code.)
   ['] c.RunWait is t.RunWait
   ['] c.Run is t.Run
   ['] c.GetRegs is t.GetRegs
   ['] c.SetRegs is t.SetRegs
   ['] c.SetHX is t.SetAddr
   ['] c.ReadNext is t.Read
   ['] c.WriteNext is t.Write

   _chat ;

   ( XXX - call hi? Only if it's modified to _not_ copy code over when it's
     compiled for flash!)
