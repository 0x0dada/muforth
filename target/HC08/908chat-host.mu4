( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( I couldn't take it any more - the 908 ROM monitor was driving me crazy.
  It's slow, and there is still an odd bug with the PC - the "image" of it on
  the stack frame - not getting properly initialised... but only when the
  target is first connected!

  I decided to try out some simple ideas. Instead of the Nibble Machines
  loader, we have this! Rather than a Bootloader, it's a Byteloader?)

loading HC08 Chat (host)

decimal

( Spying on the protocol.)
variable spy  spy off

: send          spy @ if ." >"  dup .h8_ then  _send ;
: recv   _recv  spy @ if ." <"  dup .h8_ then ;

.ifdef chat1-host

( Host side)
: c.Bye        00 send  ;  ( commands 0 and 1 are ignored by the chat target)  
: c.Idle       01 send  ;
: c.RunWait    02 send  recv ( flags)  drop ;  ( wait for response)
: c.Run        02 send  ;                      ( don't wait)
: c.Id         03 send  recv ;
: c.SetH       04 send  send ;
: c.SetX       05 send  send ;
: c.GetH       06 send  recv ;
: c.GetX       07 send  recv ;
: c.HXtoSP     08 send  ;
: c.SPtoHX     09 send  ;
: c.ReadNext   10 send  recv ;
: c.WriteNext  11 send  send ;

.else

( One change with newer "chat2" protocol is that target no longer sends a
  byte when it executes an swi and returns to chatting. It just waits. But
  if the host sends a command - say to read the stack pointer - then the
  target will get that command when it returns to chatting, and will
  immediately answer. This is the new way we do "rendez-vous".)

( Host side)
: c.Bye        00 send  ;  ( command 0 is ignored by the chat target)  
: c.Run        01 send  ;  ( start target executing; don't wait)
: c.Id         02 send  recv ;
: c.SetH       03 send  send ;
: c.SetX       04 send  send ;
: c.GetH       05 send  recv ;
: c.GetX       06 send  recv ;
: c.HXtoSP     07 send  ;
: c.SPtoHX     08 send  ;
: c.ReadNext   09 send  recv ;
: c.WriteNext  10 send  send ;

( These are not chat protocol commands, but are "faked" for compatibility.)
: c.Idle       11 send  ;  ( anything >10 is ignored by target)
: c.RunWait   c.Run  c.Id drop ;

.then

( Resynchronise the protocol - just to make sure. We throw away any unread
  input, and then send one ChatIdle, just in case we were in the middle of
  a SetH/SetX/WriteNext. This puts us back into a known state.)

: resync  flush  c.Idle ;

( We resync right before reading from a new memory address, and when
  getting the SP. We don't do these all the time, but when we do, we'd like
  to get the right addresses! By "sprinkling" these protocol resets
  throughtout the interaction, it's difficult for the two machines to stay
  out of whack for very long. Doing a "du" or ".regs" usually resets
  things.)

: c.SetHX  resync  >lohi  c.SetH  c.SetX ;
: c.GetHX                 c.GetH  c.GetX  hilo> ;
: c.GetSP  resync  c.SPtoHX  c.GetHX ;
: c.SetSP                    c.SetHX  c.HXtoSP ;

: c.GetRegs  ( - SP H CC A X PCH PCL)
   c.GetSP ( sets HX too!)
   6 for  c.ReadNext  next ;

: c.SetRegs  ( PCL PCH X A CC H)
   c.SPtoHX
   6 for  c.WriteNext  next ;

: chat
   115200 bps
   c.Idle  c.Bye  ( exit BDM loop, if running)

   ( Wire our versions into the interact code.)
   ['] c.RunWait is t.RunWait
   ['] c.Run is t.Run
   ['] c.GetRegs is t.GetRegs
   ['] c.SetRegs is t.SetRegs
   ['] c.SetHX is t.SetAddr
   ['] c.ReadNext is t.Read
   ['] c.WriteNext is t.Write

   _chat ;

   ( XXX - call hi? Only if it's modified to _not_ copy code over when it's
     compiled for flash!)
