( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( I couldn't take it any more - the 908 ROM monitor was driving me crazy.
  It's slow, and there is still an odd bug with the PC - the "image" of it on
  the stack frame - not getting properly initialised... but only when the
  target is first connected!

  I decided to try out some simple ideas. Instead of the Nibble Machines
  loader, we have this! Rather than a Bootloader, it's a Byteloader?)

loading HC08 Chat (host)

decimal

( Spying on the protocol.)
variable spy  spy off

: send          spy @ if ." >"  dup .h8_ then  _send ;
: recv   _recv  spy @ if ." <"  dup .h8_ then ;

( Which protocol? Default to chat2.)
.ndef chat1-host  .ndef chat3-host .and .if  -d chat2-host  .then

.ifdef chat1-host

( Original chat protocol)

( Host side)
: c.Bye        00 send  ;  ( commands 0 and 1 are ignored by the chat target)  
: c.Idle       01 send  ;
: c.RunWait    02 send  recv ( flags)  drop ;  ( wait for response)
: c.Run        02 send  ;                      ( don't wait)
: c.Id         03 send  recv ;
: c.SetH       04 send  send ;
: c.SetX       05 send  send ;
: c.GetH       06 send  recv ;
: c.GetX       07 send  recv ;
: c.HXtoSP     08 send  ;
: c.SPtoHX     09 send  ;
: c.ReadNext   10 send  recv ;
: c.WriteNext  11 send  send ;

: c.SetHX   >lohi  c.SetH  c.SetX ;
: c.GetHX          c.GetH  c.GetX  hilo> ;

( Resynchronise the protocol - just to make sure. We throw away any unread
  input, and then send one ChatIdle, just in case we were in the middle of
  a SetH/SetX/WriteNext. This puts us back into a known state.)

: resync  flush  c.Idle ;

.then

.ifdef chat2-host

( Simpler, slightly improved chat protocol)

( Host side)
: c.Bye        00 send  ;  ( command 0 is ignored by the chat target)  
: c.RunWait    01 send  recv ( flags)  drop ;  ( wait for response)
: c.Run        01 send  ;                      ( don't wait)
: c.SetHX      02 send  >lohi send send ;
: c.GetHX      03 send        recv recv hilo> ;
-- : c.HXtoSP     04 send  ;  ( deprecated)
: c.SPtoHX     05 send  ;
: c.ReadNext   06 send  recv ;
: c.WriteNext  07 send  send ;
: c.Stream     08 send  send ;  ( "stream" N bytes from memory)
: c.FlashNext  09 send  send ;  ( flash one byte)
: c.FlashStat  10 send  recv ;  ( read flash status)

.then

.ifdef chat3-host

( Mostly reorganised, eliminating HXtoSP - and therefore SetSP.
  Implementation on the target uses subroutines, rather than being one big
  loop. Since I keep changing this, I thought from now on I'd include a
  protocol version command - which will always be command #1!! I'll start
  the version number at three...)

( Host side)
: c.Bye        00 send  ;  ( command 0 is ignored by the chat target)  
: c.Version    01 send  recv ;  ( query chat protocol version)
: c.RunWait    02 send  recv ( flags)  drop ;  ( wait for response)
: c.Run        02 send  ;                      ( don't wait)
: c.GetSP      03 send        recv recv hilo> ;
: c.GetHX      04 send        recv recv hilo> ;
: c.SetHX      05 send  >lohi send send ;
: c.ReadNext   06 send  recv ;
: c.WriteNext  07 send  send ;
: c.Stream     08 send  send ;  ( "stream" N bytes from memory)
: c.FlashNext  09 send  send ;  ( flash one byte)
: c.FlashStat  10 send  recv ;  ( read flash status)

.then

.ifndef chat1-host
( In this case we send two dummy bytes in case we were doing a SetHX.)
: resync  flush  c.Bye c.Bye ;
.then

.ifndef c.GetSP
: c.GetSP  resync  c.SPtoHX  c.GetHX ;
.then

( We resync right before reading from a new memory address, and when
  getting or setting the SP. We don't do these all the time, but when we
  do, we'd like to get the right addresses! By "sprinkling" these protocol
  resets throughtout the interaction, it's difficult for the two machines
  to stay out of whack for very long. Doing a "du" or ".regs" usually
  resets things.)

: c.SetAddr  resync  c.SetHX ;
: c.GetAddr          c.GetHX ;

: chat-c@  c.SetAddr  c.ReadNext ;
: chat-c!  c.SetAddr  c.WriteNext ;

: c.Id   \l SDIDL chat-c@
   dup "0af = if  drop "0ff ^  then  ( 908 will return 0af) ;

( This can read from and write to arbitrary buffers on the host side, not
  just pieces of the image.)

: c.setup-chunk  ( 'target len buffer - len)
   p!  swap c.SetAddr ;

( Use streaming read.)
: c.ReadChunk    ( 'target len buffer)
   c.setup-chunk  dup c.Stream  for  recv c&  next ;

: c.WriteChunk   ( 'target len buffer)
   c.setup-chunk  for  c* c.WriteNext  next ;

: c.FlashChunk   ( 'target len buffer cmd - status)
   "30 \l FSTAT chat-c!  ( clear flash errors)
   \l flash-command 1+  chat-c!
   c.setup-chunk  for  c* c.FlashNext  next
   c.FlashStat ;

: c.VerifyChunk   ( 'target len - flag)
   over image+ c.setup-chunk  dup c.Stream
   for  recv c*  xor  if  image-p@ 1- u.  then  next ;

: c.GetRegs  ( buf - sp)
   c.GetSP ( sets HX too!)  dup push
   6 rot c.ReadChunk  pop ;

: c.SetRegs  ( buf)
   c.GetSP 6 rot  c.WriteChunk ;

: chat
.ifdef chat-slow  ( using a xtal that only allows 38400)
    38400 bps
.else
   115200 bps
.then

   resync  drain  ( exit BDM loop, if running; resync chat protocol)

   ( Wire our versions into the interact code.)
   ['] c.RunWait is t.RunWait
   ['] c.Run is t.Run
   ['] c.GetRegs is t.GetRegs
   ['] c.SetRegs is t.SetRegs
   ['] c.SetAddr is t.SetAddr
   ['] c.GetAddr is t.GetAddr
   ['] c.ReadNext is t.Read
   ['] c.WriteNext is t.Write
   ['] c.ReadChunk is t.ReadChunk
   ['] c.WriteChunk is t.WriteChunk
   ['] c.FlashChunk is t.FlashChunk
   ['] c.VerifyChunk is t.VerifyChunk

   +chat  hi ;
