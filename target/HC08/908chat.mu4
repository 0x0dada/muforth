( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( I couldn't take it any more - MON08 was driving me crazy. It's slow, and
  I still have an odd bug with the PC - the "image" of it on the stack
  frame - not getting properly initialised... but only when the target is
  first connected!

  I decided to try out some simple ideas. Instead of the Nibble Machines
  loader, we have this!

  This code should _just_ fit into RAM, leaving room for the data
  structures needed for the ROM flash routines. The idea basically that
  this is a simple target to write to in order to get the Flash written -
  ideally with a copy of this code to act as a bootloader!)

cr " HC908 Chat (target) "  file[#
hex

__outside

macro SciInit
  SCC1 6 ( ENSCI) bset
  0c # SCC2 ) mov  ( enable rcvr, xmitter)
  30 # SCPSC ) mov  ( prescaler divisor of 2 + 16/32)
                    ( yields 115200 from 18.432M clock)  ;m

code SciRx  ( returns char in A)
  begin  SCS1 ( status 1) 5 ( recvr full)  bset? until
  SCDR ( data) ) lda  rts  ;c

macro SciTx  ( sends char in A - synchronous!)
  -- begin  SCS1 ( status 1) 7 ( xmit empty)  bset? until
  SCDR ( data) ) sta  ;m

( Commands:
  0  Run        - does an RTI - pops stack frame and runs
  1  SetH       - reads a byte from SCI, writes into H register
  2  SetX       - reads a byte from SCI, writes into X register
  3  GetH       - writes H register to SCI
  4  GetX       - writes X register to SCI
  5  HXtoSP     - sets SP from HX
  6  SPtoHX     - sets HX from SP
  7  WriteByte  - reads a byte from SCI, writes into memory @ HX
  8  ReadByte   - reads a byte from memory @ HX, writes it to SCI
  9+ Sync       - nop, echoes
)

code Echo
   SciTx ( fall through)  ;c

code Dispatch
   SciRx bsr  ( command)

   0= if ( Run)   .h pul  rti  then

   .a decz? if ( SetH)
   SciRx bsr  .a psh  .h pul  ( set H)  Echo again  then

   .a decz? if ( SetX)
   SciRx bsr  tax ( set X)  Echo again  then

   .a decz? if ( GetH)
   .h psh  .a pul  Echo again  then

   .a decz? if ( GetX)
   txa  Echo again  then

   .a decz? if ( HXtoSP)  txs  Echo again  then
   .a decz? if ( SPtoHX)  tsx  Echo again  then

   .a decz? if ( WriteByte)
   SciRx bsr   0 ,x sta   1 # aix  Echo again  then

   .a decz? if ( ReadByte)
   0 ,x lda  1 # aix  then  ( fall through)

   ( Sync or unknown command)   Echo again  ;c

( If compiling to run in RAM, jump forward here to make room for the data
  structures needed for the Flash routines - from 88 to AC.)

[with] Ram [if]
0 0 0b0 org
[then]

( We need this because MON08 has taken the SWI vector, and getting it back
  means flashing the vectors, which for now I want to avoid...)
swi vector
   ( jsr/bsr has already pushed PC)
   .x psh  .a psh  tpa ( flags to A)  .a psh  .h psh  sei
   Echo again  ;c

( If the chat interaction changes the PC on this stack frame to point
  somewhere other than _after_ the __swi, not all is lost - since we got
  here via a _call_ from reset, we'll return to _that_ loop, and re-enter
  the SWI.

  On the other hand, if the PC remains unaltered, an RTI from the SWI's
  stack frame wil simply return here, and we'll take the "exception" again.)

code interact
   begin  __swi  again  ;c

reset vector
   0140 # ldhx
   txs

   -- XXX Set up for use with on-chip crystal osc?
   -- 42 # OSC ) mov  ( set Ext Osc and ECGON)

   -- configure crystal osc
   PortA 4 bset
   PortAdir 4 bset  ( configure OSC2 as output, drive high several cycles)
   nsa nsa nsa
   PortAdir 4 bclr
   0c0 # OSC ) mov  ( set external osc going - 8-32MHz xtal)

   -- wait for startup; normally one waits 4096 target cycles; for
   -- simplicity we wait that many cycles, but based on the internal osc,
   -- which is slower (12.8M) than the crystal (18.432M).

   #16 # ldx  ( 4096 = 16 * 256)  .a clr
   begin  begin  .a decz? until  .x decz? until
   OSC 1 bset ( set ECGON - switch oscillators!)

   SciInit
   begin  interact bsr  again  ;c

#]file

