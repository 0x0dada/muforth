( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( I couldn't take it any more - the 908 ROM monitor was driving me crazy.
  It's slow, and there is still an odd bug with the PC - the "image" of it on
  the stack frame - not getting properly initialised... but only when the
  target is first connected!

  I decided to try out some simple ideas. Instead of the Nibble Machines
  loader, we have this! Rather than a Bootloader, it's a Byteloader?

  This code should _just_ fit into RAM, leaving room for the data
  structures needed for the ROM flash routines. The idea basically that
  this is a simple target to write to in order to get the Flash written -
  ideally with a copy of this code to act as a bootloader!)

loading HC08 Chat (target)

hex

__meta

( The SCI code is identical between 908 and S08 except for the names - and
  offsets - of the SCI status and data regs ... so let's abstract them.)

.ifdef S08

aka SCIS1 SciStatus
aka SCID  SciData

.else   -- 908

aka SCS1 SciStatus
aka SCDR SciData

.then

label SciRx  ( returns char in A)
   begin  SciStatus 5 ( recvr full)  bset? until
   SciData ) lda  rts  ;c

label SciTx  ( transmits char in A)
   begin  SciStatus 7 ( xmit empty)  bset? until
   SciData ) sta  rts  ;c

( chat1 - original - protocol)

( Commands:
  0  Bye        - ignored by chat; force other command loops to return to chat
  1  Idle       - no-op - so we can re-sync the protocol
  2  Run        - does an RTI - pops stack frame and runs
  3  Id         - read low byte of S08 Id register SDIDL @1807
  4  SetH       - reads a byte from SCI, writes into H register
  5  SetX       - reads a byte from SCI, writes into X register
  6  GetH       - writes H register to SCI
  7  GetX       - writes X register to SCI
  8  HXtoSP     - sets SP from HX
  9  SPtoHX     - sets HX from SP
 10  ReadNext   - reads a byte from memory @ HX, writes it to SCI, inc HX
 11  WriteNext  - reads a byte from SCI, writes into memory @ HX, inc HX
)

( chat2 protocol - minor changes)

( Commands:
  0  Bye        - ignored by chat; force other command loops to return to chat;
                  can be used as an Idle
  1  Run        - does an RTI - pops stack frame and runs
                  when it returns to chat loop, returns flags register
  2  SetHX      - reads two bytes from SCI, writes them into H & X registers
  3  GetHX      - writes H then X register to SCI
  4  HXtoSP     - sets SP from HX
  5  SPtoHX     - sets HX from SP
  6  ReadNext   - reads a byte from memory @ HX, writes it to SCI, inc HX
  7  WriteNext  - reads a byte from SCI, writes into memory @ HX, inc HX
  8  ReadN      - reads a length from SCI, reads that many bytes from
                  memory, and writes them to SCI [S08 only!]
)

label SendByte  ( send char in A)
   SciTx bsr

label Dispatch
   SciRx bsr  ( command)

   ( map 0 -> ff -- ignore)
   .a decz? if ( Run)   .h pul  rti  then

   .a decz? if ( SetHX)
   SciRx bsr  .a psh  .h pul  ( set H)
   SciRx bsr  tax ( set X)  Dispatch again  then

   .a decz? if ( GetHX)
   .h psh  .a pul  SciTx bsr  ( send H)
   txa  SendByte again  ( send X)  then

   .a decz? if ( HXtoSP)  txs  Dispatch again  then
   .a decz? if ( SPtoHX)  tsx  Dispatch again  then

   .a decz? if ( ReadByte)
   0 ,x lda  1 # aix  SendByte again  then

   .a decz? if ( WriteByte)
   SciRx bsr   0 ,x sta   1 # aix

.ifdef S08
   ( end prev command)               Dispatch again  then

   .a decz? if ( ReadN)
   SciRx bsr  .a psh ( count)
   begin  0 ,x lda  1 # aix  SciTx bsr  0 ,s decz? until
   .a pul

.then

   then   ( fall through)
   ( unknown command)   Dispatch again  ;c


( If compiling into RAM and using 908 flash control block, check to make
  sure we haven't "run into" the control block, then jump forward over it
  and continue compiling there.)

in-ram?  .def control-block  .and .if
__host
: ?fits
   control-block  'zram @  u< if
      error" Code too long - ran into Flash control block"
   then ;
?fits
__meta
09c org           -- continue compiling there
.then

label emulated-swi
   ( jsr/bsr has already pushed PC)
   .x psh  .a psh  tpa ( flags to A)  .a psh  sei
   .h psh
   SendByte again  ;c

( If the chat interaction changes the PC on this stack frame to point
  somewhere other than _after_ the __swi, not all is lost - since we got
  here via a _call_ from reset, we'll return to _that_ loop, and re-enter
  the SWI.

  On the other hand, if the PC remains unaltered, an RTI from the SWI's
  stack frame wil simply return here, and we'll take the "exception" again.)

label interact
   begin  emulated-swi c  again  ;c

Vreset handler
   @ram #ram + # ldhx
   txs

.ifdef S08

   -- Turn off watchdog
   -- Can't use bit ops! SOPT1 not in z-page.
   -- Clear bits 6 & 7. These have different meanings on different chips,
   -- but at least for the JS and QG clearing both bits will shut off the
   -- watchdog.
   SOPT1 ) lda  3f # and  SOPT1 ) sta

.ifdef 4.9152m

   -- Let's try switching on the xtal osc.
   %01_11_0110 # ICSC2 ) mov  ( keep BDIV at /2, start ext osc)
   -- wait for osc to start
   begin  ICSSC 1  bset? until
   -- switch! making sure to change RDIV at the same time
   %00_111_000 # ICSC1 ) mov

   #49152 hhz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   -- At this xtal frequency we can't do better than 38400 and still get a
   -- good divisor.

   SCIBDH ) clr      ( baud rate divisor, high)
   8 # SCIBDL ) mov  ( baud rate divisor, low)
                     ( yields 38400 from 9.8304M bus clock)
   0c # SCIC2 ) mov  ( enable rcvr, xmitter)

.else .ifdef 9.8304m

   -- Let's try switching on the xtal osc.
   %00_11_0110 # ICSC2 ) mov  ( BDIV to /1 from /2, start ext osc)
   -- wait for osc to start
   begin  ICSSC 1  bset? until
   -- switch! making sure to change RDIV at the same time
   %00_111_000 # ICSC1 ) mov

   #98304 hhz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   -- At this xtal frequency we can't do better than 38400 and still get a
   -- good divisor.

   SCIBDH ) clr       ( baud rate divisor, high)
   10 # SCIBDL ) mov  ( baud rate divisor, low)
                      ( yields 38400 from 9.8304M bus clock)
   0c # SCIC2 ) mov   ( enable rcvr, xmitter)

.else  ( configure ICS or MCG, depending on device)

.labels. .contains ICSTRM .if
   -- Configure ICS (internal clock source)
   -- We're staying in FEI mode, but we're going to trim the internal
   -- reference so that our bus clock is 9.216M - a nice multiplier for
   -- 115200.
   -- I've put my own trim values into the chips @ FFAD (for 9.216M).

   0ffad ) lda   ICSTRM ) sta

   ICSC2 ) clr   ( switch BDIV to /1 from /2)

.else    -- JS or JM part with MCG
   -- Adjust registers and values for the JS & JM parts, which use a different
   -- clock generator (MCG instead of ICS), and run twice as fast.

   0ffad ) lda   MCGTRM ) sta
   -- leave BDIV/2 set; MCG runs 2x as fast as QG's ICS

.then  ( ICS vs MCG)

   #9216 khz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   SCIBDH ) clr      ( baud rate divisor, high)
   5 # SCIBDL ) mov  ( baud rate divisor, low)
                     ( yields 115200 from 9.216M bus clock)
   0c # SCIC2 ) mov  ( enable rcvr, xmitter)

.then  .then  ( xtal vs internal osc)

.ifdef so-that-worked
   -- UART test
   begin
      %1111_1111 # lda  SciTx c
      %0101_0101 # lda  SciTx c
      %0100_1001 # lda  SciTx c
      %0001_0001 # lda  SciTx c
      %0000_0001 # lda  SciTx c
   again
.then

.else  -- 908

   -- Setting COPD works, but is unnecessary in monitor mode; however,
   -- setting RSTEN causes the chip to fly away. Noise on nRST pin?
   -- Since I'm avoiding setting the Reset vector, setting these or not is
   -- irrelevant.
   -- CONFIG2 0 bset  ( set RSTEN: enable nRST pin - pin 8)

   -- I'm going to, after all, attempt to burn a chip with a programmed
   -- Reset vector. So I need this:
   CONFIG1 0 bset  ( set COPD: disable watchdog!)

   -- XXX Set up for use with on-chip crystal osc?
   -- 42 # OSC ) mov  ( set Ext Osc and ECGON)

   -- configure crystal osc
   PortA 4 bset
   DirA 4 bset  ( configure OSC2 as output, drive high several cycles)
   nsa nsa nsa
   DirA 4 bclr
   0c0 # OSC ) mov  ( set external osc going - 8-32MHz xtal)

   -- wait for startup; normally one waits 4096 target cycles; for
   -- simplicity we wait that many cycles, but based on the internal osc,
   -- which is slower (12.8M) than the crystal (18.432M).

   #16 # ldx  ( 4096 = 16 * 256; we don't bother to clr A the first time)
   begin  begin  .a decz? until  .x decz? until
   OSC 1 bset ( set ECGON - switch oscillators!)

   -- Configure SCI
   SCC1 6 ( ENSCI) bset
   %001_10000 # SCPSC ) mov  ( prescaler divisor of 2 + 16/32)
                             ( yields 115200 from 18.432M clock)
   0c # SCC2 ) mov   ( enable rcvr, xmitter)

.then

   begin  interact bsr  again  ;c
