( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HC908 Flash programming

hex

( Code to utilise the on-chip ROM-resident Flash programming routines in
  Freescale's HC908 microcontroller.)

( Read AN2635 and AN2874 for details.)

ld target/HC08/908flash-defs.mu4


-- Rescue mode -----------------------------------------------------------

( This is only for use when 908 is messed up and use of "forced monitor
  mode" is necessary. This means that there is a 9.8304M or 4.9152M clock
  signal connected to OSC1, and nIRQ is at TST voltage - above 7v. We only
  use rescue mode to do two things: do a mass erase, and program the
  oscillator trim byte. Once this is done, the chip can be used in "normal"
  monitor mode again.)

: rescue-flash-setup  ( 'target len erase-cmd 'code )
   ( write PC to stack frame) pc!
   control-block t.SetAddr
      ( erase-cmd) t.Write
                #5 t.Write ( running @ 4.9152M)
   over + 1-  >lohi  t.Write  t.Write  ( last addr)
   ( write HX to stack frame:) hx! ;

: mass-erase
   0ffbe ( flash protect register)  1 ( bogus length)
   40 ( mass erase)  'erase-range  rescue-flash-setup  chat-run ;

: rescue-trim   ( trim)
   write-buffer t.SetAddr  t.Write
   0ffc0 1 0 'program-range rescue-flash-setup  chat-run ;

-- -----------------------------------------------------------------------


: flash-setup  ( 'target 'len 'code)
   ( write PC to stack frame) pc!
   control-block t.SetAddr
       0 t.Write ( page erase)
     #18 t.Write ( running @ 18.432M) 
   over + 1-  >lohi  t.Write  t.Write  ( last addr)
   ( write HX to stack frame:)
   ( 'target) hx! ;

( Flash a chunk of 16 bytes or less.)
: program-chunk  ( 'target len)
   cr ." program-chunk "  2dup swap u. u.
   'program-range flash-setup  chat-run ;

( The length - from which we calc last-addr for the control block - doesn't
  matter for erase-range. The ROM routine always erases an entire page;
  also HX can point anywhere in the page.)

: erase-page  ( 'target)
   cr ." erase-page " dup u.
   1 'erase-range flash-setup  chat-run ;

: blank-check  ( addr - flag)
   cr ." blank-check "  dup u.
   t.SetAddr  -1  /page  for  t.Read and  next  0ff = ;

: copy-chunk  ( 'image len)
   cr ." copy-chunk "  2dup swap u. u.
   write-buffer t.SetAddr  for  c@+ t.Write  next  drop ;

( For each chunk check if blank, erase if necessary, then copy chunks over
  to buffer and program them!)

: erased  ( 'target)
   dup [ /page 1- ] and  if  drop ^  then  ( do nothing if not first byte)
   dup blank-check  if  drop ^  then
   erase-page ;

( For each chunk check if blank, erase if necessary, then copy chunks over
  to buffer and program them!)

: chunk  ( 'target len - 'target+len)
   2dup + push  over erased
   over |+ ( 'target to 'image)  over  ( 'image len)  copy-chunk
   program-chunk  pop ;

: flash-region  ( a len)
   /chunk /mod  ( r q)  swap push  ?for  /chunk chunk  next  then
                              pop  =if   ( rem) chunk  drop ^  then  2drop ;

: flash-image   flash  |region ( a u)   flash-region ;

: flash-trim   ( re-flash saved trim value)
   0ffc0 image-c@  
   write-buffer t.SetAddr  t.Write
   0ffc0 1 'program-range flash-setup  chat-run ;

( On 908, erasing the vectors means erasing the TRIM byte, so we copy it
  before erasing the last page.)

: copy-trim  ( save from the wrecking ball)
   cr ." copy-trim"
   0ffc0 dup t.SetAddr  t.Read  swap image-c! ;

: flash-vectors
   copy-trim
   0ffc0 erase-page  ( trim & vectors)
   flash-trim
   write-buffer t.SetAddr
   \m Vreset image-@ >lohi  t.Write t.Write
   \m Vreset 2 'program-range flash-setup  chat-run ;
