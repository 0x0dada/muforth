( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

cr " HC908 Flash programming " file[#

( Code to utilise the on-chip ROM-resident Flash programming routines in
  Freescale's HC908 microcontroller.)

( Read AN2635 and AN2874 for details.)

( from AN2635:
MCU Name         RAM GetByte PutByte RDVRRNG PRGRNGE ERARNGE DELNUS
MC68HC908QB4/QB8 $80   $2800   $280F   $2803  $2809   $2806   $280C )

( from AN2874:
  MCU     RAM PRGRNGE ERARNGE RDVRRNG GETBYTE DELNUS
QB4/8     $88   $2809   $2806   $2803   $2800  $280C )

__forth

hex

#64 constant /page    ( QB have 64 byte pages, I think...)
#32 constant /chunk   ( decreed by existing Flash routines)

( ROM addresses of the Flash programming routines.)
2803 constant 'verify-range
2806 constant 'erase-range
2809 constant 'program-range

( HX points to first byte of data to Flash.)
88 constant control-block
   1 6 << constant mass-erase
        0 constant page-erase
-- 89 constant cpu-speed    ( 4*bus_speed_in_mhz, rounded up to nearest int)
-- 8a constant lastH   ( Last address to program - 1)
-- 8b constant lastL
8c constant write-buffer  ( 1-32 bytes of data to write to Flash)

: flash-setup  ( 'target 'len 'code)
   push
   control-block SetHX
       0 WriteByte ( page erase)
     #18 WriteByte ( running @ 18.432M) 
     over + 1-  >lohi  WriteByte  WriteByte  ( last addr)
   ( write HX and PC to stack frame:)
   ( 'target) hx!  pop ( PC) pc! ;

( Flash a chunk of 32 bytes or less.)
: program-chunk  ( 'target len)
   cr ." program-chunk "  2dup swap u. u.
   'program-range flash-setup  chat-run ;

( The length - from which we calc last-addr for the control block - doesn't
  matter for erase-range. The ROM routine always erases an entire page;
  also HX can point anywhere in the page.)

: erase-chunk  ( 'target)
   cr ." erase-chunk " dup u.
   1 'erase-range flash-setup  chat-run ;

: blank-check  ( addr len - flag)
   cr ." blank-check "  2dup swap u. u.
   swap SetHX  0ff swap  for  ReadByte and  next  0ff = ;

: c@+  ( a - a+1 b)  dup 1+  swap c@ ;

: copy-chunk  ( 'image len)
   cr ." copy-chunk "  2dup swap u. u.
   write-buffer SetHX  for  c@+ WriteByte  next  drop ;

: erased  ( 'target len - 'target len)
   2dup blank-check  if ^ then  over erase-chunk ;

( For each chunk check if blank, erase if necessary, then copy chunks over
  to buffer and program them!)

: chunk  ( 'target len - 'target+len)
   2dup + push  erased
   over |+ ( 'target to 'image)  over  ( 'image len)  copy-chunk
   program-chunk  pop ;

: flash-region  ( a len)
   /chunk /mod  ( r q)  swap push  ?for  /chunk chunk  next  then
                              pop  =if   ( rem) chunk  drop ^  then  2drop ;

: flash-image   |origin @  |#  flash-region ;

: flash-vectors
   write-buffer SetHX
   \o swi   @ >lohi  WriteByte WriteByte
   \o reset @ >lohi  WriteByte WriteByte
   0fffc 4 'program-range flash-setup  chat-run ;

#]file

