( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( I want to use the bootloader on my MC908QB8 chips to bootstrap my 9S08
  chips. This is support for talking to the ROM monitor/bootloader resident
  on all 908 microcontrollers.)

loading HC908 Chat (ROM monitor)

( Spying on the protocol.)
variable spy  spy off

: recv  _recv  spy @ if dup .h8_ then ;

( The hardware we're using means that we should recv sent chars _twice_ -
  once because of hardware loopback, and again because the target is -
  hopefully - echoing them.)

: expect  ( ch)  "0ff and  push ( expected)
   spy @ if  cr ." expected " r@ .h8_ r@ .  ." received "  then
   recv recv ( loopback, target)
   r@ =  swap pop = and if ^ then  error"  - mismatch" ;

: send  ( byte -)  ( Send a byte, read back echoed and verify)
   dup _send  expect ;

: addr>  ( a)  >lohi send send ;

hex
: breakCheck  recv 0= if ." (break received)" then ;
: security  ( send 8 security bytes, initally FF)  8 for  0ff send  next
   breakCheck ( target sends break after security bytes recvd) ;

( Target monitor commands.)
comment
==========================================================================
READ:   Send 4a addrhi addrlo, recv byte; target sets index ptr to addr+1
WRITE:  Send 49 addrhi addrlo  data; target sets index ptr to addr+1
IREAD:  Send 1a, recv two bytes; target increments index ptr by 2
IWRITE: Send 19 byte; target increments index ptr by 1
READSP: Send 0c, recv sphi splo
RUN:    Send 28
==========================================================================
: tgRead    ( a - byte)  4a send  addr>  recv ;
: tgWrite   ( byte a)    49 send  addr>  send ;
: tgIread   ( - b0 b1)   1a send  recv recv ;
: tgIwrite  ( byte -)    19 send  send ;
: tgReadSp  ( - sp)      0c send  recv recv  hilo> ;
: tgRun                  28 send  ;
  ( target _seems_ to send a 00 or break when code that has been run
  returns to the ROM monitor. This is undocumented behaviour.)
decimal

variable leftover  ( single byte, since tgIread returns two)
variable #leftover

: m.SetAddr
   -1 +wrap  tgRead drop  ( simple, brutal, and inefficient!)
   #leftover off ;

: m.GetRegs  ( - SP H CC A X PCH PCL)
   tgReadSp dup  m.SetAddr  tgIread  tgIread  tgIread ;

: m.SetRegs  ( PCL PCH X A CC H)
   ( We can't set SP using the ROM monitor!)
   ( Instead, get current SP - which points to SWI frame - and put regs there)
   tgReadSp  m.SetAddr  6 for  tgIwrite  next ;

: m.Read  ( - byte)
   #leftover @ if  leftover @  ( return cached byte)  #leftover off  ^  then
   tgIread  ( b0 b1)  leftover !  1 #leftover ! ;

( m.Write  tgIwrite ; )

( XXX I need better names for these... esp since they already called their
  command "run")

( m.Go  tgRun ; )
: m.Run  ( wait for target)  tgRun  breakCheck ;

decimal

: chat
   ( Wire our versions into the interact code.)
   ['] m.Run is t.RunWait
   ['] tgRun is t.Run
   ['] m.GetRegs is t.GetRegs
   ['] m.SetRegs is t.SetRegs
   undeferred @  is t.AllocStackBuf   ( can't set SP using ROM monitor)
   ['] m.SetAddr is t.SetAddr
   ['] m.Read is t.Read
   ['] tgIwrite is t.Write
   ['] drop is t.StreamCount
   ['] m.Read is t.StreamRead

   9600 bps  flush  security
   _chat ;
