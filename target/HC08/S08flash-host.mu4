( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HCS08 Flash programming (host)

hex

( S08 Flash memory layout.

  ffac  my FTRIM - trims to 9.216M
  ffad  my TRIM  - ditto
  ffae  FTRIM bit - factory trim for 8M
  ffaf  TRIM byte - ditto

  ffb0 - ffbf    is all about _security_
  ffb0 - b7   comparison key
  ffb8 - bc   available
  ffbd        NVPROT; copied to FPROT at reset
  ffbe        available
  ffbf        NVOPT; copied to FOPT at reset

  ffc0 - ffff  Interrupt and reset vectors)

forth

05 constant mBlankCheck
20 constant mByteProgram
25 constant mBurstProgram
40 constant mPageErase
41 constant mMassErase

#512 constant /page   ( S08 has 512 byte Flash pages - this is erase size)
 #64 constant /row    ( max size of row to program)

.ifndef USB

: copy-row  ( 'target len)
   swap  image-p!
   dup t.AllocStackBuf  for  image-c* t.Write  next ;

: target-c!  ( byte a)  t.SetAddr  t.Write ;

: flash-setup  ( 'target len flash-status flash-command 'code)
   ( 'code) pc!
   \l flash-command 1+ target-c!  ( paste into lda #)
   \l flash-status target-c!  ( paste nop or lsra)
   ( len) \l flashCount target-c!  ( 'target) hx!
   68 .CC c! ( ensure I is set)
   t.Return ( rts or bgnd, depending on mode)  \l flash-exit target-c! ;

( Flash a row of 64 bytes or less, all in the same 64-byte "line".)
: check-row  ( 'target len)
   dup /row > if  error" programming too many bytes in one row"  then
   over + 1- xor  [ /row 1- ] bic  if
      error" row overlaps flash row boundary"  then ;

( Run flash command and check that there were no errors.)
: flash-run  ( 'target len flash-status flash-command 'code)
   30 \l FSTAT target-c!  ( clear errors)
   flash-setup  _runwait
   .CC w@ ( fetch CC:A) 2/ 0ff and  ( A contained FSTAT lsl 1)
   ." FSTAT=" dup u.  
   30 and if error" flash access or protection violation" then ;

: program-row  ( 'target len)
   cr ." program-row "  2dup swap u. u.
   2dup check-row  2dup copy-row
   9d ( nop)  ( to test status: matches FCBEF)
   mBurstProgram  \l FlashRow  flash-run ;

: erase-page  ( 'target)
   cr ." erase-page " dup u.
   1 ( len)  44 ( lsra)  ( to test status: matches FCCF)
   mPageErase  \l FlashByte  flash-run ;

: blank?  ( addr - flag)
   cr ." blank? "  dup u.
   t.SetAddr  -1  [ /page  40 / ] for  ( do it in chunks of 64)
      40 t.StreamCount ( request 64 bytes)  40 for  t.StreamRead and  next
      dup 0ff xor if  pop 2drop  0 ^  then  ( exit early)
   next  0ff = ;

.else  ( USB flash support is quite different... and much simpler!)

: check-flash-status
   \l FSTAT usb-c@  ." FSTAT=" dup u.  
   30 and if error" flash access or protection violation" then ;

: program-row  ( 'target len)
   cr ." program-row "  2dup swap u. u.
   over |+ ( 'target len buffer)  mByteProgram  u.Flash  check-flash-status ;

: erase-page  ( 'target)
   cr ." erase-page " dup u.
   1  0 |+  mPageErase  u.Flash  check-flash-status ;

( We use the USB ram region of the image as a read buffer: 1860-1960.)
: blank?  ( addr - flag)
   cr ." blank? "  dup u.
   -1  swap  [ /page  40 / ] for  ( do it in chunks of 64)
      ( sum addr)  dup 40 1860 |+  u.Read  40 + swap
      ( addr+ sum)  1860 image-p!  40 for  image-c* and  next  swap
      ( sum addr+)  over 0ff xor if  pop drop 2drop  0 ^  then  ( exit early)
   next  drop  0ff = ;

.then

( If target address is first byte of the last page of flash, return true)
: last-page?  ( 'target - f)
   @flash #flash +  /page -  = ;

( On S08, erasing the vectors means erasing the TRIM bytes, the secure
  bits, and the bootloader. So be careful about re-programming things, esp
  the TRIMs and the secure bits. Copy from ffac to ffaf.

  In the case that the chip is blank, and we've put trims into the image,
  don't overwrite these with the FF's from the chip.)

: save-trims  ( save them from the wrecking ball)
   cr ." save-trims"
   0ffac dup t.SetAddr  4 for
      t.Read  dup 0ff xor  if  over image-c!  else  drop  then
      1+  next  drop ;

( Flash vectors, security bytes, & trims)
: flash-vectors
   cr ." flashing vectors, security bytes, and trims"
   0ffac 14  ( 0ffac - 0ffcf)  program-row  ( trims and security bytes)
   0ffc0 40  ( 0ffc0 - 0ffff)  program-row  ( vectors) ;

( The only correct semantics for blank? are that when we are about to
  program the _first_ byte of a page, we check the entire page & erase it
  if necessary.)

: erased  ( 'target)
   dup [ /page 1- ] and  if  drop ^  then  ( do nothing if not first byte)
   dup blank?  if  drop ^  then
   dup last-page? if  ( erasing last page)
      save-trims  erase-page  flash-vectors  ^  then  ( normal case)
   erase-page ;

( For each row check if blank, erase if necessary, then copy rows over
  to buffer and program them!)

: row  ( 'target len - 'target+len)
   2dup + push  over erased  program-row  pop ;

: flash-region  ( a len)
   /row /mod  ( r q)  swap push  ?for   /row row  next  then
                            pop  =if  ( rem) row  drop ^  then  2drop ;

: flash-image   flash  region ( a u)   flash-region ;

( Use this to initially set the value of "our" trim - the one that trims
  the internal osc to 9.216M.)
: set-trims ( ours factory-ftrim factory)
   0ffaf image-c!  0ffae image-c!  0ffad image-c! ;

( Set value of NVOPT, which is loaded into FOPT at reset. We set it so
  security is off, and vector redirection is _enabled_.)
: set-unsecured
   0be 0ffbf image-c! ;  set-unsecured

: >nvprot  ( protected-addr - byte)
   1-  8 >>  0fe and ( clears FPDIS bit to enable protection!) ;

: protect-flash  ( protected-addr)
   dup vector-offset !  ( oddly, protected addr is mod 64k vector offset!)
   >nvprot 0ffbd image-c! ;

.ifdef S08JS
( Bypass checksum check on JS parts.)
: bypass-checksum   0  0ffba image-c! ;  bypass-checksum
.else
0fe00 protect-flash  ( don't do this for JS parts while we work on USB)
.then

( XXX This is a bit of a hack, but seems to work.)
: slow-verify   region ( a u)  over t.SetAddr  swap image-p!
   for  image-c* t.Read       xor  if  image-p@ 1- u.  then  next ;

: verify-chunk  ( len)  dup t.StreamCount
   for  image-c* t.StreamRead xor  if  image-p@ 1- u.  then  next ;

( Fast verify! Using stream reads.)
: verify   region ( a u)  over t.SetAddr  swap image-p!
   >lohi  swap push  ?for    100 verify-chunk  next  then
                pop  =if  ( rem) verify-chunk  ^  then  drop ;
