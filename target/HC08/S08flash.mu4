( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HCS08 Flash programming

hex

( Posts from the 8-bit forum about programming S08 flash:
  http://forums.freescale.com/freescale/board/message?board.id=8BITCOMM&thread.id=14410
  http://forums.freescale.com/freescale/board/message?board.id=8BITCOMM&message.id=9610
  http://forums.freescale.com/freescale/board/message?board.id=8BITCOMM&message.id=627)

comment tonyp  Bomb-proof working code from tonyp:

;*******************************************************************************
; Purpose: RAM routine to do the job we can't do from Flash
; Input  : A = value to program
; Output : None
; Note(s): This routine is modified in RAM by its loader at @2,3 and @5
;        : Stack needed: 20 bytes + 2 for JSR/BSR

?RAM_Execute       sta       EEPROM              ;Step 1 - Latch data/address
                                                 ;EEPROM (@2,@3) replaced
                   lda       #mByteProg          ;mByteProg (@5) replaced
                   sta       FCMD                ;Step 2 - Write command to FCMD

                   lda       #FCBEF_
                   sta       FSTAT               ;Step 3 - Write FCBEF_ in FSTAT
                   lsra                          ;min delay before checking FSTAT
                                                 ;(FCBEF -> FCCF for later BIT)
?RAM_Execute.Loop  bit       FSTAT               ;Step 4 - Wait for completion
                   beq       ?RAM_Execute.Loop   ;check FCCF_ for completion
                   rts

;after exit, check FSTAT for FPVIOL and FACCERR

?RAM_Needed        equ       *-?RAM_Execute

XXX: add the short - sometimes-it-works code as well.

comment tonyp

( S08 Flash memory layout.

  ffac  my FTRIM - trims to 9.216M
  ffad  my TRIM  - ditto
  ffae  FTRIM bit - factory trim for 8M
  ffaf  TRIM byte - ditto

  ffb0 - ffbf    is all about _security_
  ffb0 - b7   comparison key
  ffb8 - bc   available
  ffbd        NVPROT
  ffbe        available
  ffbf        NVOPT

  ffc0 - ffff  Interrupt and reset vectors)

forth

20 constant mByteProgram
25 constant mBurstProgram
40 constant mPageErase

__outside

ram

( Target code to write to and erase the Flash. By "pasting in" different
  values for flash-command and flash-status, it's possible to do regular
  byte programming, burst programming, or page/mass erase.)

( This code is only used for flashing via chat. Using BDM we can do this
  directly.)

( NOTE!! This code must be run from RAM. Normally it will be "scripted" via
  the chat interface, and the rts will return to flash. Because of this, it
  cannot be used with the mBurstProgram command! Only mByteProgram works.
  The reason: because the burst program command leaves the charge pump on,
  the flash array is not accessible when rts executes, and the chip resets
  with an illegal opcode error!

  Given all that, I could use Tony's code above and replace the "lda
  #status" with his lsra - though I like the idea of also matching the
  error bits and using them as reasons to exit.)

code RunFlashCommand  ( value in A, address in HX)
   0 ,x sta   ( store byte into Flash array)
   1 # aix    ( post-increment - mostly we're going to write several bytes)
label flash-command
   00 # lda   FCMD ) sta
   80 # lda   FSTAT ) sta  ( pwpp - clear FCBEF - start command)
label flash-status
   00 # lda
   begin  FSTAT ) bit  ( prpp)  0!= until  ( until flash-status matches)
   FSTAT ) and
   rts  ;c

__forth
forth

( XXX - is this necessary? should it be renamed?)
: wbyte  ( byte addr)  c.SetHX  c.WriteNext ;

: chat-flash-setup  ( 'target flash-status flash-command)
   30 \m FSTAT wbyte  ( clear errors)
   \o flash-command 1+ wbyte  ( paste into lda #)
   \o flash-status 1+ wbyte  ( paste into lda #)
   ( 'target) hx! ;

: chat-flash-run  ( byte - status)
   \o RunFlashCommand ( PC) pc!
   .A c! ( put byte to program into A)
   regs@ c.SetRegs  c.RunWait  c.GetRegs regs!  .A c@ ( status) ;

( We need similar routines for flashing via BDM.)
variable flash-command  ( in chat code these are "cached" in the actual)
variable flash-status   ( ram-resident code; for bdm we store them in vars.)

: bdm-flash-setup  ( 'target flash-status flash-command)
   30 \m FSTAT b.WriteByte  ( clear errors - doesn't use HX)
   flash-command !  flash-status !  b.SetAddr ;

( This does via BDM what RunFlashCommand does by executing code.)
: bdm-flash-run    ( byte - status)
   ( byte) b.WriteNext  ( write via HX and incr HX)
   flash-command @  \m FCMD b.WriteByte  ( set command)
   80 \m FSTAT b.WriteByte  ( start command)
   0  begin  drop  \m FSTAT b.ReadByte  flash-status @  and  =until ;


#512 constant /page    ( S08 has 512 byte Flash pages - this is erase size)
 #64 constant /chunk   ( max size of row to program)


( If target address is in the last page of flash, return true)
: last-page?  ( 'target - f)
   /page negate and  ( round down to start of page)
   @flash #flash +  /page -  = ;

( So we can switch how we flash the chip.)
defer flash-setup  ( 'target flash-status flash-command) 
defer _flash-run   ( byte - status)

: flash-via-chat  ['] chat-flash-setup is flash-setup
                  ['] chat-flash-run is _flash-run ;

: flash-via-bdm  ['] bdm-flash-setup is flash-setup
                 ['] bdm-flash-run is _flash-run ;

: flash-run  ( byte)
   _flash-run  30 and if  error" flash program or erase error"  then ;

( Flash a chunk of 64 bytes or less.)
: program-chunk  ( 'target len)
   cr ." program-chunk "  2dup swap u. u.  over
   %0111_0000 ( FCCF | FPVIOL | FACCERR)  mByteProgram  flash-setup
   swap  |+ ( target -> 'image)  swap
   for  c@+ flash-run  next drop ;

( On S08, erasing the vectors means erasing the TRIM bytes, the secure
  bits, and the bootloader. So be careful about re-programming things, esp
  the TRIMs and the secure bits. Copy from ffac to ffbf.)

: save-trims  ( save them from the wrecking ball)
   cr ." save-trims"
   0ffac dup t.SetAddr  |+ ( 'image)  14 ( hex) for
      t.Read  over c! ( save in image)  1+  next  drop ;

: erase-page  ( 'target)
   cr ." erase-page " dup u.
   dup last-page? if  ( erasing last page)  save-trims  then
   %0111_0000 ( FCCF | FPVIOL | FACCERR)  mPageErase  flash-setup
   0 ( byte)  flash-run ;

: blank-check  ( addr len - flag)
   cr ." blank-check "  2dup swap u. u.
   swap t.SetAddr  0ff swap  for  t.Read and  next  0ff = ;

: erased  ( 'target len - 'target len)
   2dup blank-check  if ^ then  over erase-page ;

( For each chunk check if blank, erase if necessary, then copy chunks over
  to buffer and program them!)

: chunk  ( 'target len - 'target+len)
   2dup + push  erased  program-chunk  pop ;

: flash-region  ( a len)
   /chunk /mod  ( r q)  swap push  ?for  /chunk chunk  next  then
                              pop  =if   ( rem) chunk  drop ^  then  2drop ;

: flash-image   flash  |region ( a u)   flash-region ;

( Use this to initially set the value of "our" trim - the one that trims
  the internal osc to 9.216M.)
: set-trims ( ours factory)  0ffaf image-c!  0ffad image-c!
   0fe 0ffbf image-c! ( unsecured) ;

( Bypass checksum check on JS parts.)
: bypass-checksum   0  0ffba image-c! ;

( Re-flash, from values saved in local image, trim and security bytes.)
( Trims are ffac -- ffaf. Security bytes are ffb0 -- ffbf.)
: flash-trims  ( re-flash saved trims and security bits.)
   0ffad 3 program-chunk  ( ours, factory ftrim, factory trim)
   0ffbf 1 program-chunk  ( security byte) ;

( XXX - maybe vector words should store the values in the correct place in
  the image?)
: flash-vectors
   \o swi   @  0fffc image-!
   \o reset @  0fffe image-!
   0fffc 4 program-chunk ;

( XXX This is a bit of a hack, but seems to work.)
: verify   |region ( a u)  swap  dup t.SetAddr  |+
    swap for  c@+ t.Read xor if  dup 'image - u.  then  next  drop ;
