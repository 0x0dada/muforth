( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HCS08 Flash programming

hex

( Posts from the 8-bit forum about programming S08 flash:
  http://forums.freescale.com/freescale/board/message?board.id=8BITCOMM&thread.id=14410
  http://forums.freescale.com/freescale/board/message?board.id=8BITCOMM&message.id=9610
  http://forums.freescale.com/freescale/board/message?board.id=8BITCOMM&message.id=627)

comment tonyp  Bomb-proof working code from tonyp:

;*******************************************************************************
; Purpose: RAM routine to do the job we can't do from Flash
; Input  : A = value to program
; Output : None
; Note(s): This routine is modified in RAM by its loader at @2,3 and @5
;        : Stack needed: 20 bytes + 2 for JSR/BSR

?RAM_Execute       sta       EEPROM              ;Step 1 - Latch data/address
                                                 ;EEPROM (@2,@3) replaced
                   lda       #mByteProg          ;mByteProg (@5) replaced
                   sta       FCMD                ;Step 2 - Write command to FCMD

                   lda       #FCBEF_
                   sta       FSTAT               ;Step 3 - Write FCBEF_ in FSTAT
                   lsra                          ;min delay before checking FSTAT
                                                 ;(FCBEF -> FCCF for later BIT)
?RAM_Execute.Loop  bit       FSTAT               ;Step 4 - Wait for completion
                   beq       ?RAM_Execute.Loop   ;check FCCF_ for completion
                   rts

;after exit, check FSTAT for FPVIOL and FACCERR

?RAM_Needed        equ       *-?RAM_Execute

XXX: add the short - sometimes-it-works code as well.

comment tonyp

( S08 Flash memory layout.

  ffac  my FTRIM - trims to 9.216M
  ffad  my TRIM  - ditto
  ffae  FTRIM bit - factory trim for 8M
  ffaf  TRIM byte - ditto

  ffb0 - ffbf    is all about _security_
  ffb0 - b7   comparison key
  ffb8 - bc   available
  ffbd        NVPROT
  ffbe        available
  ffbf        NVOPT

  ffc0 - ffff  Interrupt and reset vectors)

forth

20 constant mByteProgram
25 constant mBurstProgram
40 constant mPageErase

__outside

ram

1 var flashCount

( Target code to write to and erase the Flash. By "pasting in" different
  values for flash-command and flash-status, it's possible to do regular
  byte programming, burst programming, or page/mass erase.

  A note on timing: according to Freescale docs there should be _at least_
  four bus cycles between the write to FSTAT that starts the command, and
  the first test of FSTAT for command completion and error status. Based
  on this code and the machine-cycle diagrams shown, there are six cycles
  between the two.

  Ending this with "bgnd" works, but only because we get lucky. In chat
  mode bgnd causes a reset, but since that simply re-starts the chat
  protocol it's almost like executing an SWI.)

code FlashRow  ( program up to 64 bytes; Flash address in HX; bytes on stack)
   begin
      .a pul  ( pop next byte to program)
      0 ,x sta   ( store byte into Flash array)
      1 # aix
label flash-command
      00 # lda   FCMD ) sta
      80 # lda   FSTAT ) sta  ( pwpp)  ( clear FCBEF - start command)
label flash-status
      begin
         00 # lda     ( pp)
         FSTAT ) and  ( prpp)
      0!= until  ( until flash-status matches)
      30 # and  0= while  ( !error)
   flashCount ) decz? until  then
label flash-exit
   rts   ;c   ( Gets rewritten every time we run flash-setup. If flashing)
              ( via BDM, this will get rewritten to a bgnd instruction.)


__forth
forth


#512 constant /page   ( S08 has 512 byte Flash pages - this is erase size)
 #64 constant /row    ( max size of row to program)

: copy-row  ( 'target len)
   swap  image-p!
   dup t.AllocStackBuf  for  image-c* t.Write  next ;

: target-c!  ( byte a)   t.SetAddr  t.Write ;

: flash-setup  ( 'target len flash-status flash-command)
   \o flash-command 1+ target-c!  ( paste into lda #)
   \o flash-status 1+ target-c!  ( paste into lda #)
   ( len) \o flashCount target-c!  ( 'target) hx!
   \o FlashRow ( PC) pc!  68 .CC c! ( ensure I is set)
   t.Return ( rts or bgnd, depending on mode)  \o flash-exit target-c! ;

( Flash a row of 64 bytes or less, all in the same 64-byte "line".)
: check-row  ( 'target len)
   dup /row > if  error" programming too many bytes in one row"  then
   over + 1- xor  [ /row 1- ] bic  if
      error" row overlaps flash row boundary"  then ;

: program-row  ( 'target len)
   cr ." program-row "  2dup swap u. u.
   2dup check-row  2dup copy-row
   %1011_0000 ( FCBEF | FPVIOL | FACCERR)
   mBurstProgram  flash-setup  _runwait ;

: erase-page  ( 'target)
   cr ." erase-page " dup u.
   1 t.AllocStackBuf  ( so we can pop a byte in FlashRow)
   1 ( len)  %0111_0000 ( FCCF | FPVIOL | FACCERR)
   mPageErase  flash-setup  _runwait ;

: blank?  ( addr - flag)
   cr ." blank? "  dup u.
   t.SetAddr  -1  [ /page  40 / ] for  ( do it in chunks of 64)
      40 t.StreamCount ( request 64 bytes)  40 for  t.StreamRead and  next
      dup 0ff xor if  pop 2drop  0 ^  then  ( exit early)
   next  0ff = ;

( If target address is first byte of the last page of flash, return true)
: last-page?  ( 'target - f)
   @flash #flash +  /page -  = ;

( On S08, erasing the vectors means erasing the TRIM bytes, the secure
  bits, and the bootloader. So be careful about re-programming things, esp
  the TRIMs and the secure bits. Copy from ffac to ffaf.

  In the case that the chip is blank, and we've put trims into the image,
  don't overwrite these with the FF's from the chip.)

: save-trims  ( save them from the wrecking ball)
   cr ." save-trims"
   0ffac dup t.SetAddr  |+ ( 'image)  4 for
      t.Read  dup 0ff xor  if  over c! ( save in image)  else  drop  then
      1+  next  drop ;

( Flash vectors, security bytes, & trims)
: flash-vectors
   cr ." flashing vectors, security bytes, and trims"
   0ffac 14  ( 0ffac - 0ffcf)  program-row  ( trims and security bytes)
   0ffc0 40  ( 0ffc0 - 0ffff)  program-row  ( vectors) ;

( The only correct semantics for blank? are that when we are about to
  program the _first_ byte of a page, we check the entire page & erase it
  if necessary.)

: erased  ( 'target)
   dup [ /page 1- ] and  if  drop ^  then  ( do nothing if not first byte)
   dup blank?  if  drop ^  then
   dup last-page? if  ( erasing last page)
      save-trims  erase-page  flash-vectors  ^  then  ( normal case)
   erase-page ;

( For each row check if blank, erase if necessary, then copy rows over
  to buffer and program them!)

: row  ( 'target len - 'target+len)
   2dup + push  over erased  program-row  pop ;

: flash-region  ( a len)
   /row /mod  ( r q)  swap push  ?for   /row row  next  then
                            pop  =if  ( rem) row  drop ^  then  2drop ;

: flash-image   flash  |region ( a u)   flash-region ;

( Use this to initially set the value of "our" trim - the one that trims
  the internal osc to 9.216M.)
: set-trims ( ours factory-ftrim factory)
   0ffaf image-c!  0ffae image-c!  0ffad image-c! ;

: set-unsecured
   0fe 0ffbf image-c! ;  set-unsecured

.ifdef S08JS
( Bypass checksum check on JS parts.)
: bypass-checksum   0  0ffba image-c! ;  bypass-checksum
.then

( XXX This is a bit of a hack, but seems to work.)
: slow-verify   |region ( a u)  over t.SetAddr  swap image-p!
   for  image-c* t.Read       xor  if  image-p@ 1- u.  then  next ;

: verify-chunk  ( len)  dup t.StreamCount
   for  image-c* t.StreamRead xor  if  image-p@ 1- u.  then  next ;

( Fast verify! Using stream reads.)
: verify   |region ( a u)  over t.SetAddr  swap image-p!
   >lohi  swap push  ?for    100 verify-chunk  next  then
                pop  =if  ( rem) verify-chunk  ^  then  drop ;
