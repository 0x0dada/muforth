( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR chat-over-serial (core)

__meta

( Support for simple IIC chat with Atmel's 8-bit AVR family, using a
  serial-connected S08QE or QG as a master.)

( The style of this code was inspired by chat3.mu4. It's really just an
  experiment to see if the style that I wrote the USB chat firmware in
  works in this context too. The main difference is that the original chat
  code was a big loop, where the USB "loop" was a subroutine - which meant
  that to return the "top" from any piece of code all you do is _return_. And
  using tail calls, it's easy to code in a Forth-like style that is very
  efficient.)

hex

( Create a forward jump at the start of the flash sector.)
forward-jmp avr-chat-loop

( Our signature.)
label id
   char A c,  char V c,  char R c,  ( AVR architecture)
   char c c,                        ( chat)
   char 1 c,                        ( version 1)

( QE and QG parts have been trimmed to run at 9.216M so they can
  accurately generate 115200 bps clock. By using a divider of 24 we get an
  IIC clock of 384k.)

label InitIIC
   IICS 1 bset  ( clr IICIF)  ( clear lingering flags)
   -- %0000_0010 # ( mul=1, ICR=02: /24, sda hold 8~) IICF ) mov
   19 # ( mul=1, ICR=19: /96, sda hold 9~) IICF ) mov
   80 # IICC ) mov  ( enable IIC module)
   %0000_1100 # lda  PTADS ) sta ( high drive on SCL and SDA, A3, A2)
   rts  ;c

label get-serial  ( returns char in A)
   begin  SCIS1 5 ( recvr full)  bset? until
   SCID ) lda  rts  ;c

label put-serial  ( transmits char in A)
   begin  SCIS1 7 ( xmit empty)  bset? until
   SCID ) sta  rts  ;c

( Return a signature of who we are and what we're doing.)
label signon
   .h clr  .x clr
   begin  id ,x lda  put-serial c  .x inc  5 # cpx  0= until
   rts  ;c

label start-bit
   -- begin  IICS 5 ( bus busy)  bclr? until
   IICC 5 ( MST) bset
   IICS ) lda  ( return status)
   put-serial j  ;c

label restart-bit
   -- begin  IICS 5 ( bus busy)  bclr? until
   IICC 2 ( RSTA) bset
   IICS ) lda  ( return status)
   put-serial j  ;c

label stop-bit
   IICC 5 ( MST) bclr  rts  ;c

label iic-wait-complete
   begin  IICS 1 ( IICIF)  bset? until  ( transfer complete)
   IICS 1 bset  ( clr IICIF)  rts  ;c

label put-iic
   get-serial c
   IICC 4 ( TX) bset  IICD ) sta
   -- begin  IICS 7 ( TCF)  bset? until  ( transfer complete)
   iic-wait-complete c
   IICS ) lda  ( RXAK is bit 0)
   put-serial j  ;c

label get-iic
   IICC 4 ( TX) bclr
   IICD ) lda  ( dummy read to begin receive)
   -- begin  IICS 7 ( TCF)  bset? until  ( transfer complete)
   iic-wait-complete c
   IICD ) lda  ( get character)
   put-serial j  ;c

label get-iic-ack
   IICC 3 ( TXAK) bclr  ( ACK slave)  get-iic j  ;c

label get-iic-nack
   IICC 3 ( TXAK) bset  ( NACK slave)  get-iic j  ;c

( Commands:
0-2f  Bye        - exit AVR chat code and return to chat loop
  30  Start      - send START bit
  31  Restart    - send RESTART bit
  32  Stop       - send STOP bit
  33  Send       - send data byte, return ACK/NACK
  34  RecvAck    - receive data byte, send ACK
  35  RecvNack   - receive data byte, send NACK
)

label process-serial
   SCIS1 5 ( recvr full)  bclr? if  rts  then  ( nothing to do)
   SCID ) lda  ( command)

   ( NOTE: Command numbers are all given in HEX.)
   30 # sub   ( AVR chat commands start at 30 hex; anything below that, we exit)
   u< if  ( 00 - 2f Bye)  2 # ais  ( skip return from process-serial)  rts  then

   ( 30 Start)      start-bit              0!= until
   ( 31 Restart)    restart-bit    .a dec  0!= until
   ( 32 Stop)       stop-bit       .a dec  0!= until
   ( 33 SendByte)   put-iic        .a dec  0!= until
   ( 34 RecvAck)    get-iic-ack    .a dec  0!= until
   ( 35 RecvNack)   get-iic-nack   .a dec  0!= until

   ( unknown command)   rts  ;c

\l avr-chat-loop resolve>>  ( jump at start of Flash points here)
label main-loop
   InitIIC c    ( setup IIC interface)
   signon c     ( tell who we are and what we're doing)
   begin  process-serial c  again  ;c
