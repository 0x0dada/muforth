( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading AVR chat-over-serial (host)

( Host-side code to drive the AVR chat code in
  target/HC08/avrchat-serial-core.mu4.)

hex

( Commands:
0-2f  Bye        - exit AVR chat code and return to chat loop
  30  Start      - send START bit
  31  Restart    - send RESTART bit
  32  Stop       - send STOP bit
  33  Send       - send data byte, return ACK/NACK
  34  RecvAck    - receive data byte, send ACK
  35  RecvNack   - receive data byte, send NACK
  36  EndRecv    - read last byte received
)

.ifndef await
: await  ( a u)
   m preserve
   swap m !  for  m* recv  xor if  error" Wrong firmware"  then  next ;
.then

: twi.Bye  0 send ;
: twi.Hello  ( start the AVR chat firmware on the connected device)
.ifdef in-ram
   0112 c.SetPC c.Run  ( run from ram - loads right after flash routine)
.else
   0f800 c.SetPC c.Run
.then
   " AVRc1" await  ( match signature) ;

( Standard form for interact - we might also be using the serial chat for
  devices that lack a TWI.)

: avrchat.Hello    twi.Hello ;


( Some shorthands)
: S    ( start)    30 send ;
: PS   ( restart)  31 send ;
: P    ( stop)     32 send ;
: W    ( write)    33 send  send  recv drop ;  ( ACKs are wrong?!?)
: Ra   ( read)     34 send  recv ;  ( read and ACK)
: Rn   ( read)     35 send  recv ;  ( read and NACK)
: Re)  ( endread)  36 send  recv ;  ( read last byte)

-- : Aw   ( addr+write)  0fe W ;
-- : Ar   ( addr+read)   0ff W ;
: Aw   ( addr+write)  0b0 W ;
: Ar   ( addr+read)   0b1 W ;

: cmd  ( cmd)   S  Aw  W ;

( Because reads are pipelined - the first one returns junk, and the last
  byte must be fetched with Re) ( - let's make some shorthands for the
  initial read, which will always drop its result.)

: (Ra   Ra drop ;
: (Rn   Rn drop ;

( zp* and zpcell* read from _program_ memory. z* and zcell* read from
  _data_ memory.)

: z!       ( addr)  >hilo  10 cmd  W  W  P ;
: zp*      ( - b)          11 cmd        PS  Ar      (Rn  Re)  P ;
: zpcell*  ( - w)          11 cmd        PS  Ar  (Ra  Rn  Re)  P  lohi> ;
: z*       ( - b)          12 cmd        PS  Ar      (Rn  Re)  P ;
: zcell*   ( - w)          12 cmd        PS  Ar  (Ra  Rn  Re)  P  lohi> ;
: z&       ( b)            13 cmd  W     P ;
: zcell&   ( w)    >hilo   13 cmd  W  W  P ;
: zgo                      14 cmd        P ;

: zcmd   ( buf addr len cmd - len)  rot z!  cmd  swap m ! ;

: R?  ( len - len-1)  1-  =if  Ra ^  then  Rn ;

: zrcmd  constant  does> @  ( buf addr len cmd)
   over if
      zcmd  PS  Ar  R? drop  begin  =while  R? m&  repeat  drop  Re) m&  P  ^
   then  2drop 2drop ;

: zwcmd  constant  does> @  ( buf addr len cmd)
   over if
      zcmd  for  m* W  next  P  ^
   then  2drop 2drop ;

11 zrcmd zpread  ( buf addr len)
12 zrcmd zread   ( buf addr len)
13 zwcmd zwrite  ( buf addr len)

15 zrcmd zeread   ( buf addr len)  ( read eeprom)
16 zwcmd zewrite  ( buf addr len)  ( write eeprom)

( XXX Support for bootloader commands can wait. ;-)
