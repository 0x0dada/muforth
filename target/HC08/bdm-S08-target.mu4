( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HCS08 BDM target (host)

( This file contains the host-side code to talk to a BDM transport layer --
  either over serial or USB -- and expects to talk to an S08 target. There
  will eventually also be a ColdFire V1 version of this file.)

hex

( Non-intrusive)
: b.Background                                90 Send1  Expect0 ;
: b.WriteByte     ( byte a)           >lohi  0c0 Send4  Expect0 ;
: b.WriteByteS    ( byte a - status)  >lohi  0c1 Send4  Expect1 ;
: b.WriteControl  ( status)                  0c4 Send2  Expect0 ;
: b.ReadByte      ( a - byte)         >lohi  0e0 Send3  Expect1 ;
: b.ReadByteS     ( a - status byte)  >lohi  0e1 Send3  Expect2 ;
: b.ReadStatus    ( - status)                0e4 Send1  Expect1 ;

( Active - must be in "active BDM" mode to use.)
: b.Go           08 Send1  Expect0 ;
: b.Trace        10 Send1  Expect0 ;
: b.ReadA        68 Send1  Expect1 ;
: b.ReadCC       69 Send1  Expect1 ;
: b.ReadPC       6b Send1  Expect2  hilo> ;
: b.ReadHX       6c Send1  Expect2  hilo> ;
: b.ReadSP       6f Send1  Expect2  hilo>  1+ ( normalised!) ;
: b.ReadNext     70 Send1  Expect1 ; ( inc HX, then read byte)
: b.ReadNextS    71 Send1  Expect2 ; ( inc HX, read status, read byte)

: b.WriteA               48 Send2  Expect0 ;
: b.WriteCC              49 Send2  Expect0 ;
: b.WritePC       >lohi  4b Send3  Expect0 ;
: b.WriteHX       >lohi  4c Send3  Expect0 ;
: b.WriteSP   1-  >lohi  4f Send3  Expect0 ; ( normalised!)
: b.WriteNext            50 Send2  Expect0 ; ( inc HX, write byte)
: b.WriteNextS           51 Send2  Expect1 ; ( inc HX, write byte, read status)

comment Commands
d = delay 16 BDM cycles
r = read one byte
w = write one byte

Non-intrusive
=============
Background   90 d
ReadStatus   e4 r
WriteControl c4 w
ReadByte     e0 w w d r    -- write addr, read byte
ReadByteS    e1 w w d r r  -- write addr, read status, read byte
ReadLast     e8 r r        -- read status, read last byte read
WriteByte    c0 w w w d
WriteByteS   c1 w w w d r  -- write addr, write byte, read status
ReadBkpt     e2 r r
WriteBkpt    c2 w w

Active mode
===========
Go           08 d
Trace        10 d
ReadA        68 d r
ReadCC       69 d r
ReadPC       6b d r r
ReadHX       6c d r r
ReadSP       6f d r r
ReadNext     70 d r         -- inc HX, then read byte
ReadNextS    71 d r r       -- inc HX, read status, read byte
WriteA       48 w d
WriteCC      49 w d
WritePC      4b w w d
WriteHX      4c w w d
WriteSP      4f w w d
WriteNext    50 w d         -- inc HX, write byte
WriteNextS   51 w d r       -- inc HX, write byte, read status

comment Commands


( BDM versions of interact operations)

( Since WriteNext and ReadNext _pre-increment_, let's subtract one when we
  set the address, and add one when we read it.)
: b.SetAddr           -1 +a  b.WriteHX ;
: b.GetAddr  b.ReadHX  1 +a ;

( XXX should be a limited number of tries)
: b.RunWait  b.Go  begin  b.ReadStatus  40 and until ;

: b.setup-chunk  ( 'target len buffer - len)
   p!  swap b.SetAddr ;

: b.ReadChunk    ( 'target len buffer)
   b.setup-chunk  for  b.ReadNext c&  next ;

: b.WriteChunk   ( 'target len buffer)
   b.setup-chunk  for  c* b.WriteNext  next ;

( Order of regs in memory: H CC A X PC)
: b.GetRegs  ( buf - sp)  p!
   b.ReadHX >lohi ( X H) c&  b.ReadCC c&  b.ReadA c& ( X) c&
   b.ReadPC >lohi c& c&  b.ReadSP ;

: b.SetRegs  ( buf)  p!
   c* ( H)  c* b.WriteCC  c* b.WriteA  c* ( H X ) hilo> b.WriteHX
   c* c* hilo> b.WritePC ;

.ifdef bdm-flash-no-ram

( Let's do this over BDM again, instead of running a ram routine. Warning:
  doing it this way is *really* slow!)

variable bdm-flash-command
: b.flash-byte  ( byte)
   b.WriteNext  bdm-flash-command @  \l FCMD b.WriteByte
   80 \l FSTAT b.WriteByte
   begin  \l FSTAT b.ReadByte  40 and  until ;

: b.FlashChunk   ( 'target len buffer cmd - status)
   bdm-flash-command !
   30 \l FSTAT b.WriteByte  ( clear flash errors)
   b.setup-chunk  for  c* b.flash-byte  next
   \l FSTAT b.ReadByte  ( return flash status) ;

.else  ( bdm-flash-using-ram)

( We've already written the byte, so jump to lda command)
: b.flash-byte  ( byte)
   b.WriteNext  b.RunWait ;

: b.FlashChunk   ( 'target len buffer cmd - status)
   30 \l FSTAT b.WriteByte  ( clear flash errors)
       ( cmd) \l flash-command  b.WriteByte
   \l do-flash-command b.WritePC
   b.setup-chunk  for  c* b.flash-byte  next
   \l FSTAT b.ReadByte  ( return flash status) ;

.then

: b.VerifyChunk   ( 'target len - flag)
   over image+ b.setup-chunk
   for  b.ReadNext c*  xor  if  image-p@ -1 +a u.  then  next ;

: ResetSP
   @ram #ram +  b.WriteSP ;

( Bollocks! Even this is different between variants. The JS/JM/SH uses two bits
  to select which kind of watchdog; setting both to zero is required to
  disable it. It looks like it's safe to write both bits 7 and 6 to zero to
  disable the dog on the parts I've looked at...

  It looks like newer parts are using this more sophisticated watchdog.
  Rather than just write to a memory location, you have to write 55 then
  AA.)

: NoWatchdog
   \l SOPT1 b.ReadByte  3f and  \l SOPT1 b.WriteByte ;

( I've decided we shouldn't do this. It's too complicated. Not only do
  different parts use different clocks - ICG, ICS, MCG - but even the parts
  that have ICS put the registers in different places! So ICSTRM is _not_
  always at 003a.

  How about instead we simply leave the part untrimmed, in its BDIV=2 state
  - running at half speed - and set FCDIV so that no matter what, its value
  makes sense.

  Using a divisor of 25 seems safe. The untrimmed speed of the DCO should
  fall between 16M and 20M, putting the bus clock between 4M and 5M. A
  divisor of 25 puts the flash clock into the range of 160k to 200k, which
  is perfect.

  But this is specific to the QG! I need a table of values somewhere...

  Another approach is to have the device file set TRIM to ICSTRM, ICGTRM,
  MCGTRM. I still need to know what each part's POR bus clock speed and BDM
  clock are... put these into the device file!)

( Trim internal oscillator to factory setting; on QG parts this is 31.25k,
  which results in 16M FLL frequency; this is divided by two to give a
  default BDM freq of 8M, and divided by two again - because of reset BDIV
  setting - to give a reset bus clock of 4M.)

: TrimOsc
   0ffaf ( factory trim) b.ReadByte  \l TRIM b.WriteByte ;

( Set FCDIV to correspond to bus clock at power-on-reset. As an added
  bonus, we don't subtract one from the divisor, so it's one bigger than it
  needs to be; this gives us a bit of cushion in case the factory trim has
  the clock running fast. In the case of QG parts - 4M bus clock out of POR
  - this puts the Flash clock at 190k instead of 200k.)

: SetFCDIV
   \l FCDIV b.ReadByte  80 and if ^ then  ( already set)
   [ \l POR-bus-clock  khz>fcdiv ]  ( divide freq by 200k, rounding up)
   \l FCDIV b.WriteByte ;

(  If trim found in flash, trim oscillator and also set FCDIV. If not found,
  print a message and leave everything alone.)

: SetupClock
   0ffaf ( factory trim) b.ReadByte  0ff = if
   ." 
Trim in flash is 0ff; didn't set TRIM or FCDIV. You have to do this by hand.
"  ^  then
   TrimOsc  SetFCDIV ;

comment misguided
( Based on what we get back from b.Sync, match BDM clock)
( XXX - this is currently based on 908's 4.608M clock)
: MatchBDMClock
   b.Sync 70 - 21 u< if  ( within +-"10 of 80 - running at 4M)
      b.Clock4M ^ then
   b.Clock8M ;

: FastBusClock
   ( assume osc trimmed)
   MatchBDMClock
   \l ICSC2 b.ReadByte  3f and ( clear BDIV)  \l ICSC2 b.WriteByte
   b.Clock8M ;

comment misguided

( Get target into a known, safe state. Chat code will have done this for
  itself at reset, so this is only necessary for BDM targets.)

( Since we are flashing - even via BDM - by executing code from RAM, we
  have to initialise the chip first.)

: b.Hi
   SetupClock ( trim & fcdiv)  NoWatchdog  ResetSP
   \l flash-byte  \l flash-end  over -  put-region
   82 ( bgnd) \l flash-exit  b.WriteByte ;

   -- hi ( copy ram flash routine)
   -- broken because chat copies to
   -- connected device and resets pointer to show that the target is synced
   -- with host) ;

: try-clock
   b.ReadStatus dup u.  0c8 = if  b.Hi  -1 ^  then  0 ;

: pwr  b.BkgdLow  ." power cycle S08, then press a key..."  key drop
       b.BkgdHiZ   b.Sync u.  b.Sync u.
       b.Clock4M try-clock  if ^ then
       b.Clock8M try-clock  if ^ then
       ." Didn't get a valid status over BDM." ;

( Get start address of BDM code.)
variable bdm-ram-start  ( filled in by loaded code)
: bdm-start  ( - a)
   t.Id 0ff = if  0fb00  ( 908, flash version)   ^ then

   .ifdef bdm-in-ram   bdm-ram-start @ ( S08, ram version)
      .else .ifdef usb-target
                       0fa00  ( S08, USB, flash version)
               .else   0fc00  ( S08, serial, flash version)
   .then .then ;

decimal

: bdm
.ifdef serial-target
   .ifdef chat-slow  ( using a xtal that only allows 38400)
       38400 bps
   .else
      115200 bps
   .then
.then

   bdm-start pc!  SetRegs  t.Run   ( start bdm chat loop)

   ( Wire our versions into the interact code.)
   ['] b.RunWait is t.RunWait
   ['] b.Go is t.Run  ( keeping b.Go since it's a BDM command name)
   ['] b.GetRegs is t.GetRegs
   ['] b.SetRegs is t.SetRegs
   ['] b.SetAddr is t.SetAddr
   ['] b.GetAddr is t.GetAddr
   ['] b.ReadNext is t.Read
   ['] b.WriteNext is t.Write
   ['] b.ReadChunk is t.ReadChunk
   ['] b.WriteChunk is t.WriteChunk
   ['] b.FlashChunk is t.FlashChunk
   ['] b.VerifyChunk is t.VerifyChunk

   ( We'd like to set BDM clock from Sync pulse, but it doesn't seem to
     work. A hack is to set it instead from the chip defs that we load.)
   -- \l POR-bus-clock #4000 = if  b.Clock4M  else  b.Clock8M  then

   +chat  pwr ;

( Handy shortcuts - esp for testing.)
: s  b.Sync u. ;
: t  b.Trace  GetRegs .r ;
: w  b.WriteByte ;
: r  b.ReadByte ;
