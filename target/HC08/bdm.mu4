( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

cr " HCS08 BDM support " file[#

( Support for Freescale's Background Debug Mode - or BDM.)

( I originially wrote this code "flattened" out but I want to run it from
  the small RAM in a 908, and it won't fit. I don't see why I can't make
  the bit transmit and receive code _routines_ rather than macros. What
  matters is the timing _within_ a bit, not as much between bits. As long
  as no more than 512 cycles elapse between falling edges, the interface
  will not time out.)

( Using the internal osc on the 908QB8, running at 3.2MHz, I wasn't able to
  run fast enough to talk to a 9S08QG8, running at 8MHz. I dug out a 25MHz
  crystal, which will give me a 6.25MHz bus speed, which should be plenty
  fast enough.

  Of course, now I have to rewrite my bit rx and tx routines. ;-)

( Another update. I've decided to try using an 18.432MHz crystal on the
  908QB. This way I get a nice even divisor for a 57600 bps serial clock,
  and it seems to be fast enough to talk to an S08 part running at either
  4MHz or 8MHz.

  It turns out that because the 9S08QG8, when mostly blank, is hard to get
  into Active BDM mode. On POR - power on reset - it starts running random
  code and either gets a COP - watchdog - reset, or an illegal instruction,
  or illegal address. So it resets and starts all over again. Trying to get
  into Active BDM via the BKGD pin is basically impossible. There is a
  forum posting about this here:

  http://forums.freescale.com/freescale/board/message?message.uid=11435#U11435

  So, given that, we have to hold BKGD/MS low during POR in order to force
  the chip into Active BDM mode. A side-effect of this is that it selects
  the bus clock - rather than the "alternate" BDM clock - ICSLCLK - so the
  BDM will be running at 4MHz instead of 8. This makes life simpler in some
  ways, but it turns out that it's pretty easy to meet the timing specs for
  both 4M and 8M BDM with the 908QB8 running at 18.432M.)

( Now we're reading BKGD on PB7 thru an HCT244 gate. We drive BKGD _low_ by
  driving 0 on PB3, and drive it _high_ by driving PB0 low and PB1 high.
  The BKGD_foo defines are for PortB data direction bits - we never change
  the values driven.)

__outside

02 equ PortBinit  ( PB3 low, PB1 high, PB0 low)
08 equ BKGD_L     ( drive PB3)
03 equ BKGD_H     ( drive PB1, PB0)

( We are now calling the BDM bit send/recv commands _indirectly_, so we can
  wire them to the correct ones for a given target clock rate. For now we
  have targets of 4M and 8M only.)
3 var BdmRx1  ( jmp extended to actual routine)
3 var BdmTx1

code SetRx1
   0cc # lda  ( jmp extended)  BdmRx1 ) sta
   .a pul  ( hi)  BdmRx1 1 + ) sta
   .a pul  ( lo)  BdmRx1 2 + ) sta  rts  ;c

code SetTx1
   0cc # lda  ( jmp extended)  BdmTx1 ) sta
   .a pul  ( hi)  BdmTx1 1 + ) sta
   .a pul  ( lo)  BdmTx1 2 + ) sta  rts  ;c

( BDM code for host running at 4.608M, and target at 4M or 8M.)

code SetTx1_4M
   SetTx1 bsr  ;c   -- pushes address of following routine on stack!

( Send one bit via BDM - target @ 4M.)
code tx1_4m  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  0 ,x tst                  ( pr     - delay 2 cycles)
  PortBdir ) sta            ( pwp    - drive data bit)
  nsa nsa                   ( ppdppd - pause 6 cycles)
  BKGD_H # PortBdir ) mov   ( ppwp   - drive stop bit)
  rts  ;c

code SetRx1_4M
   SetRx1 bsr  ;c   -- pushes address of following routine on stack!

( Recv one bit via BDM - target @ 4M.)
code rx1_4m  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  0 ,x tst                  ( pr     - delay 2 cycles)
  PortBdir ) clr            ( pwp    - undrive PortB)
  nsa nop                   ( ppdp   - wait for target to drive its bit)
  PortB ) lda               ( prp    - sample bit)
  rts  ;c

( BDM code for host running at 4.608M, and target at 8M.)

code SetTx1_8M
   SetTx1 bsr  ;c   -- pushes address of following routine on stack!

( Send one bit via BDM - target @ 8M.)
code tx1_8m  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  PortBdir ) sta            ( pwp    - drive data bit)
  nop                       ( p      - pause 1 cycle)
  BKGD_H # PortBdir ) mov   ( ppwp   - drive stop bit)
  rts  ;c

code SetRx1_8M
   SetRx1 bsr  ;c   -- pushes address of following routine on stack!

( Recv one bit via BDM - target @ 8M.)
code rx1_8m  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  PortBdir ) clr            ( pwp    - undrive PortB)
  PortB ) lda               ( prp    - sample bit)
  rts  ;c

comment *6.25M*
( BDM code for host running at 6.25M, and target at 8M.)
( These are currently UNUSED; from when I was using a 25M crystal.)

( Send one bit via BDM.)
macro tx1  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( drive start bit)
  PortBdir ) sta            ( drive data bit)
  nsa                       ( pause)
  BKGD_H # PortBdir ) mov   ( drive stop bit)
  ;m

( Recv one bit via BDM.)
macro rx1  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( drive start bit)
  PortBdir ) clr            ( undrive PortB)
  nop                       ( wait for target to drive its bit)
  PortB ) lda               ( sample bit)
  ;m

*6.25M*

( Send one byte via BDM.)
( NOT the usual X stack discipline with two slots free!)
code BdmTx  ( tx byte at 0,x)
   ( loop 8; generate bits MSB first)
   8 # lda   .a psh
   begin  0 ,x rol  CS if  BKGD_H # lda  else  BKGD_L # lda  then
      BdmTx1 ) jsr   0 ,s decz?  until
   PortBdir ) clr   -- tristate when done xmitting
   .a pul
   1 # aix   rts  ;c

( Recv one byte via BDM.)
( NOT the usual X stack discipline with two slots free!)
code BdmRx  ( recvd byte to 0,x)
  ( loop 8; recv bits MSB first; bit is 80)
   8 # lda   .a psh   0 ,x clr
   begin   BdmRx1 ) jsr  .a rol  ( PortB7 -> C)  0 ,x rol
           0 ,s decz?  until
   .a pul
   1 # aix   rts  ;c

code SciRxBuf
   SciRx ) jsr  0 ,x sta  1 # aix  rts  ;c

code SciTxBuf
   begin  SCS1 ( status 1) 7 ( xmit empty)  bset? until
   0 ,x  SCDR ( data) ) mov  rts  ;c  ( the mov does post-incr of HX)

( BdmChat uses the following stack frame:
  0,s to 3,s   read and write buffer
  4,s          write count
  5,s          read count
  6,s          current count)

code BdmChat
   -7 # ais   ( room for read and write counts, cur count, and buffer)
label BdmLoop
   SciRx ) jsr
   0= if ( Bye)  ( return to byteloader)  7 # ais  rts  then

   05 # cmp  u< if  ( Write1..4)
      4 ,s sta  ( write count)
      6 ,s sta  ( count)
      tsx  ( point HX at start of buffer)
      begin  SciRxBuf bsr  6 ,s decz? until  ( get write count bytes from SCI)
      ( __swi)  BdmLoop again  then

   08 # cmp  u< if  ( Execute BDM, Read 0..1)
      05 # sub
      5 ,s sta  ( read count)

      4 ,s lda  ( get write count)
      6 ,s sta  ( count)
      tsx  ( point HX at start of buffer)
      begin  BdmTx ) jsr  6 ,s decz? until  ( write bytes via BDM)
      nsa nsa  ( delay a bit - we're supposed to wait 16 BDM cycles)
               ( instruction overhead between here and driving BKGD)
               ( is at least 16 host cycles)

      5 ,s lda  0= if  ( read count zero)
         SciTxBuf bsr  ( send back a junk byte - keep host from outrunning us)
      else
         6 ,s sta  ( count)
         tsx  ( point HX at start of buffer)
         begin  BdmRx ) jsr  6 ,s decz? until  ( read bytes via BDM)

         tsx  ( point HX at start of buffer)
         5 ,s lda  ( get read count)
         6 ,s sta  ( count)
         begin  SciTxBuf bsr  6 ,s decz? until  ( send response back via SCI)
      then
      ( __swi)  then

   ( Sync)  ( do nothing at all!)  BdmLoop again  ;c

code BdmSetup
   SetTx1_4M ) jsr
   SetRx1_4M ) jsr
   PortBinit # PB ) mov
   BKGD_L # PortBdir ) mov   -- drive BKGD/MS low
   08 # lda  -- remind user to power cycle the S08
   __swi
   PortBdir ) clr  rts  ;c

comment dispatch-ideas

How about the following commands:
0 Bye - escape back to byteloader
1 Write 1 from SCI -> buffer
2 ditto, 2 bytes
3 ditto, 3
4 ditto, 4
5 write to BDM, read nothing
6 ditto, read 1, write to SCI
7 ditto, read 2 write to SCI
8+ Sync/No-op

Nine commands!

Read Status: 01 E4 05
Read A: 01 68 06
Read HX: 01 6C 07
WriteHX: 03 4C hi lo 05

We can always re-sync by writing 00 00 00 00.

Wanting to keep same "almost stateless" design as the byteloader. So, we
have the following commands:

Set write count
Set read count
Set byte (0..3)
Read byte (0..1)
Execute
Bye  ( escape back to byteloader)

So, for example, to execute the Read Status command, we do the following:
SetWriteCount(1)
SetReadCount(0)
SetByte0(0e4)
Execute

And to Read HX we do this:
SetWriteCount(1)
SetReadCount(2)
SetByte0(6c)
Execute
GetByte0 -> H
GetByte1 -> X

To Write a Byte (in background mode):
SetWriteCount(4)
SetReadCount(0)
SetByte0(0c0)
SetByte1(hi)
SetByte2(lo)
SetByte3(data)
Execute

Seems a bit inefficient, though - right?

How about a hybrid approach? We keep as much state as possible.. We'll
still need Set0..2 and Get0..1. But if the commands are mapped to the
actual BDM commands, and the "logic" is on the 908, that might be better.
The above examples would then look more like this:

ReadStatus
Get0

ReadHX
Get0 -> H
Get1 -> X

Set0(a_hi)
Set1(a_lo)
Set2(data)
WriteByte

That seems better... and common commands (running in Active mode) would
look like this:

ReadA
Get0

Set0
WriteA

All this is crazy - we just implement things the "normal" way - with the
exception that we number the commands from zero, for easier dispatching,
and we make command 0 be "Sync", which is a no-op. This is so we can easily
resync the protocol. By sending three 0 chars we fulfil any commands need
for bytes and if we exceed it, we loop at Sync.

comment dispatch-ideas

comment *3.2M*
( Compressing three transitions into one byte:
   Hxx  10
   xHx  08
   xxH  04
   Lxx  80
   xLx  40
   xxL  20
                    L  H
   tx1 = LHH = 8c = 1000_1100
   tx0 = LLH = c4 = 1100_0100  )

( Send one bit via BDM.)
code tx1  ( tx bit in A)
  savex  PortBdir # ldx
  0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta
  restx  rts  ;c

( Recv one bit via BDM.)
code rx1  ( recvd bit in A1)
  savex  PortBdir # ldx
  80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PortA ) lda
  restx  rts  ;c

( Send one byte via BDM.)
code tx8  ( tx byte in A)
   ( loop 8; generate bits MSB first)
   0 ,x sta   8 # lda   1 ,x sta
   begin  0 ,x rol  CS if  8c # lda  else  0c4 # lda  then
      tx1 bsr   1 ,x decz?  until
   rts  ;c

( Recv one byte via BDM.)
code rx8  ( recvd byte in A)
  ( loop 8; recv bits MSB first; bit is 02)
  8 # lda   1 ,x sta   0 ,x clr
  begin   rx1 bsr   .a ror  .a ror  ( PortA.1 -> C)  0 ,x rol
          1 ,x decz?  until
  0 ,x lda  ( byte into A)
  rts  ;c
*3.2M*

0 [if]
code InitBdm
  BKGD_H # PortB ) mov   -- BKGD_L 0, BKGD_H 1
  PortBdir ) clr
  rts  ;c

-- macro savex   xSaved ) stx  ;m
-- macro restx   xSaved ) ldx  ;m
macro savex   .x psh  ;m
macro restx   .x pul  ;m

( Archive this here.)

( Send one bit via BDM.)
macro tx1
   .a pul   0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta  ;m

( Recv one bit via BDM.)
macro rx1
   80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PortA ) lda   .a psh  ;m

macro savex   xSaved ) stx  ;m
macro restx   xSaved ) ldx  ;m

code tx8
   ( loop 8; generate bits LSB first; then we'll pop them MSB first)
   8 # lda   0 ,x sta
   begin  2 ,x ror  CS if  8c # lda  else  0c4 # lda  then
          .a psh  0 ,x decz?  until
   savex  ( XXX if I moved this above the pushes, it could psh onto stack...)
   PortBdir # ldx
   tx1  tx1  tx1  tx1
   tx1  tx1  tx1  tx1
   restx   2 # aix  ( pop xmitted byte)
   rts  ;c

code rx8
   savex
   PortBdir # ldx
   rx1  rx1  rx1  rx1
   rx1  rx1  rx1  rx1
   restx
   ( loop 8; pop bits LSB first; bit is 02)
   8 # lda   1 ,x sta   0 ,x clr
   begin   .a pul  .a ror  .a ror  ( PortA.2 -> C)  0 ,x ror
           1 ,x decz?  until
   -2 # aix  ( promote scratch - recvd char - to TOP)
   rts  ;c

[then]

#]file
