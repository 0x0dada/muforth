( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

cr " HCS08 BDM support " file[#

( Support for Freescale's Background Debug Mode - or BDM.)

( I originially wrote this code "flattened" out but I want to run it from
  the small RAM in a 908, and it won't fit. I don't see why I can't make
  the bit transmit and receive code _routines_ rather than macros. What
  matters is the timing _within_ a bit, not as much between bits. As long
  as no more than 512 cycles elapse between falling edges, the interface
  will not time out.)

( Using the internal osc on the 908QB8, running at 3.2MHz, I wasn't able to
  run fast enough to talk to a 9S08QG8, running at 8MHz. I dug out a 25MHz
  crystal, which will give me a 6.25MHz bus speed, which should be plenty
  fast enough.

  Of course, now I have to rewrite my bit rx and tx routines. ;-)

( Another update. I've decided to try using an 18.432MHz crystal on the
  908QB. This way I get a nice even divisor for a 57600 bps serial clock,
  and it seems to be fast enough to talk to an S08 part running at either
  4MHz or 8MHz.

  It turns out that because the 9S08QG8, when mostly blank, is hard to get
  into Active BDM mode. On POR - power on reset - it starts running random
  code and either gets a COP - watchdog - reset, or an illegal instruction,
  or illegal address. So it resets and starts all over again. Trying to get
  into Active BDM via the BKGD pin is basically impossible. There is a
  forum posting about this here:

  http://forums.freescale.com/freescale/board/message?message.uid=11435#U11435

  So, given that, we have to hold BKGD/MS low during POR in order to force
  the chip into Active BDM mode. A side-effect of this is that it selects
  the bus clock - rather than the "alternate" BDM clock - ICSLCLK - so the
  BDM will be running at 4MHz instead of 8. This makes life simpler in some
  ways, but it turns out that it's pretty easy to meet the timing specs for
  both 4M and 8M BDM with the 908QB8 running at 18.432M.)

( Now we're reading BKGD on PB7 thru an HCT244 gate. We drive BKGD _low_ by
  driving 0 on PB3, and drive it _high_ by driving PB0 low and PB1 high.
  The BKGD_foo defines are for PortB data direction bits - we never change
  the values driven.)

ram-start image

__outside

02 equ PortBinit  ( PB3 low, PB1 high, PB0 low)
08 equ BKGD_L     ( drive PB3)
03 equ BKGD_H     ( drive PB1, PB0)

( We are now calling the BDM bit send/recv commands _indirectly_, so we can
  wire them to the correct ones for a given target clock rate. For now we
  have targets of 4M and 8M only.)
3 var BdmRx1  ( jmp extended to actual routine)
3 var BdmTx1

code SetRx1
   0cc # lda  ( jmp extended)  BdmRx1 ) sta
   .a pul  ( hi)  BdmRx1 1 + ) sta
   .a pul  ( lo)  BdmRx1 2 + ) sta  rts  ;c

code SetTx1
   0cc # lda  ( jmp extended)  BdmTx1 ) sta
   .a pul  ( hi)  BdmTx1 1 + ) sta
   .a pul  ( lo)  BdmTx1 2 + ) sta  rts  ;c

( BDM code for host running at 4.608M, and target at 4M or 8M.)

code SetTx1_4M
   SetTx1 bsr  ;c   -- pushes address of following routine on stack!

( Send one bit via BDM - target @ 4M.)
code tx1_4m  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  0 ,x tst                  ( pr     - delay 2 cycles)
  PortBdir ) sta            ( pwp    - drive data bit)
  nsa nsa                   ( ppdppd - pause 6 cycles)
  BKGD_H # PortBdir ) mov   ( ppwp   - drive stop bit)
  rts  ;c

code SetRx1_4M
   SetRx1 bsr  ;c   -- pushes address of following routine on stack!

( Recv one bit via BDM - target @ 4M.)
code rx1_4m  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  0 ,x tst                  ( pr     - delay 2 cycles)
  PortBdir ) clr            ( pwp    - undrive PortB)
  nsa nop                   ( ppdp   - wait for target to drive its bit)
  PortB ) lda               ( prp    - sample bit)
  rts  ;c

( BDM code for host running at 4.608M, and target at 8M.)

code SetTx1_8M
   SetTx1 bsr  ;c   -- pushes address of following routine on stack!

( Send one bit via BDM - target @ 8M.)
code tx1_8m  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  PortBdir ) sta            ( pwp    - drive data bit)
  nop                       ( p      - pause 1 cycle)
  BKGD_H # PortBdir ) mov   ( ppwp   - drive stop bit)
  rts  ;c

code SetRx1_8M
   SetRx1 bsr  ;c   -- pushes address of following routine on stack!

( Recv one bit via BDM - target @ 8M.)
code rx1_8m  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  PortBdir ) clr            ( pwp    - undrive PortB)
  PortB ) lda               ( prp    - sample bit)
  rts  ;c

comment *6.25M*
( BDM code for host running at 6.25M, and target at 8M.)
( These are currently UNUSED; from when I was using a 25M crystal.)

( Send one bit via BDM.)
macro tx1  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( drive start bit)
  PortBdir ) sta            ( drive data bit)
  nsa                       ( pause)
  BKGD_H # PortBdir ) mov   ( drive stop bit)
  ;m

( Recv one bit via BDM.)
macro rx1  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( drive start bit)
  PortBdir ) clr            ( undrive PortB)
  nop                       ( wait for target to drive its bit)
  PortB ) lda               ( sample bit)
  ;m

*6.25M*

( Send one byte via BDM.)
( NOT the usual X stack discipline with two slots free!)
code BdmTx  ( tx byte at 0,x)
   ( loop 8; generate bits MSB first)
   8 # lda   .a psh
   begin  0 ,x rol  CS if  BKGD_H # lda  else  BKGD_L # lda  then
      BdmTx1 ) jsr   0 ,s decz?  until
   PortBdir ) clr   -- tristate when done xmitting
   .a pul
   1 # aix   rts  ;c

( Recv one byte via BDM.)
( NOT the usual X stack discipline with two slots free!)
code BdmRx  ( recvd byte to 0,x)
  ( loop 8; recv bits MSB first; bit is 80)
   8 # lda   .a psh   0 ,x clr
   begin   BdmRx1 ) jsr  .a rol  ( PortB7 -> C)  0 ,x rol
           0 ,s decz?  until
   .a pul
   1 # aix   rts  ;c

comment Commands
d = delay 16 BDM cycles
r = read one byte
w = write one byte

Non-intrusive
=============
Background   90 d
ReadStatus   e4 r
WriteControl c4 w
ReadByte     e0 w w d r    -- write addr, read byte
ReadByteS    e1 w w d r r  -- write addr, read status, read byte
ReadLast     e8 r r        -- read status, read last byte read
WriteByte    c0 w w w d
WriteByteS   c1 w w w d r  -- write addr, write byte, read status
ReadBkpt     e2 r r
WriteBkpt    c2 w w

Active mode
===========
Go           08 d
Trace        10 d
ReadA        68 d r
ReadCC       69 d r
ReadPC       6b d r r
ReadHX       6c d r r
ReadSP       6f d r r
ReadNext     70 d r         -- inc HX, then read byte
ReadNextS    71 d r r       -- inc HX, read status, read byte
WriteA       48 w d
WriteCC      49 w d
WritePC      4b w w d
WriteHX      4c w w d
WriteSP      4f w w d
WriteNext    50 w d         -- inc HX, write byte
WriteNextS   51 w d r       -- inc HX, write byte, read status

w1r0
w1r1
w1r2
w2r0
w2r1
w3r0
w3r1
w3r2
w4r0
w4r1

comment Commands

code BdmDelayBackup
   nsa nsa  -1 # aix  rts  ;c

code WriteCmd
   ( in A)
   0 ,x sta  ( command)  BdmTx again  ;c  

code ReadBdm8
   -- send 8 bit command, expect one byte back
   WriteCmd bsr  BdmDelayBackup bsr  BdmRx again  ;c

code ReadBdm16
   -- send 8 bit command, expect two bytes back
   ReadBdm8 bsr  BdmRx again  ;c

code ReadHX
   6c # lda  ReadBdm16 again  ;c

code WriteHX
   ( H @ 0,x; X in A)
   -1 # aix
   2 ,x sta
   4c # lda  ( WRITE_HX command)  WriteCmd bsr
   BdmTx bsr  BdmTx bsr  -1 # aix  BdmDelayBackup again  ;c

code ReadNext
   70 # lda   ReadBdm8  again  ;c

code BdmSetup
   SetTx1_4M ) jsr
   SetRx1_4M ) jsr
   PortBinit # PB ) mov
   BKGD_L # PortBdir ) mov   -- drive BKGD/MS low
   08 # lda  -- remind user to power cycle the S08
   __swi
   PortBdir ) clr
   0e4 # lda   ReadBdm8  again  ;c

comment *3.2M*
( Compressing three transitions into one byte:
   Hxx  10
   xHx  08
   xxH  04
   Lxx  80
   xLx  40
   xxL  20
                    L  H
   tx1 = LHH = 8c = 1000_1100
   tx0 = LLH = c4 = 1100_0100  )

( Send one bit via BDM.)
code tx1  ( tx bit in A)
  savex  PortBdir # ldx
  0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta
  restx  rts  ;c

( Recv one bit via BDM.)
code rx1  ( recvd bit in A1)
  savex  PortBdir # ldx
  80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PortA ) lda
  restx  rts  ;c

( Send one byte via BDM.)
code tx8  ( tx byte in A)
   ( loop 8; generate bits MSB first)
   0 ,x sta   8 # lda   1 ,x sta
   begin  0 ,x rol  CS if  8c # lda  else  0c4 # lda  then
      tx1 bsr   1 ,x decz?  until
   rts  ;c

( Recv one byte via BDM.)
code rx8  ( recvd byte in A)
  ( loop 8; recv bits MSB first; bit is 02)
  8 # lda   1 ,x sta   0 ,x clr
  begin   rx1 bsr   .a ror  .a ror  ( PortA.1 -> C)  0 ,x rol
          1 ,x decz?  until
  0 ,x lda  ( byte into A)
  rts  ;c
*3.2M*

0 [if]
code InitBdm
  BKGD_H # PortB ) mov   -- BKGD_L 0, BKGD_H 1
  PortBdir ) clr
  rts  ;c

-- macro savex   xSaved ) stx  ;m
-- macro restx   xSaved ) ldx  ;m
macro savex   .x psh  ;m
macro restx   .x pul  ;m

( Archive this here.)

( Send one bit via BDM.)
macro tx1
   .a pul   0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta  ;m

( Recv one bit via BDM.)
macro rx1
   80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PortA ) lda   .a psh  ;m

macro savex   xSaved ) stx  ;m
macro restx   xSaved ) ldx  ;m

code tx8
   ( loop 8; generate bits LSB first; then we'll pop them MSB first)
   8 # lda   0 ,x sta
   begin  2 ,x ror  CS if  8c # lda  else  0c4 # lda  then
          .a psh  0 ,x decz?  until
   savex  ( XXX if I moved this above the pushes, it could psh onto stack...)
   PortBdir # ldx
   tx1  tx1  tx1  tx1
   tx1  tx1  tx1  tx1
   restx   2 # aix  ( pop xmitted byte)
   rts  ;c

code rx8
   savex
   PortBdir # ldx
   rx1  rx1  rx1  rx1
   rx1  rx1  rx1  rx1
   restx
   ( loop 8; pop bits LSB first; bit is 02)
   8 # lda   1 ,x sta   0 ,x clr
   begin   .a pul  .a ror  .a ror  ( PortA.2 -> C)  0 ,x ror
           1 ,x decz?  until
   -2 # aix  ( promote scratch - recvd char - to TOP)
   rts  ;c

[then]

#]file
