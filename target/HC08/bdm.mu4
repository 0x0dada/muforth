( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

cr " HCS08 BDM support " file[#

( Support for Freescale's Background Debug Mode - or BDM.)

( I originially wrote this code "flattened" out but I want to run it from
  the small RAM in a 908, and it won't fit. I don't see why I can't make
  the bit transmit and receive code _routines_ rather than macros. What
  matters is the timing _within_ a bit, not as much between bits. As long
  as no more than 512 cycles elapse between falling edges, the interface
  will not time out.)

( Using the internal osc on the 908QB8, running at 3.2MHz, I wasn't able to
  run fast enough to talk to a 9S08QG8, running at 8MHz. I dug out a 25MHz
  crystal, which will give me a 6.25MHz bus speed, which should be plenty
  fast enough.

  Of course, now I have to rewrite my bit rx and tx routines. ;-)

( Another update. I've decided to try using an 18.432MHz crystal on the
  908QB. This way I get a nice even divisor for a 57600 bps serial clock,
  and it seems to be fast enough to talk to an S08 part running at either
  4MHz or 8MHz.

  It turns out that because the 9S08QG8, when mostly blank, is hard to get
  into Active BDM mode. On POR - power on reset - it starts running random
  code and either gets a COP - watchdog - reset, or an illegal instruction,
  or illegal address. So it resets and starts all over again. Trying to get
  into Active BDM via the BKGD pin is basically impossible. There is a
  forum posting about this here:

  http://forums.freescale.com/freescale/board/message?message.uid=11435#U11435

  So, given that, we have to hold BKGD/MS low during POR in order to force
  the chip into Active BDM mode. A side-effect of this is that it selects
  the bus clock - rather than the "alternate" BDM clock - ICSLCLK - so the
  BDM will be running at 4MHz instead of 8. This makes life simpler in some
  ways, but it turns out that it's pretty easy to meet the timing specs for
  both 4M and 8M BDM with the 908QB8 running at 18.432M.)

( BDM code for host running at 4.608M, and target at 4M.)

( Send one bit via BDM.)
macro tx1  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  0 ,x tst                  ( pr     - delay 2 cycles)
  PortBdir ) sta            ( pwp    - drive data bit)
  nsa nsa                   ( ppdppd - pause 6 cycles)
  BKGD_H # PortBdir ) mov   ( ppwp   - drive stop bit)
  ;m

( Recv one bit via BDM.)
macro rx1  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  0 ,x tst                  ( pr     - delay 2 cycles)
  PortBdir ) clr            ( pwp    - undrive PortB)
  nsa nop                   ( ppdp   - wait for target to drive its bit)
  PortB ) lda               ( prp    - sample bit)
  ;m

comment *4.608M--8M*
( BDM code for host running at 4.608M, and target at 8M.)

( Send one bit via BDM.)
macro tx1  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  PortBdir ) sta            ( pwp    - drive data bit)
  nop                       ( p      - pause 1 cycle)
  BKGD_H # PortBdir ) mov   ( ppwp   - drive stop bit)
  ;m

( Recv one bit via BDM.)
macro rx1  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( ppwp   - drive start bit)
  PortBdir ) clr            ( pwp    - undrive PortB)
  PortB ) lda               ( prp    - sample bit)
  ;m
*4.608M--8M*

comment *6.25M*
( BDM code for host running at 6.25M, and target at 8M.)

( Send one bit via BDM.)
macro tx1  ( tx bit in A)
  BKGD_L # PortBdir ) mov   ( drive start bit)
  PortBdir ) sta            ( drive data bit)
  nsa                       ( pause)
  BKGD_H # PortBdir ) mov   ( drive stop bit)
  ;m

( Recv one bit via BDM.)
macro rx1  ( recvd bit in A1)
  BKGD_L # PortBdir ) mov   ( drive start bit)
  PortBdir ) clr            ( undrive PortB)
  nop                       ( wait for target to drive its bit)
  PortB ) lda               ( sample bit)
  ;m

*6.25M*

( Send one byte via BDM.)
code BdmTx8  ( tx byte in A)
   ( loop 8; generate bits MSB first)
   0 ,x sta   8 # lda   1 ,x sta
   begin  0 ,x rol  CS if  BKGD_H # lda  else  BKGD_L # lda  then
      tx1 ( bsr)   1 ,x decz?  until
   PortBdir ) clr   -- tristate when done xmitting
   rts  ;c

( Recv one byte via BDM.)
code BdmRx8  ( recvd byte in A)
  ( loop 8; recv bits MSB first; bit is 02)
  8 # lda   1 ,x sta   0 ,x clr
  begin   rx1 ( bsr)   .a rol  ( PortB7 -> C)  0 ,x rol
          1 ,x decz?  until
  0 ,x lda  ( byte into A)
  rts  ;c

comment *3.2M*
( Compressing three transitions into one byte:
   Hxx  10
   xHx  08
   xxH  04
   Lxx  80
   xLx  40
   xxL  20
                    L  H
   tx1 = LHH = 8c = 1000_1100
   tx0 = LLH = c4 = 1100_0100  )

( Send one bit via BDM.)
code tx1  ( tx bit in A)
  savex  PortBdir # ldx
  0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta
  restx  rts  ;c

( Recv one bit via BDM.)
code rx1  ( recvd bit in A1)
  savex  PortBdir # ldx
  80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PortA ) lda
  restx  rts  ;c

( Send one byte via BDM.)
code tx8  ( tx byte in A)
   ( loop 8; generate bits MSB first)
   0 ,x sta   8 # lda   1 ,x sta
   begin  0 ,x rol  CS if  8c # lda  else  0c4 # lda  then
      tx1 bsr   1 ,x decz?  until
   rts  ;c

( Recv one byte via BDM.)
code rx8  ( recvd byte in A)
  ( loop 8; recv bits MSB first; bit is 02)
  8 # lda   1 ,x sta   0 ,x clr
  begin   rx1 bsr   .a ror  .a ror  ( PortA.1 -> C)  0 ,x rol
          1 ,x decz?  until
  0 ,x lda  ( byte into A)
  rts  ;c
*3.2M*

0 [if]
code InitBdm
  BKGD_H # PortB ) mov   -- BKGD_L 0, BKGD_H 1
  PortBdir ) clr
  rts  ;c

-- macro savex   xSaved ) stx  ;m
-- macro restx   xSaved ) ldx  ;m
macro savex   .x psh  ;m
macro restx   .x pul  ;m

( Archive this here.)

( Send one bit via BDM.)
macro tx1
   .a pul   0 ,x sta   .a lsl   0 ,x sta  .a lsl  0 ,x sta  ;m

( Recv one bit via BDM.)
macro rx1
   80 # lda ( BKGD_L)   0 ,x sta   .a lsl   0 ,x sta   PortA ) lda   .a psh  ;m

macro savex   xSaved ) stx  ;m
macro restx   xSaved ) ldx  ;m

code tx8
   ( loop 8; generate bits LSB first; then we'll pop them MSB first)
   8 # lda   0 ,x sta
   begin  2 ,x ror  CS if  8c # lda  else  0c4 # lda  then
          .a psh  0 ,x decz?  until
   savex  ( XXX if I moved this above the pushes, it could psh onto stack...)
   PortBdir # ldx
   tx1  tx1  tx1  tx1
   tx1  tx1  tx1  tx1
   restx   2 # aix  ( pop xmitted byte)
   rts  ;c

code rx8
   savex
   PortBdir # ldx
   rx1  rx1  rx1  rx1
   rx1  rx1  rx1  rx1
   restx
   ( loop 8; pop bits LSB first; bit is 02)
   8 # lda   1 ,x sta   0 ,x clr
   begin   .a pul  .a ror  .a ror  ( PortA.2 -> C)  0 ,x ror
           1 ,x decz?  until
   -2 # aix  ( promote scratch - recvd char - to TOP)
   rts  ;c

[then]

#]file
