( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2014 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( Calling this "chat3". It's really just an experiment to see if the style
  that I wrote the USB chat firmware in works in this context too. The main
  difference is that the original chat code was a big loop, where the USB
  "loop" was a subroutine - which meant that to return the "top" from any
  piece of code all you do is _return_. And using tail calls, it's easy to
  code in a Forth-like style that is very efficient.)

loading HC08 Chat v3 (target - tail-recursive version ;-)

hex

__meta

( The SCI code is identical between 908 and S08 except for the names - and
  offsets - of the SCI status and data regs ... so let's abstract them.)

.ifdef S08

aka SCIS1 SciStatus
aka SCID  SciData

.else   -- 908

aka SCS1 SciStatus
aka SCDR SciData

.then

label get-byte  ( returns char in A)
   begin  SciStatus 5 ( recvr full)  bset? until
   SciData ) lda  rts  ;c

label put-byte  ( transmits char in A)
   begin  SciStatus 7 ( xmit empty)  bset? until
   SciData ) sta  rts  ;c

( chat3 protocol - minor changes)

( Commands:
  0  Bye        - ignored by chat; force other command loops to return to chat;
                  can be used as an Idle
  1  Version    - return chat protocol version. A new command! Heh.
                - Starting out at 3.
  2  Run        - does an RTI - pops stack frame and runs
                  when it returns to chat loop, returns flags register
  3  GetSP      - sets HX from SP, then returns HX
  4  GetHX      - writes H then X register to SCI
  5  SetHX      - reads two bytes from SCI, writes them into H & X registers
  6  ReadNext   - reads a byte from memory @ HX, writes it to SCI, incrs HX
  7  WriteNext  - reads a byte from SCI, writes into memory @ HX, incrs HX

 ~~ The following are S08-only commands ~~

  8  ReadN      - reads a count from SCI, reads that many bytes from
                  memory, and writes them to SCI
  9  FlashNext  - reads a byte from SCI, writes to flash @ HX, incrs HX
                - calls a routine at @ram that host downloads to device
 10  FlashStatus - returns FSTAT
                 - need this as a way to "ping" the device for the
                 - completion of long operations, such as erase
)

label process-serial
   SciStatus 5 ( recvr full)  bclr? if  rts  then  ( nothing to do)
   SciData ) lda  ( command)

   ( map 0 -> ff -- ignore)
   .a decz? if ( Version)   3 # lda  put-byte j  then

   .a decz? if ( Run)   2 # ais ( skip return addr)  .h pul  rti  then

   .a decz? if ( GetSP)  tsx  2 # aix ( skip return addr)  .a inc  then
      ( incrementing A causes us to execute GetHX too!)

   .a decz? if ( GetHX)
   .h psh  .a pul  put-byte c  ( send H)
              txa  put-byte j  ( send X)  then

   .a decz? if ( SetHX)
   get-byte c  .a psh  .h pul  ( set H)
   get-byte c             tax  ( set X)  rts  then

   .a decz? if ( ReadNext)
label read-and-put-byte
   0 ,x lda  1 # aix  put-byte j  then

   .a decz? if ( WriteNext)
   get-byte c   0 ,x sta
label write-increment
   1 # aix

.ifdef S08

   ( end WriteNext)  rts  then

   .a decz? if ( ReadN)
   get-byte c  .a psh ( count)
   begin  read-and-put-byte c  0 ,s decz? until
   .a pul  rts  then

   .a decz? if ( FlashNext)
   get-byte c  @ram ) jsr  ( call flash routine in RAM)
   write-increment j  ( to WriteNext)  then

   .a decz? if ( FlashStatus)
   FSTAT ) lda  put-byte j

.then

   then
   ( unknown command)   rts  ;c

( If compiling into RAM and using 908 flash control block, check to make
  sure we haven't "run into" the control block, then jump forward over it
  and continue compiling there.)

in-ram?  .def control-block  .and .if
__host
: ?fits
   control-block  'zram @  u< if
      error" Code too long - ran into Flash control block"
   then ;
?fits
__meta
09c org           -- continue compiling there
.then

( USB code defines its own versions of swi and clock code, so we needn't
  repeat them here.)

.ifndef usb-debug-via-serial
label emulated-swi
   ( jsr/bsr has already pushed PC)
   .x psh  .a psh  tpa ( flags to A)  .a psh  sei
   .h psh
   put-byte c
   begin  process-serial c  again  ;c

( If the chat interaction changes the PC on this stack frame to point
  somewhere other than _after_ the __swi, not all is lost - since we got
  here via a _call_ from reset, we'll return to _that_ loop, and re-enter
  the SWI.

  On the other hand, if the PC remains unaltered, an RTI from the SWI's
  stack frame wil simply return here, and we'll take the "exception" again.)

label interact
   begin  emulated-swi c  again  ;c

Vreset handler
   @ram #ram + # ldhx
   txs

.ifdef S08

   -- Turn off watchdog
   -- Can't use bit ops! SOPT1 not in z-page.
   -- Clear bits 6 & 7. These have different meanings on different chips,
   -- but at least for the JS and QG clearing both bits will shut off the
   -- watchdog.
   SOPT1 ) lda  3f # and  SOPT1 ) sta

.ifdef 24m  ( JS/JM running 48M PLL)

   ( Set up the xtal oscillator and PLL. For USB we need a 48M clock - 24M
     bus clock. Getting there takes a few steps...)

   -- FEI ==> FBE
   -- Start xtal osc - we've got a 4M xtal on the board.
   -- Datasheet and appnotes have you set BDIV to /1 here, but since we're
   -- running off untrimmed internal osc still, that's a bad idea. We leave
   -- that until the end.
   %01_11_0110 # MCGC2 ) mov  ( keep BDIV at /2, start ext osc)
   -- wait for osc to start (OSCINIT)
   begin  MCGSC 1  bset? until
   -- switch to ext clock (FBE): CLKS=01 (ext), RDIV=001 (/2), IREFS=0
   -- NOTE: We've set RDIV for PLL (4M/2 == 2M), but we're still running
   -- the FLL, so this will temporarily run it out of spec... DS says this
   -- is ok, as long as we switch quickly!
   -- %10_111_000 # MCGC1 ) mov  -- from when I thought I needed to keep
                                 -- RDIV set for FLL
   %10_001_000 # MCGC1 ) mov

   -- Wait until we've switched clocks
   begin  MCGSC ) lda  %0001_1100 # and  ( mask IREFST and CLKST)
          %0000_1000 # cmp  0= until  ( IREFST=0, CLKST=10)

   -- FBE ==> PBE
   -- We're spinning up the PLL. We're set up to divide our 4M xtal by two
   -- (RDIV) to get 2M (PLL freq); let's multiply that by 24 (VDIV) to get
   -- 48M, which is our target clock.
   %0100_0110 # MCGC3 ) mov    -- PLLS=1, VDIV=0110 (*24)

   begin  MCGSC 5 bset?  until   -- loop until PLLST set
   begin  MCGSC 6 bset?  until   -- loop until LOCK set

   -- PBE ==> PEE
   MCGC1 7 bclr  -- set CLKS to 00 (PLL)
   begin  MCGSC 2 bset?  until
   begin  MCGSC 3 bset?  until   -- loop until CLKST=11

   -- Lastly, set BDIV to /1
   MCGC2 6 bclr

   #24000 khz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI for 115200 bps

   SCIBDH ) clr        ( baud rate divisor, high)
   #13 # SCIBDL ) mov  ( baud rate divisor, low)
                       ( yields 115200 from 24M bus clock)
   0c # SCIC2 ) mov    ( enable rcvr, xmitter)

.else .ifdef 4.9152m

   -- Let's try switching on the xtal osc.
   %01_11_0110 # ICSC2 ) mov  ( keep BDIV at /2, start ext osc)
   -- wait for osc to start
   begin  ICSSC 1  bset? until
   -- switch! making sure to change RDIV at the same time
   %00_111_000 # ICSC1 ) mov

   #49152 hhz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   -- At this xtal frequency we can't do better than 38400 and still get a
   -- good divisor.

   SCIBDH ) clr      ( baud rate divisor, high)
   8 # SCIBDL ) mov  ( baud rate divisor, low)
                     ( yields 38400 from 9.8304M bus clock)
   0c # SCIC2 ) mov  ( enable rcvr, xmitter)

.else .ifdef 9.8304m

   -- Let's try switching on the xtal osc.
   %00_11_0110 # ICSC2 ) mov  ( BDIV to /1 from /2, start ext osc)
   -- wait for osc to start
   begin  ICSSC 1  bset? until
   -- switch! making sure to change RDIV at the same time
   %00_111_000 # ICSC1 ) mov

   #98304 hhz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   -- At this xtal frequency we can't do better than 38400 and still get a
   -- good divisor.

   SCIBDH ) clr       ( baud rate divisor, high)
   10 # SCIBDL ) mov  ( baud rate divisor, low)
                      ( yields 38400 from 9.8304M bus clock)
   0c # SCIC2 ) mov   ( enable rcvr, xmitter)

.else  ( configure ICS or MCG, depending on device)

.labels. .contains ICSTRM .if
   -- Configure ICS (internal clock source)
   -- We're staying in FEI mode, but we're going to trim the internal
   -- reference so that our bus clock is 9.216M - a nice multiplier for
   -- 115200.
   -- I've put my own trim values into the chips @ FFAD (for 9.216M).

   0ffad ) lda   ICSTRM ) sta

   ICSC2 ) clr   ( switch BDIV to /1 from /2)

.else    -- JS or JM part with MCG
   -- Adjust registers and values for the JS & JM parts, which use a different
   -- clock generator (MCG instead of ICS), and run twice as fast.

   0ffad ) lda   MCGTRM ) sta
   -- leave BDIV/2 set; MCG runs 2x as fast as QG's ICS

.then  ( ICS vs MCG)

   #9216 khz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI
   SCIBDH ) clr      ( baud rate divisor, high)
   5 # SCIBDL ) mov  ( baud rate divisor, low)
                     ( yields 115200 from 9.216M bus clock)
   0c # SCIC2 ) mov  ( enable rcvr, xmitter)

.then  .then  .then  ( xtal vs internal osc)

.ifdef so-that-worked
   -- UART test
   begin
      %1111_1111 # lda  SciTx c
      %0101_0101 # lda  SciTx c
      %0100_1001 # lda  SciTx c
      %0001_0001 # lda  SciTx c
      %0000_0001 # lda  SciTx c
   again
.then

.else  -- 908

   -- Setting COPD works, but is unnecessary in monitor mode; however,
   -- setting RSTEN causes the chip to fly away. Noise on nRST pin?
   -- Since I'm avoiding setting the Reset vector, setting these or not is
   -- irrelevant.
   -- CONFIG2 0 bset  ( set RSTEN: enable nRST pin - pin 8)

   -- I'm going to, after all, attempt to burn a chip with a programmed
   -- Reset vector. So I need this:
   CONFIG1 0 bset  ( set COPD: disable watchdog!)

   -- XXX Set up for use with on-chip crystal osc?
   -- 42 # OSC ) mov  ( set Ext Osc and ECGON)

   -- configure crystal osc
   PortA 4 bset
   DirA 4 bset  ( configure OSC2 as output, drive high several cycles)
   nsa nsa nsa
   DirA 4 bclr
   0c0 # OSC ) mov  ( set external osc going - 8-32MHz xtal)

   -- wait for startup; normally one waits 4096 target cycles; for
   -- simplicity we wait that many cycles, but based on the internal osc,
   -- which is slower (12.8M) than the crystal (18.432M).

   #16 # ldx  ( 4096 = 16 * 256; we don't bother to clr A the first time)
   begin  begin  .a decz? until  .x decz? until
   OSC 1 bset ( set ECGON - switch oscillators!)

   -- Configure SCI
   SCC1 6 ( ENSCI) bset
   %001_10000 # SCPSC ) mov  ( prescaler divisor of 2 + 16/32)
                             ( yields 115200 from 18.432M clock)
   0c # SCC2 ) mov   ( enable rcvr, xmitter)

.then  ( 908)

   begin  interact c  again  ;c

.then  ( usb-debug-via-serial)
