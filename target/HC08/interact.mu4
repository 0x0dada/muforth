( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( Support common to all 908 and S08 interactions. Things like SWI stack
  frames, reading and writing memory using "indexed" reads and writes.)


loading HC08 Interaction (common)


( Hex output, from lib/see.mu4)
: .h8_   .h8 space ;
: .hcell_  .hcell space ;

( Recv from, send to target.)
: _send  tty-target  >emit ;
: _recv  tty-target  <key ;
: flush  tty-target  tty-iflush ;
: drain  tty-target  tty-drain ;
: icount  ( - chars-waiting)  tty-target  tty-icount ;

( XXX shortcut - remove when done fixing chat stuff)
: c  icount ;


comment chat-commands

  Simple and unified interaction layer.
  
  The interaction "plumbing" - whether chat-monitor, chat, or BDM - will
  implement the following commands:

  GetRegs  - get all registers
  SetRegs  - set all registers
  SetAddr  - set memory address for subsequent Read and Write commands
  Read     - read a single byte from memory, increment pointer
  Write    - write a single byte to memory, increment pointer
  Run      - start executing
  RunWait  - same as Run, but also wait for target to finish
             and resume chatting

comment chat-commands

defer t.GetRegs
defer t.SetRegs
defer t.AllocStackBuf  ( n)  ( allocate room for buffer; set HX to point to it)
defer t.SetAddr  ( a)
defer t.GetAddr  ( - a)
defer t.Read     ( - byte)
defer t.Write    ( byte)
defer t.StreamCount  ( n)   ( read several bytes at once)
defer t.StreamRead   ( - byte)  ( get next byte in stream)
defer t.Run
defer t.RunWait
defer t.Return  ( - instruction)  ( return the instruction that gets us
                                    back to talking to host)

( We keep a local copy of the target's registers in the same order as they
  appear in an exception frame.

  The order, low to high: H CC A X PCH PCL)

6 buffer chat-frame  ( local copy of SWI stack frame)
variable chat-sp     ( current value of target's SP)

( These index into our local chat-frame, _not_ into target memory!)
: reg  ( offset)  constant  does> @  chat-frame + ;  ( self-index)
00 reg .H
01 reg .CC
02 reg .A
03 reg .X
04 reg .PC
04 reg .PCH
05 reg .PCL

: regs!  ( SP H CC A X PCH PCL)
   [ chat-frame 6 + ]  6 for  1-  tuck c!  next  drop
   chat-sp ! ;

: regs@  ( - PCL PCH X A CC H)
   [ chat-frame 6 + ]  6 for  1- dup  c@ swap  next  drop ;

: GetRegs  ( run "current" x.GetRegs & store those in our local frame)
   t.GetRegs regs! ;

: SetRegs  ( fetch regs from our local frame & run "current" x.SetRegs)
   regs@  t.SetRegs ;

( These are handy.)
: pc!  >lohi  .PCH c!  .PCL c! ;
: hx!  >lohi    .H c!    .X c! ;

: .bits8  radix preserve  binary  <# # # # # # # # # #> type ;
: w@  ( a - w)  dup c@ 8 <<  swap 1+ c@ or ;

: .b  ( a)  c@ .h8_ ;
: .w  ( a)  w@  .hcell_ ;

: .regs
   cr  ." V--HINZC  A  H  X   SP   PC"
   cr  .CC c@ .bits8 space  .A .b  .H .b  .X .b  chat-sp @ .hcell_  .PC .w ;

: put  ( from to)  ( copy code to target)
   2dup u< if  over - ( from count)  over t.SetAddr  swap image-p!
   for  image-c*  t.Write  next  ^  then  2drop ;

: copy-ram   @ram  |ram @  put  ;
: hi   copy-ram  GetRegs .regs ;

variable chatting

: +chat  chatting on ;

: t.ReadW  ( - word)  t.Read ( hi)  t.Read ( lo)  hilo> ;

: >chat  ['] t.SetAddr  is |p!
         ['] t.GetAddr  is |p@
         ['] t.Read     is |c*
         ['] t.ReadW    is |*
                         2 |cell !  ( size of cell) ;

( Set |@ and |c@ to _some_ form of target fetch. Prefer to get bytes from
  target if we're connected. This word is useful so we can set an initial
  state for target's  du  and  dis  so that inspect won't crash when it
  runs |@ to get a default ea.)

: >target  chatting @ if  >chat ^  then  >image ;


( Define our own key bindings for memory dumping and disassembly. We'll
  default to host bindings if there isn't one in our array. This way we
  only have to define the "delta" between host and target behaviours.)

128 array hc08-seekeys

( Default key action is to run host key code)
host-seekeys hc08-seekeys  128 cells cmove

hc08-seekeys 'seekeys !    ( switch over to our bindings)

( Support for dumping memory)
: 1dump  ( a)
   hex-bytes  ( set field width)
   >image   dup .addr  dup .hex-bytes
   chatting @ if
      >chat   dup _addr  dup .hex-bytes
   then
   drop ( a) ;

key: d  ( a - a 0)  ['] skip+  advance!
                    ['] skip-  retreat!
                    ['] 1dump  inspect!  0 ;

key: i  ( a - a 0)  ['] i-skip  advance!
                    ['] 0       retreat!
                    ['] 1dis    inspect!  0 ;

( Interactive)
: du-host  -1 addr-mask !  du ;  ( make an alias so we can still get to it)

: du  ( a - a')    hc08-seekeys 'seekeys !    ( switch over to our bindings)
                   >target
                   "0ffff addr-mask !
                   ['] skip+  advance!
                   ['] skip-  retreat!
                   ['] 1dump  inspect ;

: dis  ( a - a')   hc08-seekeys 'seekeys !    ( switch over to our bindings)
                   >target
                   "0ffff addr-mask !
                   ['] i-skip  advance!
                   ['] 0       retreat!
                   ['] 1dis    inspect ;
forth

hex

outside
: equ  ( make a constant in .outside.)
  current preserve  outside constant ;

assembler
: label   |here  \o equ ;
: ;c   __outside ;

compiler
: ;m   \ ^  __outside ;  ( to exit from macro compilation)

outside
: ram  ram ;
: flash  flash ;
: org  org ;
: code   \a label  __asm ;
: macro  current preserve  assembler :  __macro ;
: var   |ram @  \o equ  |ram +! ( allot) ;

( For forward references)
: forward    "100 \a ) \a jmp  \a label ;
: resolve>>  ( src)  |here  swap 2 -  image-! ;

: .or   or ;
: .x  ( like .s)  .X c@ du ;

"0fffe constant Vreset  ( even though the chips will all re-define this...)
: handler  ( vector-offset)  |here swap  image-!  __asm ;

forth
: .r   .regs ;

: _runwait  SetRegs  t.RunWait  GetRegs ;
: _run      SetRegs  t.Run ;  ( don't wait for target)

: runwait   _runwait  .regs ;
: call  pc!  runwait ;
: reset   \m Vreset image-@  call ;

: \o  .outside. chain' execute ;


( Calculation of FCDIV - flash clock divider [sic])

   -- Set FCDIV - flash clock divider - to match our bus clock
   -- FCDIV = ceil(busclock/200k) - 1

   -- We leave off the - 1 to slow the flash a bit. Insurance against our
   -- clock being a bit fast... better to have the flash clock run a bit
   -- slow than too fast.

-- XXX complete crock #42: this belongs in the meta compiler... which
-- doesn't exist yet!
-- We're trying the divide the bus clock down to between 150kHz and 200kHz,
-- to drive the flash programming machinery. We need to calculate a divider
-- that works. One caveat: if the calculated value is > 63, set a bit that
-- first divides the bus clock by 8 before dividing by our divider
-- (actually, our divider + 1).

decimal

: _fcdiv   ( divisor - fcdiv)
   dup 64 u< not if
      ( too big - round up and divide by 8)  7 + 3 >>
      ( set "divide by 8" bit)  "40 or
  then ;

( For most uses: clock speed is in kilohertz - khz.)
: khz>fcdiv  ( clock-in-khz - fcdiv)
   199 + 200 /   _fcdiv ;

( For more resolution: clock speed is input in hundreds of hertz -
  hectahertz - hhz.)
: hhz>fcdiv  ( clock-in-hhz - fcdiv)
   1999 +  2000 /  _fcdiv ;
