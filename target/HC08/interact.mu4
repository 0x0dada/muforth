( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( Support common to all 908 and S08 interactions. Things like SWI stack
  frames, reading and writing memory using "indexed" reads and writes.)


loading HC08 Interaction (common)


( Hex output, from lib/see.mu4)
: .h8_   .h8 space ;
: .hcell_  .hcell space ;

( Recv from, send to target.)
: _send  tty-target  >emit ;
: _recv  tty-target  <key ;
: flush  tty-target  tty-iflush ;
: drain  tty-target  tty-drain ;
: icount  ( - chars-waiting)  tty-target  tty-icount ;

( XXX shortcut - remove when done fixing chat stuff)
: c  icount ;


comment chat-commands

  Simple and unified interaction layer.
  
  The interaction "plumbing" - whether chat-monitor, chat, or BDM - will
  implement the following commands:

  GetRegs  - get all registers
  SetRegs  - set all registers
  SetAddr  - set memory address for subsequent Read and Write commands
  Read     - read a single byte from memory, increment pointer
  Write    - write a single byte to memory, increment pointer
  Run      - start executing
  RunWait  - same as Run, but also wait for target to finish
             and resume chatting

comment chat-commands

defer t.GetRegs
defer t.SetRegs
defer t.AllocStackBuf  ( n)  ( allocate room for buffer; set HX to point to it)
defer t.SetAddr  ( a)
defer t.GetAddr  ( - a)
defer t.Read     ( - byte)
defer t.Write    ( byte)
defer t.StreamCount  ( n)   ( read several bytes at once)
defer t.StreamRead   ( - byte)  ( get next byte in stream)
defer t.Run
defer t.RunWait
defer t.Return  ( - instruction)  ( return the instruction that gets us
                                    back to talking to host)

( We keep a local copy of the target's registers in the same order as they
  appear in an exception frame.

  The order, low to high: H CC A X PCH PCL)

6 buffer chat-frame  ( local copy of SWI stack frame)
variable chat-sp     ( current value of target's SP)

( These index into our local chat-frame, _not_ into target memory!)
: reg  ( offset)  constant  does> @  chat-frame + ;  ( self-index)
00 reg .H
01 reg .CC
02 reg .A
03 reg .X
04 reg .PC
04 reg .PCH
05 reg .PCL

: regs!  ( SP H CC A X PCH PCL)
   [ chat-frame 6 + ]  6 for  1-  tuck c!  next  drop
   chat-sp ! ;

: regs@  ( - PCL PCH X A CC H)
   [ chat-frame 6 + ]  6 for  1- dup  c@ swap  next  drop ;

: GetRegs  ( run "current" x.GetRegs & store those in our local frame)
   t.GetRegs regs! ;

: SetRegs  ( fetch regs from our local frame & run "current" x.SetRegs)
   regs@  t.SetRegs ;

( These are handy.)
: pc!  >lohi  .PCH c!  .PCL c! ;
: hx!  >lohi    .H c!    .X c! ;
: hx@           .H c@    .X c@  hilo> ;

: .bits8  binary  <# # # # # # # # # #> type ;
: w@  ( a - w)  dup c@ 8 <<  swap 1+ c@ or ;

: .b  ( a)  c@  .h8_ ;
: .w  ( a)  w@  .hcell_ ;

: .regs
   radix preserve
   cr  ." V--HINZC  A  H  X   SP   PC"
   cr  .CC c@ .bits8 space  .A .b  .H .b  .X .b  chat-sp @ .hcell_  .PC .w ;

: put  ( 'ram)  ( copy code to target)
   2@  ( from to)
   2dup u< if  over - ( from count)  over t.SetAddr  swap image-p!
   for  image-c*  t.Write  next  ^  then  2drop ;

: copy-ram   'zram put  'ram put ;
: hi   copy-ram  GetRegs .regs ;

variable chatting

: +chat  chatting on ;

: t.ReadW  ( - word)         t.Read  ( hi)  t.Read  ( lo)  hilo> ;
: t.WriteW  ( word)   >lohi  t.Write ( hi)  t.Write ( lo) ;

: >chat  ['] t.SetAddr  is |p!
         ['] t.GetAddr  is |p@
         ['] t.Read     is |c*
         ['] t.ReadW    is |*
                         2 |cell !  ( size of cell) ;

( Set |@ and |c@ to _some_ form of target fetch. Prefer to get bytes from
  target if we're connected. This word is useful so we can set an initial
  state for target's  du  and  dis  so that inspect won't crash when it
  runs |@ to get a default ea.)

: >target  chatting @ if  >chat ^  then  >image ;


( Define our own key bindings for memory dumping and disassembly. We'll
  default to host bindings if there isn't one in our array. This way we
  only have to define the "delta" between host and target behaviours.)

128 array hc08-seekeys

( Default key action is to run host key code)
host-seekeys hc08-seekeys  128 cells cmove

hc08-seekeys 'seekeys !    ( switch over to our bindings)

( Support for dumping memory)
: 1dump  ( a)
   hex-bytes  ( set field width)
   >image   dup .addr  dup .hex-bytes
   chatting @ if
      >chat   dup _addr  dup .hex-bytes
   then
   drop ( a) ;

key: d  ( a - a 0)  ['] skip+  advance!
                    ['] skip-  retreat!
                    ['] 1dump  inspect!  0 ;

key: i  ( a - a 0)  ['] i-skip  advance!
                    ['] 0       retreat!
                    ['] 1dis    inspect!  0 ;

( Interactive)
: du-host  -1 addr-mask !  du ;  ( make an alias so we can still get to it)

: du  ( a - a')    hc08-seekeys 'seekeys !    ( switch over to our bindings)
                   >target
                   "0ffff addr-mask !
                   ['] skip+  advance!
                   ['] skip-  retreat!
                   ['] 1dump  inspect ;

: dis  ( a - a')   hc08-seekeys 'seekeys !    ( switch over to our bindings)
                   >target
                   "0ffff addr-mask !
                   ['] i-skip  advance!
                   ['] 0       retreat!
                   ['] 1dis    inspect ;


( XXX these are only temporary - as is this whole file. ;-)
( Borrowed from target/HC08/meta, which was copied from ARM.)

( The various token consumers for each mode.)

-:  ."  (assembling)"  ;
-:
    .assembler. find  if  execute  ^  then
       .labels. find  if  execute  ^  then  ( equates are in .labels.)
         .meta. find  if  execute  ^  then
        .forth. find  if  execute  ^  then  ( utility words in .forth.)
                                            number ;
mode __asm


-:  ."  (compiling an assembler macro)"  ;
-:
     .compiler. find  if  execute  ^  then  ( compiler's if/then/begin ...)
    .assembler. find  if  ,  ^        then  ( ... trump the the assembler's)
       .labels. find  if  ,  ^        then  ( equates are in .labels.)
         .meta. find  if  ,  ^        then
        .forth. find  if  ,  ^        then  ( utility words in .forth.)
                                            number literal ;
mode __macro


( The meta-interpreter. We're in this mode when we're building the target
  image, and when in between [ and ] when running the target colon
  compiler.)

-:  ."  (meta)"  ;
-:
         .meta. find  if  execute  ^  then
        .forth. find  if  execute  ^  then
                                            number ;
mode __meta


: macro  current preserve  assembler       :   __macro ;

assembler
: ;c   __meta ;

compiler
: ;m   \ ^  __meta ;  ( to exit from macro compilation)

meta
: __host  \ [ ;  ( return to host forth mode)
: name   current preserve  target  \m here constant ;

: label   \m here  equ  __asm ;

( XXX Should I assume space for stack? Things are bad _before_ we've come
  to the actual end of RAM...)

: var   ( bytes)
   'ram @  dup equ  +  dup 'ram ! ( allot)
   @ram #ram +  swap u<  if error" No available ram"  then ;

forth
: ?zpage  if error" No available zero-page ram" then ;
meta

: zvar  ( bytes)
   'zram @  dup equ  +  dup 'zram ! ( allot)
   'xram @ swap u< ?zpage ;

: xvar  ( bytes)
   'xram @  swap -  dup equ  dup 'xram ! ( allot)
   'zram @ u< ?zpage ;

: code    \m name   __asm ;

: '  .target. chain' execute ;  ( target words are constants!)

( For forward references)
: forward    "100 \a ) \a jmp  \m label ;
: resolve>>  ( src)  \m here  swap 2 -  image-! ;

: .and  and ;
: .or   or ;
: .x  ( like .s)  .X c@ du ;

"0fffe constant Vreset  ( even though the chips will all re-define this...)
forth
variable vector-offset  ( 0 if vectors not relocated)
: reloc-vector  ( offset - offset')
   dup \m Vreset = if ^ then  ( reset doesn't get relocated)
   vector-offset @ +a ;

meta
: handler  ( vector-offset)
   reloc-vector  \m here swap  image-!  __asm ;

forth
: .r   .regs ;

: _runwait  SetRegs  t.RunWait  GetRegs ;
: _run      SetRegs  t.Run ;  ( don't wait for target)

: runwait   _runwait  .regs ;
: call  pc!  runwait ;
: reset   \m Vreset image-@  call ;

: \m  .meta. chain' execute ;
: \l  .labels. chain' execute ;


( Calculation of FCDIV - flash clock divider [sic])

   -- Set FCDIV - flash clock divider - to match our bus clock
   -- FCDIV = ceil(busclock/200k) - 1

   -- We leave off the - 1 to slow the flash a bit. Insurance against our
   -- clock being a bit fast... better to have the flash clock run a bit
   -- slow than too fast.

-- XXX complete crock #42: this belongs in the meta compiler... which
-- doesn't exist yet!
-- We're trying the divide the bus clock down to between 150kHz and 200kHz,
-- to drive the flash programming machinery. We need to calculate a divider
-- that works. One caveat: if the calculated value is > 63, set a bit that
-- first divides the bus clock by 8 before dividing by our divider
-- (actually, our divider + 1).

: _fcdiv   ( divisor - fcdiv)
   dup 64 u< not if
      ( too big - round up and divide by 8)  7 + 3 >>
      ( set "divide by 8" bit)  "40 or
  then ;

( For most uses: clock speed is in kilohertz - khz.)
: khz>fcdiv  ( clock-in-khz - fcdiv)
   199 + 200 /   _fcdiv ;

( For more resolution: clock speed is input in hundreds of hertz -
  hectahertz - hhz.)
: hhz>fcdiv  ( clock-in-hhz - fcdiv)
   1999 +  2000 /  _fcdiv ;

( Getting ready to test interactively - time for a real meta-compiler!)

( NOTE: top cell of target stack is _scratch_ - so allocate it but don't
  copy it back and forth.)

.ifndef one-byte-scratch
2 constant #scratch  ( number of "scratch" bytes on top of target stack)
: ReadStackW   t.ReadW ;
: WriteStackW  t.WriteW ;
.else
1 constant #scratch  ( number of "scratch" bytes on top of target stack)
( These have to be little-endian!)
: ReadStackW              t.Read  t.Read swap hilo> ;
: WriteStackW  >lohi swap t.Write t.Write ;
.then

meta
: r0  @ram #ram + ;  ( bottom of target's R stack)
: s0  \m r0  64 - ;  ( bottom of target's D stack; room for 32 values on R)
: cell   2  ;
: cell/  2/ ;
: cells  2* ;
: depth  \m s0 hx@ #scratch +  -  \m cell/ ;
: u.  u. ;
: .  . ;
: du   du ;
: dis  dis ;

forth
: stack>  ( "push" stack to target)
   depth 8 min  ( more than that would be silly)
   \m s0 over \m cells -  dup #scratch -  hx! ( top of D stack) t.SetAddr
   ?for  WriteStackW  next  then ( copy each cell as a word to D stack) ;
 
( XXX should this set hx when done?)
: stack<  ( "pop" stack from target)
   \m depth 0 max 8 min  ( more than that would be silly)  =if
   hx@ #scratch + t.SetAddr  dup ( depth)
   for  ReadStackW  pop 2push  next  ( starting with top, push to R)
   for  2pop push  next  ( pop from R to reverse order)  ^  then  drop ;

: remote  ( cfa)  ( execute target word on stack)
   pc!  stack>  runwait  stack< ;

-:  ."  (interacting with target)"  ;
-:
      .meta. find  if  execute  ^  then
    .target. find  if  execute  remote  ^  then
                                                 number ;
mode __target


-- ------------------------------------------------------------------------
-- Stack layout
-- ------------------------------------------------------------------------

.ifndef one-byte-scratch

( To make use of literals easier, we keep two "scratch" bytes allocated on
  the D stack, at 0,x and 1,x. Below this is top, and below that, second.
  Like this:

     |      |      |
     +------+------+
  4  |  sh  |  sl  |  5   second
     +------+------+
  2  |  th  |  tl  |  3   top
     +------+------+
  0  |  xh  |  xl  |  1   scratch
     +------+------+
)

macro sl  5 ,x  ;
macro sh  4 ,x  ;
macro tl  3 ,x  ;
macro th  2 ,x  ;
macro xl  1 ,x  ;
macro xh  0 ,x  ;

( And for double-length values:)

macro s0  9 ,x  ;  ( second, lsb)
macro s1  8 ,x  ;
macro s2  7 ,x  ;
macro s3  6 ,x  ;  ( second, msb)
macro t0  5 ,x  ;  ( top, lsb)
macro t1  4 ,x  ;
macro t2  3 ,x  ;
macro t3  2 ,x  ;  ( top, msb)

.else  ( use one byte of "scratch" space on D stack)

( To make use of literals easier, we keep one "scratch" byte allocated on
  the D stack, at 0,x. Below this is top, and below that, second. Like
  this:

     |      |      |
     +------+------+
  4  |  sh  |  sl  |  3   second
     +------+------+
  2  |  th  |  tl  |  1   top
     +------+------+
  0  |  xh  |  xl  | -1   scratch [xl generally unused]
     +------+------+

  An odd feature of this arrangement is that the data stack is
  little-endian, so we cannot use 16-bit instructions - like ldhx - to
  access it.)

macro sh  4 ,x  ;
macro sl  3 ,x  ;
macro th  2 ,x  ;
macro tl  1 ,x  ;
macro xh  0 ,x  ;
macro xl -1 ,x  ;

( And for double-length values:)

macro s0  7 ,x  ;  ( second, lsb)
macro s1  8 ,x  ;
macro s2  5 ,x  ;
macro s3  6 ,x  ;  ( second, msb)
macro t0  3 ,x  ;  ( top, lsb)
macro t1  4 ,x  ;
macro t2  1 ,x  ;
macro t3  2 ,x  ;  ( top, msb)

.then

-- ------------------------------------------------------------------------
-- Literal loading.
-- ------------------------------------------------------------------------
--
-- The low half is put into A, the high half into xh - 0,x, on the data
-- stack.
--
-- If high half and low half are equal and non-zero,
--    half # lda  xh sta  ( 3 bytes)
-- Otherwise:
--
-- High half:
-- If hi =  0, xh clr          ( 1 byte)
-- If hi =  1, xh clr  xh inc  ( 2 bytes)
-- If hi = -1, xh clr  xh dec  ( 2 bytes)
-- Otherwise, #hi lda  xh sta  ( 3 bytes)
--
-- Low half:
-- If lo = 0,  .a clr   ( 1 byte)
-- Otherwise,  #lo lda  ( 2 bytes)
-- ------------------------------------------------------------------------

( XXX should these be macros?)
: hi-lit  ( hi)
   dup     0= if  drop  \a xh \a clr  ^  then
   dup    1 = if  drop  \a xh \a clr  \a xh \a inc  ^  then
   dup "0ff = if  drop  \a xh \a clr  \a xh \a dec  ^  then
   \a # \a lda  \a xh  \a sta ;

: lo-lit  ( lo)
   =if  \a # \a lda  ^  then  drop  \a .a \a clr ;

: make-literal  ( n)
   >lohi  2dup = if  =if  ( if hi & lo are equal and non-zero)
      drop  \a # \a lda  \a xh  \a sta  ^  then  then
   hi-lit  lo-lit ;

( XXX push-literal?)
macro _dpush  ( A -> tl, xh -> th)
   -2 # aix ( xh -> th)  tl sta  ;

( XXX pop-literal?)
macro _dpop   ( tl -> A, th -> xh)
   tl lda  2 # aix  ( th -> xh)  ;

variable pending-lit  ( literal waiting on the stack)
: ?lit  pending-lit @ if  make-literal \a _dpush  pending-lit off  then ;
meta
: number  ( the target version)
   ?lit  \f number  pending-lit on ;
: compile,  ( target-cfa)
   ?lit  \a c ( compile call) ;

meta-compiler
( Support for binops with special "immediate" - ie, literal - entry
  points.)

.ifdef not-yet
+
and
or
xor
: -  negate  \mc + ;  ( we don't have a special subtract; use add instead!)
u<
<
.then

macro pshhx  .x psh  .h psh  ;m
macro pulhx          .h pul  .x pul  ;m

forth
