( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HC08 Forth kernel

__meta

target

-- ------------------------------------------------------------------------
-- Stack layout
-- ------------------------------------------------------------------------

.ifndef two-byte-scratch

( To make use of literals easier, we keep one "scratch" byte allocated on
  the D stack, at 0,x. Below this is top, and below that, second. Like
  this:

     |      |      |
     +------+------+
  4  |  sh  |  sl  |  3   second
     +------+------+
  2  |  th  |  tl  |  1   top
     +------+------+
  0  |  xh  |             scratch high
     +------+

  An odd feature of this arrangement is that the data stack is
  little-endian, so we cannot use 16-bit instructions - like ldhx - to
  access it.)

macro sh  4 ,x  ;m
macro sl  3 ,x  ;m
macro th  2 ,x  ;m
macro tl  1 ,x  ;m
macro xh  0 ,x  ;m

( And for double-length values:)

macro s0  7 ,x  ;m  ( second, lsb)
macro s1  8 ,x  ;m
macro s2  5 ,x  ;m
macro s3  6 ,x  ;m  ( second, msb)
macro t0  3 ,x  ;m  ( top, lsb)
macro t1  4 ,x  ;m
macro t2  1 ,x  ;m
macro t3  2 ,x  ;m  ( top, msb)

.else  ( use two bytes of "scratch" space on D stack)

( To make use of literals easier, we keep two "scratch" bytes allocated on
  the D stack, at 0,x and 1,x. Below this is top, and below that, second.
  Like this:

     |      |      |
     +------+------+
  4  |  sh  |  sl  |  5   second
     +------+------+
  2  |  th  |  tl  |  3   top
     +------+------+
  0  |  xh  |  xl  |  1   scratch
     +------+------+
)

macro sl  5 ,x  ;m
macro sh  4 ,x  ;m
macro tl  3 ,x  ;m
macro th  2 ,x  ;m
macro xl  1 ,x  ;m
macro xh  0 ,x  ;m

( And for double-length values:)

macro s0  9 ,x  ;m  ( second, lsb)
macro s1  8 ,x  ;m
macro s2  7 ,x  ;m
macro s3  6 ,x  ;m  ( second, msb)
macro t0  5 ,x  ;m  ( top, lsb)
macro t1  4 ,x  ;m
macro t2  3 ,x  ;m
macro t3  2 ,x  ;m  ( top, msb)

.then

-- ------------------------------------------------------------------------
-- Literal loading.
--
-- The low half is put into A, the high half into xh - 0,x, on the data
-- stack.
--
-- If high half and low half are equal and non-zero,
--    half # lda  xh sta  ( 3 bytes)
-- Otherwise:
--
-- High half:
-- If hi =  0, xh clr          ( 1 byte)
-- If hi =  1, xh clr  xh inc  ( 2 bytes)
-- If hi = -1, xh clr  xh dec  ( 2 bytes)
-- Otherwise, #hi lda  xh sta  ( 3 bytes)
--
-- Low half:
-- If lo = 0,  .a clr   ( 1 byte)
-- Otherwise,  #lo lda  ( 2 bytes)
-- ------------------------------------------------------------------------

( Stack ops.)
macro _dpush  ( A -> tl, xh -> th)
   -2 # aix ( xh -> th)  tl sta  ;m

macro _dpop   ( tl -> A, th -> xh)
   tl lda  2 # aix  ( th -> xh)  ;m

macro _drop  2 # aix  ;m

code dup  ( a - a a)
   th lda  xh sta  tl lda  ( fall through)

label dpush
   _dpush  rts  ;c

code over  ( a b - a b a)
   sh lda  xh sta  sl lda  dpush j  ;c

code nip  ( a b - b)
   tl lda  sl sta  th lda  sh sta  ( top -> sec)  ( fall through)  ;c

code drop
   _drop  rts  ;c

code swap  ( a b - b a)
   th lda  xh sta  sh lda  th sta  xh lda  sh sta
   tl lda  xh sta  sl lda  tl sta  xh lda  sl sta  rts  ;c

( Return stack ops.)
label _r  ( move to R; needs to be room above return address)
   th lda  2 ,s sta  tl lda  3 ,s sta  ' drop j  ;c

label r_  ( move from R; needs to be value above return address)
   2 ,s lda  xh sta  3 ,s lda  dpush j  ;c

( >r aka push will _compile_ -2 # ais, then call to _r )
( r> aka pop will _compile_ call to r_, then 2 # ais )

code -rot  ( a b c - c a b)
   here 2 +a c  ( call rot, then fall thru)  ;c

code rot   ( a b c - b c a)
   -- : rot  >r swap  r< swap ;
   -2 # ais  _r c  ' swap c  r_ c  2 # ais  ' swap j  ;c

code invert
   tl com  th com  rts  ;c

code negate
   tl neg  begin  .a clr  th sbc  th sta  rts  ;c

code dnegate
   sl neg         .a clr  sh sbc  sh sta
                  .a clr  tl sbc  tl sta  again  ;c

( XXX A few test literals.)
code #0
   xh clr  .a clr  rts  ;c

code #-1
   "0ff # lda  xh sta  rts  ;c

code #smax
   "7f # lda  xh sta  "0ff # lda  rts  ;c

code #smin
   "80 # lda  xh sta  .a clr  rts  ;c

( Binary ops.)
code -
   ' negate c  ( fall thru)  ;c

code +
   _dpop
label #+
           tl add  tl sta
   xh lda  th adc  th sta  rts  ;c

code and
   _dpop
label #and
           tl and  tl sta
   xh lda  th and  th sta  rts  ;c

code or
   _dpop
label #or
           tl ora  tl sta
   xh lda  th ora  th sta  rts  ;c

code xor
   _dpop  ( tl -> A, th -> xh, second -> top)
label #xor
           tl eor  tl sta
   xh lda  th eor  th sta  rts  ;c

( Basic double-length - 32-bit - support.)
code d-
   ' dnegate c  ( fall thru)  ;c

code d+
   s0 lda  t0 add  s0 sta
   s1 lda  t1 adc  s1 sta
   s2 lda  t2 adc  s2 sta
   s3 lda  t3 adc  s3 sta  4 # aix  rts  ;c

( Flags and tests.)
code 0=
   tl lda  th ora  1 # sub ( Z -> C)  ( fall thru)

label makeflag  ( C -> -1, NC -> 0)
   .a clr  0 # sbc  tl sta  th sta  rts  ;c

code 0<
   th lsl ( N -> C)  makeflag j  ;c

label compare  ( subtract top from second, but don't save the result)
   sl lda  tl sub  sh lda  th sbc  2 # aix  rts  ;c

( u< and < require that we first push literal values; there is no
  "shortcut" like with the other 2ops, because the values are in the wrong
  order!)

label #u<
   _dpush  ( 1 byte longer than a call; a lot faster - 12~?)
code u<
   compare c  makeflag j  ;c

label #<
   _dpush  ( 1 byte longer than a call; a lot faster - 12~?)
code <
   compare c  < if  sec  makeflag j  ( true)  then
                    clc  makeflag j  ( false)  ;c

( Shifts.)
code 2*
   tl lsl  th rol  rts  ;c

code 2/
   th asr  tl ror  rts  ;c

code u2/
   th lsr  tl ror  rts  ;c  ( I could share ror with 2/, but is it worth it?)


( Memory access.)
.ifdef two-byte-scratch

( Loading HX from the D stack this way requires that it be big-endian,
  which in turn requires having two bytes of scratch space.

  th ldhx : 3 bytes, 5~
  We could also do this:
     th lda [ H]  tl ldx  .a psh  .h pul  : 6 bytes, 11~  not great!!
)

macro pshhx  .x psh  .h psh  ;m
macro pulhx          .h pul  .x pul  ;m

code c@  ( a - byte)
   pshhx  th ldhx ( !)  0 ,x lda  pulhx
   th clr  tl sta  rts  ;c

code @  ( a - word)
   .a psh  ( room for hi byte)
   pshhx  th ldhx ( !)  0 ,x lda ( hi)  2 ,s sta
                        1 ,x lda ( lo)            pulhx
   tl sta  .a pul  th sta  rts  ;c

code c!  ( byte a)
   sl lda  pshhx  th ldhx  0 ,x sta  pulhx  4 # aix  rts  ;c

code !  ( word a)
   sh lda  .a psh  sl lda
   pshhx  th ldhx ( !)            1 ,x sta ( lo)
                        2 ,s lda  0 ,x sta ( hi)  pulhx
   .a pul  4 # aix  rts  ;c

.then

