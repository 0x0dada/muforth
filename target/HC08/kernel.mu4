( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HC08 Forth kernel

__meta

target

( Stack ops.)
macro _drop  2 # aix  ;m

code dup  ( a - a a)
   th lda  xh sta  tl lda  ( fall through)

label dpush
   _dpush  rts  ;c

code over  ( a b - a b a)
   sh lda  xh sta  sl lda  dpush j  ;c

code nip  ( a b - b)
   tl lda  sl sta  th lda  sh sta  ( top -> sec)  ( fall through)  ;c

code drop
   _drop  rts  ;c

code swap  ( a b - b a)
   th lda  xh sta  sh lda  th sta  xh lda  sh sta
   tl lda  xh sta  sl lda  tl sta  xh lda  sl sta  rts  ;c

( Return stack ops.)
label _r  ( move to R; needs to be room above return address)
   th lda  2 ,s sta  tl lda  3 ,s sta  ' drop j  ;c

label r_  ( move from R; needs to be value above return address)
   2 ,s lda  xh sta  3 ,s lda  dpush j  ;c

( >r aka push will _compile_ -2 # ais, then call to _r )
( r> aka pop will _compile_ call to r_, then 2 # ais )

code -rot  ( a b c - c a b)
   here 2 +a c  ( call rot, then fall thru)  ;c

code rot   ( a b c - b c a)
   -- : rot  >r swap  r< swap ;
   -2 # ais  _r c  ' swap c  r_ c  2 # ais  ' swap j  ;c

code invert
   tl com  th com  rts  ;c

code negate
   tl neg  begin  .a clr  th sbc  th sta  rts  ;c

code dnegate
   sl neg         .a clr  sh sbc  sh sta
                  .a clr  tl sbc  tl sta  again  ;c

( XXX A few test literals.)
code #0
   xh clr  .a clr  rts  ;c

code #-1
   "0ff # lda  xh sta  rts  ;c

code #smax
   "7f # lda  xh sta  "0ff # lda  rts  ;c

code #smin
   "80 # lda  xh sta  .a clr  rts  ;c

( Binary ops.)
code -
   ' negate c  ( fall thru)  ;c

code +
   _dpop
label #+
           tl add  tl sta
   xh lda  th adc  th sta  rts  ;c

code and
   _dpop
label #and
           tl and  tl sta
   xh lda  th and  th sta  rts  ;c

code or
   _dpop
label #or
           tl ora  tl sta
   xh lda  th ora  th sta  rts  ;c

code xor
   _dpop  ( tl -> A, th -> xh, second -> top)
label #xor
           tl eor  tl sta
   xh lda  th eor  th sta  rts  ;c

( Basic double-length - 32-bit - support.)
code d-
   ' dnegate c  ( fall thru)  ;c

code d+
   s0 lda  t0 add  s0 sta
   s1 lda  t1 adc  s1 sta
   s2 lda  t2 adc  s2 sta
   s3 lda  t3 adc  s3 sta  4 # aix  rts  ;c

( Flags and tests.)
code 0=
   tl lda  th ora  1 # sub ( Z -> C)  ( fall thru)

label makeflag  ( C -> -1, NC -> 0)
   .a clr  0 # sbc  tl sta  th sta  rts  ;c

code 0<
   th lsl ( N -> C)  makeflag j  ;c

label compare  ( subtract top from second, but don't save the result)
   sl lda  tl sub  sh lda  th sbc  2 # aix  rts  ;c

( u< and < require that we first push literal values; there is no
  "shortcut" like with the other 2ops, because the values are in the wrong
  order!)

label #u<
   _dpush  ( 1 byte longer than a call; a lot faster - 12~?)
code u<
   compare c  makeflag j  ;c

label #<
   _dpush  ( 1 byte longer than a call; a lot faster - 12~?)
code <
   compare c  < if  sec  makeflag j  ( true)  then
                    clc  makeflag j  ( false)  ;c

( Shifts.)
code 2*
   tl lsl  th rol  rts  ;c

code 2/
   th asr  tl ror  rts  ;c

code u2/
   th lsr  tl ror  rts  ;c  ( I could share ror with 2/, but is it worth it?)


( Memory access.)
.ifdef two-byte-scratch

( Loading HX from the D stack this way requires that it be big-endian,
  which in turn requires having two bytes of scratch space.

  th ldhx : 3 bytes, 5~
  We could also do this:
     th lda [ H]  tl ldx  .a psh  .h pul  : 6 bytes, 11~  not great!!
)

macro pshhx  .x psh  .h psh  ;m
macro pulhx          .h pul  .x pul  ;m

code c@  ( a - byte)
   pshhx  th ldhx ( !)  0 ,x lda  pulhx
   th clr  tl sta  rts  ;c

code @  ( a - word)
   .a psh  ( room for hi byte)
   pshhx  th ldhx ( !)  0 ,x lda ( hi)  2 ,s sta
                        1 ,x lda ( lo)            pulhx
   tl sta  .a pul  th sta  rts  ;c

code c!  ( byte a)
   sl lda  pshhx  th ldhx  0 ,x sta  pulhx  4 # aix  rts  ;c

code !  ( word a)
   sh lda  .a psh  sl lda
   pshhx  th ldhx ( !)            1 ,x sta ( lo)
                        2 ,s lda  0 ,x sta ( hi)  pulhx
   .a pul  4 # aix  rts  ;c

.then

