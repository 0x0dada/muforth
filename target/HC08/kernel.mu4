( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

loading HC08 Forth kernel

__meta

target

-- ------------------------------------------------------------------------
-- Stack layout
-- ------------------------------------------------------------------------

.ifndef two-byte-scratch

( To make use of literals easier, we keep one "scratch" byte allocated on
  the D stack, at 0,x. Below this is top, and below that, second. Like
  this:

     |      |      |
     +------+------+
  4  |  sh  |  sl  |  3   second
     +------+------+
  2  |  th  |  tl  |  1   top
     +------+------+
  0  |  xh  |             scratch high
     +------+

  An odd feature of this arrangement is that the data stack is
  little-endian, so we cannot use 16-bit instructions - like ldhx - to
  access it.)

macro sh  4 ,x  ;m
macro sl  3 ,x  ;m
macro th  2 ,x  ;m
macro tl  1 ,x  ;m
macro xh  0 ,x  ;m

( And for double-length values:)

macro s0  7 ,x  ;m  ( second, lsb)
macro s1  8 ,x  ;m
macro s2  5 ,x  ;m
macro s3  6 ,x  ;m  ( second, msb)
macro t0  3 ,x  ;m  ( top, lsb)
macro t1  4 ,x  ;m
macro t2  1 ,x  ;m
macro t3  2 ,x  ;m  ( top, msb)

.else  ( use two bytes of "scratch" space on D stack)

( To make use of literals easier, we keep two "scratch" bytes allocated on
  the D stack, at 0,x and 1,x. Below this is top, and below that, second.
  Like this:

     |      |      |
     +------+------+
  4  |  sh  |  sl  |  5   second
     +------+------+
  2  |  th  |  tl  |  3   top
     +------+------+
  0  |  xh  |  xl  |  1   scratch
     +------+------+
)

macro sl  5 ,x  ;m
macro sh  4 ,x  ;m
macro tl  3 ,x  ;m
macro th  2 ,x  ;m
macro xl  1 ,x  ;m
macro xh  0 ,x  ;m

( And for double-length values:)

macro s0  9 ,x  ;m  ( second, lsb)
macro s1  8 ,x  ;m
macro s2  7 ,x  ;m
macro s3  6 ,x  ;m  ( second, msb)
macro t0  5 ,x  ;m  ( top, lsb)
macro t1  4 ,x  ;m
macro t2  3 ,x  ;m
macro t3  2 ,x  ;m  ( top, msb)

.then

-- ------------------------------------------------------------------------
-- Literal loading.
--
-- The low half is put into A, the high half into xh - 0,x, on the data
-- stack.
--
-- If high half and low half are equal and non-zero,
--    half # lda  xh sta  ( 3 bytes)
-- Otherwise:
--
-- High half:
-- If hi =  0, xh clr          ( 1 byte)
-- If hi =  1, xh clr  xh inc  ( 2 bytes)
-- If hi = -1, xh clr  xh dec  ( 2 bytes)
-- Otherwise, #hi lda  xh sta  ( 3 bytes)
--
-- Low half:
-- If lo = 0,  .a clr   ( 1 byte)
-- Otherwise,  #lo lda  ( 2 bytes)
-- ------------------------------------------------------------------------

( Stack ops.)
code dup  ( a - a a)
   th lda  xh sta  tl lda  ( fall through)

label dpush  ( A -> tl, xh -> th)
   -2 # aix ( xh -> th)  tl sta  rts  ;c

macro dpop   ( tl -> A, th -> xh)
   tl lda  2 # aix  ( th -> xh)  ;m

code over  ( a b - a b a)
   sh lda  xh sta  sl lda  dpush j  ;c

macro drop  2 # aix  ;m

code nip  ( a b - b)
   tl lda  sl sta  th lda  sh sta  ( top -> sec)  drop  rts  ;c

code swap  ( a b - b a)
   th lda  xh sta  sh lda  th sta  xh lda  sh sta
   tl lda  xh sta  sl lda  tl sta  xh lda  sl sta  rts  ;c

( Return stack ops.)
code _r  ( move to R; needs to be room above return address)
   th lda  2 ,s sta  tl lda  3 ,s sta  drop  rts  ;c

code r_  ( move from R; needs to be value above return address)
   2 ,s lda  xh sta  3 ,s lda  dpush j  ;c

( >r aka push will _compile_ -2 # ais, then call to _r )
( r> aka pop will _compile_ call to r_, then 2 # ais )

-- code -rot  ( a b c - c a b)  rot c  ( fall thru)
-- : rot   ( a b c - b c a)  push  swap  pop  swap ;

code -rot  |here 2 +a c  ( call rot, then fall thru)
label rot
   -2 # ais  _r c  swap c  r_ c  2 # ais  swap j  ;c

( XXX inline? It's four bytes, so it's longer than a call..)
code invert
   tl com  th com  rts  ;c

code negate
   tl neg  begin  .a clr  th sbc  th sta  rts  ;c

code dnegate
   sl neg         .a clr  sh sbc  sh sta
                  .a clr  tl sbc  tl sta  again  ;c

( Binary ops.)
code -
   negate c  ( fall thru)

label +   dpop
label +_imm     tl add  tl sta
        xh lda  th adc  th sta  rts  ;c

code  and   dpop
label and_imm     tl and  tl sta
          xh lda  th and  th sta  rts  ;c

code  or   dpop
label or_imm     tl ora  tl sta
         xh lda  th ora  th sta  rts  ;c

code  xor   dpop
label xor_imm     tl eor  tl sta
          xh lda  th eor  th sta  rts  ;c

( Basic double-length - 32-bit - support.)
code d-
   dnegate c  ( fall thru)  ;c

code d+
   s0 lda  t0 add  s0 sta
   s1 lda  t1 adc  s1 sta
   s2 lda  t2 adc  s2 sta
   s3 lda  t3 adc  s3 sta  4 # aix  rts  ;c

( Flags and tests.)
code 0=
   tl lda  th ora  1 # sub ( Z -> C)  ( fall thru)

label makeflag  ( C -> -1, NC -> 0)
   .a clr  0 # sbc  tl sta  th sta  rts  ;c

code 0<
   -- th lda  .a lsl ( N -> C)  makeflag j  ;c
   th lsl ( N -> C)  makeflag j  ;c  ( 1 byte shorter; 1~ slower)

code true   ( put -1 into top - don't push!)
   sec  makeflag j  ;c

code false  ( put  0 into top - don't push!)
   clc  makeflag j  ;c

code  u<   dpop
label u<_imm    tl sub
        xh lda  th sbc
   ( order of subtract backwards, so use u> )
   false u> until  true j  ;c

code  <    dpop
label <_imm     tl sub
        xh lda  th sbc
   ( order of subtract backwards, so use > )
   false > until  true j  ;c

( Memory access.)
.ifdef two-byte-scratch

( Loading HX from the D stack this way requires that it be big-endian,
  which in turn requires having two bytes of scratch space.

  th ldhx : 3 bytes, 5~
  We could also do this:
     th lda [ H]  tl ldx  .a psh  .h pul  : 6 bytes, 11~  not great!!
)

macro pshhx  .x psh  .h psh  ;m
macro pulhx          .h pul  .x pul  ;m

code c@  ( a - byte)
   pshhx  th ldhx ( !)  0 ,x lda  pulhx
   th clr  tl sta  rts  ;c

code @  ( a - word)
   .a psh  ( room for hi byte)
   pshhx  th ldhx ( !)  0 ,x lda ( hi)  2 ,s sta
                        1 ,x lda ( lo)            pulhx
   tl sta  .a pul  th sta  rts  ;c

code c!  ( byte a)
   sl lda  pshhx  th ldhx  0 ,x sta  pulhx  4 # aix  rts  ;c

code !  ( word a)
   sh lda  .a psh  sl lda
   pshhx  th ldhx ( !)            1 ,x sta ( lo)
                        2 ,s lda  0 ,x sta ( hi)  pulhx
   .a pul  4 # aix  rts  ;c

.then

