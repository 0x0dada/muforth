( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2011 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( The USB version of the serial byteloader. Trying to fit it into less than
  512 bytes - I actually have 428 bytes of room!)

loading HCS08 USB chat (target)

hex

__meta

( Our device descriptor. Note: all USB data is little-endian.) 
label device-descriptor
   12 c, ( bLength)
   01 c, ( bDescriptorType = device)
   00 c, 02 c, ( bcdUSB = 02.00)
   00 c, ( bDeviceClass - composite device - look to interfaces for class)
   00 c, ( bDeviceSubClass)
   00 c, ( bDeviceProtocol)
   10 c, ( bMaxPacketSize0)
   0a2 c, 15 c, ( idVendor = Freescale)
   0de c, 0c0 c, ( idProduct = c0de)
   01 c, 00 c, ( bcdDevice = 00.01)
   00 c, ( iManufacturer - string index = none)
   00 c, ( iProduct - string index = none)
   00 c, ( iSerialNumber - string index = none)
   01 c, ( bNumConfigurations)

label config-descriptor
   09 c, ( bLength)
   02 c, ( bDescriptorType = configuration)
   12 c, 00 c, ( wTotalLength = configuration + interfaces + endpts)
   01 c, ( bNumInterfaces)
   01 c, ( bConfigurationValue; starts from 1, unlike string indices)
   00 c, ( iConfiguration - string index = none)
   80 c, ( bmAttributes)
   7d c, ( bMaxPower, in 2mA increments = 250mA)

label interface-descriptor
   09 c, ( bLength)
   04 c, ( bDescriptorType = interface)
   00 c, ( bInterfaceNum)
   00 c, ( bAlternateSetting)
   00 c, ( bNumEndpoints - in _addition_ to endpoint pair 0)
   0ff c, ( bInterfaceClass = vendor-specific)
    00 c, ( bInterfaceSubClass)
    00 c, ( bInterfaceProtocol)
   00 c, ( iInterface - string index = none)

.ifdef already-done

label SendByte  rts  ;c
label emulated-swi
   ( jsr/bsr has already pushed PC)
   .x psh  .a psh  tpa ( flags to A)  .a psh  sei
   .h psh
   SendByte again  ;c

( If the chat interaction changes the PC on this stack frame to point
  somewhere other than _after_ the __swi, not all is lost - since we got
  here via a _call_ from reset, we'll return to _that_ loop, and re-enter
  the SWI.

  On the other hand, if the PC remains unaltered, an RTI from the SWI's
  stack frame wil simply return here, and we'll take the "exception" again.)

label interact
   begin  emulated-swi c  again  ;c

Vreset handler
   @ram #ram + # ldhx
   txs

   -- Turn off watchdog
   -- Can't use bit ops! SOPT1 not in z-page.
   -- Clear bits 6 & 7. These have different meanings on different chips,
   -- but at least for the JS and QG clearing both bits will shut off the
   -- watchdog.
   SOPT1 ) lda  3f # and  SOPT1 ) sta

   ( Set up the xtal oscillator and PLL. For USB we need a 48M clock - 24M
     bus clock. Getting there takes a few steps...)

   -- FEI ==> FBE
   -- Start xtal osc - we've got a 4M xtal on the board.
   -- Datasheet and appnotes have you set BDIV to /1 here, but since we're
   -- running off untrimmed internal osc still, that's a bad idea. We leave
   -- that until the end.
   %01_11_0110 # MCGC2 ) mov  ( keep BDIV at /2, start ext osc)
   -- wait for osc to start (OSCINIT)
   begin  MCGSC 1  bset? until
   -- switch to ext clock (FBE): CLKS=01 (ext), RDIV=001 (/2), IREFS=0
   -- NOTE: We've set RDIV for PLL (4M/2 == 2M), but we're still running
   -- the FLL, so this will temporarily run it out of spec... DS says this
   -- is ok, as long as we switch quickly!
   -- %10_111_000 # MCGC1 ) mov  -- from when I thought I needed to keep
                                 -- RDIV set for FLL
   %10_001_000 # MCGC1 ) mov

   -- Wait until we've switched clocks
   begin  MCGSC ) lda  %0001_1100 # and  ( mask IREFST and CLKST)
          %0000_1000 # cmp  0= until  ( IREFST=0, CLKST=10)

   -- FBE ==> PBE
   -- We're spinning up the PLL. We're set up to divide our 4M xtal by two
   -- (RDIV) to get 2M (PLL freq); let's multiply that by 24 (VDIV) to get
   -- 48M, which is our target clock.
   %0100_0110 # MCGC3 ) mov    -- PLLS=1, VDIV=0110 (*24)

   begin  MCGSC 5 bset?  until   -- loop until PLLST set
   begin  MCGSC 6 bset?  until   -- loop until LOCK set

   -- PBE ==> PEE
   MCGC1 7 bclr  -- set CLKS to 00 (PLL)
   begin  MCGSC 2 bset?  until
   begin  MCGSC 3 bset?  until   -- loop until CLKST=11

   -- Lastly, set BDIV to /1
   MCGC2 6 bclr

   #24000 khz>fcdiv  # lda   FCDIV ) sta

   -- Configure SCI for 115200 bps

   SCIBDH ) clr        ( baud rate divisor, high)
   #13 # SCIBDL ) mov  ( baud rate divisor, low)
                       ( yields 115200 from 24M bus clock)
   0c # SCIC2 ) mov    ( enable rcvr, xmitter)

   -- Initialise USB
   -- Since we're only using ep0 I'll just refer to IN and OUT; understand
   -- that I mean ep0 IN and ep0 OUT.

.then

( USB buffer descriptors)
1860 equ in-control
1861 equ in-count
1862 equ in-bufaddr
1863 equ out-control
1864 equ out-count
1865 equ out-bufaddr

1880 equ in-buffer
1890 equ out-buffer

( Useful aliases for buffer addresses - for control requests.)
out-buffer 0 + equ bmRequestType
out-buffer 1 + equ bRequest
out-buffer 2 + equ wValue
out-buffer 3 + equ wValueHi
out-buffer 4 + equ wIndex
out-buffer 5 + equ wIndexHi
out-buffer 6 + equ wLength
out-buffer 7 + equ wLengthHi

2 zvar memptr
1 zvar memcount
1 zvar bufptr  ( offset into IN or OUT buffer)

target

label start-usb
   08 # lda  in-bufaddr ) sta    --  IN buffer @1880
     .a clr  in-control ) sta    --  IN will return NAK
   0c # lda  out-bufaddr ) sta   -- OUT buffer @1890
   10 # lda  out-count ) sta     -- expect 16 bytes
  0c8 # lda  out-control ) sta   -- accept SETUP or OUT/DATA0
   01 # CTL ) mov          -- enable USB module
   45 # USBCTL0 ) mov      -- turn on pullup, vreg, and PHY
   begin  INTSTAT 0 bset?  until  ( wait for USBRSTF)
   0ff # INTSTAT ) mov     -- clear all flags
   0d # EPCTL0 ) mov       -- enable ep0 as control endpt
   rts  ;c

( We always want to queue up either a short packet or a zero-length packet
  as the last packet. In particular this means that if the last part of the
  string _exactly_ fills a packet, we queue up a zero-length to follow it,
  to make sure to signal to the host that this is the end of the data
  stage. See USB spec 8.5.3.2.)

label copy-to-in
   bufptr ) clr
   memcount ) ldx  0!= if  txa
      10 # cmp  u>= if  ( whole packet)  10 # lda  then
      .a psh  begin
         memptr ) ldhx  0 ,x lda  1 # aix  memptr ) sthx
         .h clr  bufptr ) ldx  in-buffer ,x sta  .x inc  bufptr ) stx
         memcount ) dec
      0 ,s decz? until  .a pul
   then
   in-count ) stx  rts  ;c

.ifdef not-for-ram-test
label copy-from-out
   out-count ) ldx  memcount ) sta  bufptr ) clr
   begin
      .h clr  bufptr ) ldx  out-buffer ,x lda  .x inc  bufptr ) stx
      memptr ) ldhx  0 ,x sta  1 # aix  memptr ) sthx
   memcount ) decz? until  rts  ;c
.then

label toggle  ( HX points to EP buffer control byte)
   0 ,x lda  40 # and ( data0/1)  0c8 # eor  0 ,x sta  rts  ;c

( Get ready to receive another SETUP token.)
label expect-setup-token
   10 # lda  out-count ) sta  0c8 # lda  out-control ) sta
   CTL 5 bclr ( TSUSPEND off - resume processing)
   rts  ;c

label prepare-next-in
   ( copy data)  copy-to-in c
   ( toggle DATA0/1)  in-control # ldhx  toggle c
   expect-setup-token j  ;c

label get-device-descriptor
   device-descriptor # ldhx  
   12 # lda  ( fall thru)

( A register has length of string to return. If wLength u< A, use wLength
  instead.)

label prepare-first-in
   ( addr in HX)  memptr ) sthx
   wLength ) cmp  u> if  wLength ) lda  then
   ( count in A)  memcount ) sta
   prepare-next-in j  ;c
   
label get-config-descriptor
   config-descriptor # ldhx
   12 # lda  prepare-first-in j  ;c

label set-address
label set-config
   ( do nothing, but return status)  ( fall thru)

( Prepare to return status - a zero-length IN transaction. Also be ready to
  accept another SETUP even if it would mean abandoning the current
  transfer. This is what the USB spec says we have to do.)

label finish-control-write
   ( Setup IN status stage)
   .a clr  in-count ) sta  ( zero-length DATA1 transaction)
   0c8 # lda  in-control ) sta
   expect-setup-token j  ;c

label get-descriptor
   wValueHi ) lda  ( get descriptor type requested)
   01 # cmp  get-device-descriptor 0!= until
   02 # cmp  get-config-descriptor 0!= until
   ( unknown, fall thru)

label vendor-request
   ( NYI - this is where the byteloader will live. ;-)

label stall
   EPCTL0 1 bset ( STALL)  rts  ;c

label standard-request
   bRequest ) lda
   05 # cmp  set-address 0!= until
   06 # cmp  get-descriptor 0!= until
   09 # cmp  set-config 0!= until
   stall j  ;c

( Receipt of SETUP has set out-control's data toggle to 0. Set in-control's
  as well.)

label setup-token
   .a clr  in-control ) sta
   bmRequestType ) lda  60 # and  standard-request 0!= until
                        40 # cmp  vendor-request 0!= until
            ( unknown)  stall j  ;c

( We're going to arrange things on the host, at least for the USB
  byteloader, so that control writes that have a data stage consisting of
  only _one_ OUT transaction. Reads are a different story: in order to
  return the descriptors, and to keep our usage of USB endpoint RAM to a
  minimun, we have to break reads up into small-ish chunks.)

label out-or-setup-token
   out-control ) lda  3c # and  34 # cmp  setup-token 0!= until
   ( OUT)
   ( Until I implement some custom commands this can only be a status
     transaction for a control read.)
   -- out-count ) lda  expect-setup-token 0!= until ( status)
   -- ( do data OUT here)  rts  ;c
   expect-setup-token j  ;c

( An IN token is either part of a data stage of a control read, or it is
  the status stage of a control write. Status IN's are always zero bytes
  long; sometimes the last IN of the data stage is also zero bytes long. In
  either case, if the last IN was zero bytes long, we can expect no further
  IN tokens.

  We can't set the address immediately. The USB spec says that at every
  stage of a control transfer the device address must remain constant.
  Before the set-address command we are at the default address - 0. We
  can't change this until after the status stage of this control transfer,
  so we set a flag instead. Actually, I think we can do _nothing_ - except
  maybe set a flag about what stage we're in. By always checking ADDR after
  a status IN we can be sure to set our address at the right time.)

label in-token
   ( If last IN was a full packet, ready some more data.)
   in-count ) lda  10 # cmp  prepare-next-in 0!= until

   ( If last packet was zero-length, check to make sure our address has
     been set.)
   .a tst 0= if
      ADDR ) tst  0= if  wValue ) lda  ADDR ) sta  then
   then
   ( Last packet was partial or zero-length; no further IN's expected.)
   .a clr  in-control ) sta  ( further IN's will return NAK)
   expect-setup-token j  ;c
   
label process-usb
   INTSTAT 3 bset? if ( TOKDNEF)
      STAT ) lda  INTSTAT 3 bset  ( ack TOKDNEF)
      0f8 # and  out-or-setup-token 0!= until
       08 # cmp  in-token 0!= until
      ( not EP0; ignore)  rts
   then
   INTSTAT 7 bset? if ( STALLF)
      INTSTAT 7 bset  ( ack STALL)
      EPCTL0 1 bclr ( remove EPSTALL)
   then
   rts  ;c

code usb-reset
   -- USBCTL0 7 bset  ( USBRESET)
   80 # USBCTL0 ) mov
   begin  USBCTL0 7 bclr?  until  rts  ;c

code usb
   start-usb c
   begin  process-usb c  again
   10 # lda  .a psh  begin
      .a clr  .a psh  begin
         .a psh  begin  process-usb c  0 ,s decz? until  .a pul
      0 ,s decz? until  .a pul
   0 ,s decz? until  .a pul  rts  ;c
   
--   begin  interact bsr  again  ;c
