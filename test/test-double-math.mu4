( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2010 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)


==========================================================================
code from earlier (double-number) muforth startup (but edited for
readability)
==========================================================================
variable dpl    ( location of , or . )
variable radix

: radixer  create  does>  radix ! ;

( In order to keep this compilable by the target -before- it knows how to
  parse numbers - which is what we're defining now! - let's keep the
  calculated constants. I thought of converting - and in fact started to
  convert - these to numbers that the -metacompiler- could parse and
  compile, but that limits us to loading this code -only- via the
  metacompiler. I like the idea that the target is going to bootstrap
  itself!)

2 2* 2* dup 2* ( 16!)  radixer hex
dup            (  8!)  radixer octal
2 +            ( 10!)  radixer decimal  
2                      radixer binary

decimal
( On and off)
: on  -1 swap !  ;
: off  0 swap !  ;

( Punctuation in numbers: sign, radix, decimal point, separators.)
: punct  ( a u ch - a' u' matched)
   over if ( still chars to process)  swap >r  over c@  xor if
   ( no match)  r>            0 ^  then  ( return false)
   ( match)     r>  1 -1 v+  -1 ^  then  ( a+1 u-1 true)
   ( end of input)  drop  r> drop ;      ( return to caller's caller!)

: ?sign  char - punct  if  -1 ^  then  0 ;

: ?hex  char " punct  if  hex ^  then
        char # punct  if  decimal ^  then
        char ' punct  if  octal ^  then
        char % punct  if  binary ^  then ;

( . resets dpl; others leave it unchanged; this means that embedding . in a
  number causes a double number to be pushed, and dpl set to the count of
  digits _after_ the _last_ . in the number.)

: ?dot  char . punct  if  dpl off ^  then
        char , punct  if   ^  then
        char - punct  if   ^  then
        char / punct  if   ^  then
        char : punct  if   ^  then
        char _ punct  if   ^  then   complain ;

: digit?    ( ch - digit -1 | junk 0)
   char 0 -  [ 2 2* 2* 1+ ]  ( 9)   over u< if  ( !decimal)
          [ 2 2* 2* 2* 1+ ]  ( 17)  - 
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, UPPERCASE)
          [ 2 2* 2* 2* 2* ]  ( 32)  - 
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, lowercase)
      ( junk)  0 ^
   then  then  ( hex) [ 2 2* 1+ 2* ]  ( 10) +  then  ( decimal)
   dup radix @  u<  ;

: @digit?   ( a - a digit -1 | a junk 0)   dup c@  digit?  ;

: *digit  ( ud a digit - ud*base+digit a)
   swap >r ( a)  swap ( lo digit hi)
   radix @ um*  drop  rot ( digit hi*radix lo)
   radix @ um*            ( digit hi*radix lo*radix_lo lo*radix_hi)
   d+
   r>  dpl @ 0< 1+  dpl +!  ;

: /digit   ( ud - udquot urem)
   0 radix @ um/mod     ( 0:hi / radix -> urhi uqhi)  >r
     radix @ um/mod  ( urhi:lo / radix -> urlo uqlo)  r> rot  ;

( ANS compatible!)
: >number  ( ud1 a1 c1 - ud2 a2 c2)  ( a2 is first unconvertible char)
   =if  for  @digit?  while  *digit 1+ next  0 ^  then
                                drop  r>  then  ;

: fancy-number  ( a u - d)
   2>r  0 0  2r>  ?radix  ?sign >r  dpl on
   begin  >number  =while ( still chars)  ?dot  repeat
   2drop  r>  if dnegate then  ;

: (number)  ( a u - d)
   radix @ >r  fancy-number  r> radix !  throw  ;

-: (number)  dpl @  0< if  drop literal ^  then  swap  literal literal ;
'number, !

-: (number)  dpl @  0< if  drop  then  ;
'number !

( Make it easy to call "number" and "number," from interpreter mode words.)
: number   'number  @execute ;
: number,  'number, @execute ;

==========================================================================
existing code in current startup with 32-bit numbers
==========================================================================

: *digit  ( u a digit - u*base+digit a)
   swap >r ( a)  swap ( dig u)  radix @ * +  r>  dpl @ 0< 1+  dpl +!  ;

( ANS compatible! - or at least it was when it converting with double numbers.)
: >number  ( u1 a1 c1 - u2 a2 c2)  ( a2 is first unconvertible char)
   =if  for  @digit?  while  *digit 1+ next  0 ^  then
                                drop  r>  then  ;

( If >number can't convert any digits, complain.)
: digits   ( u1 a1 c1 - u2 a2 c2 u3)
   dup >r ( chars left)  >number  r> over - ( count of digits converted)
   0= if  drop complain  then ;

: number  ( a u - n)
   radix preserve ( always reset the radix, even in case of error)
   2>r  0  2r>  ?sign >r  ?radix  dpl on
   begin  digits  =while ( still chars)  ?dot  repeat
   2drop  r>  if negate then  ;

