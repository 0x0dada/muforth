( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2010 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)


( Trying out, after all these years, the techniques that Klaus Schleisiek
  presented in 1984 [at FORML] and that I read about in 1993.

  The basic idea is that, in addition to return address pointers
  [saved IPs], there are stack frames on the return stack. These can be for
  any purpose, but we're interested here the following: trap frames, local
  variable storage, and "fluid" rebinding of variables - aka dynamic
  scoping.)

( Here is a picture of the return stack, with high memory towards to top of
  the page, and low memory further down:

  ^   |                    |
  |   +--------------------+
  |   |  prev return addr  |
  |   +--------------------+
  |   |        ...         |   several cells could be here; depends on the
  |   +--------------------+   type of frame
  |   |        ...         |     
  |   +--------------------+
  |   |   cfa of cleanup   |   
  |   +--------------------+
  +---+     prev frame     |<--- fp
      +--------------------+
      |   ip of restore    |<--- rp      restore just calls unlink
      +--------------------+                                          )

variable fp    ( the "top" - most recently pushed - frame)
               ( fp points to a frame ptr, which pts to a frame ptr...)

( link creates a new frame. It fetches the cfa of the following word and
  pushes it onto the return stack. This is the cleanup routine. Then it
  links this frame into the list rooted at fp, and then returns to its
  caller, skipping the following cfa. link is called by a word that builds
  a new stack frame.)

: link     r> dup @  >r         ( fetch following cfa & push to r)
           fp @ >r  rp@ fp !    ( link this frame to previous)
           cell+ >r             ( skip fetched cfa) ;

( unlink undoes what link did. It unlinks the frame from the list rooted at
  fp, and then runs the cleanup routine, which will do whatever is
  necessary to de-allocate the frame and undo any state changes made by the
  word that called link.)

: unlink   r>  ( save return address)
           fp @ rp!  r> fp !    ( unlink frame)
           r> execute           ( execute cleanup word)
           >r  ( restore return address) ;

( unwind is useful in the context of exceptions. It starts at fp and
  unlinks each frame in turn until fp points to a frame with a zero link.)

: unwind   r>  ( save return address)
           -- begin  fp @ @  while  unlink  repeat
           begin  fp @  while  unlink  repeat
           >r  ( restore return address) ;


.ifdef muFORTH

( colon creates a colon word that when executed pushes the address of the
  first word in its body.)

: colon  0 constant  here  dup cell- !  -]  does> ;
colon  remove      unlink ;   ( remove pushes IP)
.else ( target)
create remove  -]  unlink ;   ( remove pushes IP)
.then


( Now some interesting applications.)

( Restore saved value of a variable.)
: restore
   r>  ( ra)
   r> r>  ( a value)  swap  !
   >r  ( ra) ;

( Preserve the value of a variable for the duration of the execution of the
  calling word.)

: preserve  ( a)  ( address of variable)
   r>  ( ra)
   swap dup @  ( a value)  >r >r  link restore ( push cleanup)
   remove >r  ( normal return - unlink and cleanup)
   >r  ( ra) ;


( Deallocate local variables.)
: unroom
   r>  ( ra)
   r>  ( #cells)  rp+!  ( rp+! takes cell count!)
   >r  ( ra) ;

( Allocate space for local variables.)
( NOTE: do -not- try to use a for loop to push cells! It doesn't work! The
  return stack is being used to store the loop index, but you're busy
  pushing stuff there! All hell breaks loose! If you absolutely want to
  zero locals as they are allocated, do a begin/until loop with the count
  on the data stack.)

: room  ( #cells)
   r>  ( ra)
.ifdef zeroed-locals
   swap dup  begin  "55aa55aa >r  1-  dup 0= until  drop
.else
   swap dup  negate rp+!  ( allocate)
.then
   ( #cells)  >r
   link unroom
   remove >r  ( normal return - unlink and cleanup)
.then
   >r  ( ra) ;


( Jump to the outermost frame and "return" to it.)
: undo  r>  fp @  cell- rp!  >r ;

( Let's talk to the user while these stack frames are set up, so we can
  dump and debug them.)

: test-frames
   ( allocate a bunch of stuff)
   radix preserve  binary
   radix preserve  hex
   4 room
   -- token number
   quit
   ( dealloc) ;

: tt   test-frames ;
: ff   rp@  4 rp+!  rp@  -4 rp+!  ;
: gg   ff ;
: uw   rp@  unwind  rp@ radix @ ;

